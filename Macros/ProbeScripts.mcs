ProbeScripts = {}
local wx = wx or require("wx")

-- Request maintenance dialog from ScreenLoad via PLC register
-- Returns true to continue, false to stop (user chose to perform maintenance)
local function RequestMaintenance()
    local inst = mc.mcGetInstance()
    local hMaintReq = mc.mcRegGetHandle(inst, "iRegs0/MaintenanceRequest")
    local hMaintResult = mc.mcRegGetHandle(inst, "iRegs0/MaintenanceResult")

    if hMaintReq == 0 then return true end

    -- Reset result and set request
    if hMaintResult ~= 0 then
        mc.mcRegSetValue(hMaintResult, 0)
    end
    mc.mcRegSetValue(hMaintReq, 1)

    -- Wait for PLC to process and clear the register
    -- wxSafeYield allows PLC to run while we wait
    local timeout = os.clock() + 30  -- 30 second timeout for user interaction
    while mc.mcRegGetValue(hMaintReq) == 1 and os.clock() < timeout do
        wx.wxMilliSleep(50)
        wx.wxSafeYield()
    end

    -- Check result: 2 = perform maintenance (stop)
    if hMaintResult ~= 0 and mc.mcRegGetValue(hMaintResult) == 2 then
        return false  -- Stop probing
    end

    return true  -- Continue probing
end

-- Performs a protected move that will retry if it doesn't reach target
-- Uses probe signal to detect collisions - if probe triggers, we hit something
function ProbeScripts.ProtectedMove(inst, moveType, X, Y, Z, feedrate)
    local RETRY_FEEDRATE_FACTOR = 0.5  -- retry at half speed
    local MIN_RETRY_FEEDRATE = 10  -- minimum feedrate for retry

    -- Default feedrate if not provided
    feedrate = feedrate or 100

    -- Store starting machine positions for return-to-start
    local startXMachine = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local startYMachine = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
    local startZMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Get work positions for building move commands
    local startXWork = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local startYWork = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    local startZWork = mc.mcAxisGetPos(inst, mc.Z_AXIS)
    
    -- Calculate target positions based on move type
    local targetX, targetY, targetZ
    if moveType == "mach" then
        targetX = X or startXMachine
        targetY = Y or startYMachine
        targetZ = Z or startZMachine
    elseif moveType == "work" then
        targetX = X or startXWork
        targetY = Y or startYWork
        targetZ = Z or startZWork
    elseif moveType == "inc" then
        targetX = startXWork + (X or 0)
        targetY = startYWork + (Y or 0)
        targetZ = startZWork + (Z or 0)
    else
        error(string.format("Invalid move type '%s'. Must be 'work', 'mach', or 'inc'", tostring(moveType)))
    end
    
    -- Attempt protected move - success = probe NOT triggered (no collision)
    local function attemptMove(feed)
        local MOVE_THRESHOLD = 0.0001  -- Minimum distance to include an axis
        local gcode = ""
        local hasMove = false

        if moveType == "mach" then
            gcode = "G90 G53 G31.1"
            if math.abs(targetX - startXMachine) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" X%.4f", targetX)
                hasMove = true
            end
            if math.abs(targetY - startYMachine) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Y%.4f", targetY)
                hasMove = true
            end
            if math.abs(targetZ - startZMachine) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Z%.4f", targetZ)
                hasMove = true
            end
        elseif moveType == "inc" then
            gcode = "G91 G31.1"
            if X and math.abs(X) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" X%.4f", X)
                hasMove = true
            end
            if Y and math.abs(Y) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Y%.4f", Y)
                hasMove = true
            end
            if Z and math.abs(Z) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Z%.4f", Z)
                hasMove = true
            end
        else  -- work
            gcode = "G90 G31.1"
            if math.abs(targetX - startXWork) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" X%.4f", targetX)
                hasMove = true
            end
            if math.abs(targetY - startYWork) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Y%.4f", targetY)
                hasMove = true
            end
            if math.abs(targetZ - startZWork) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Z%.4f", targetZ)
                hasMove = true
            end
        end

        -- Don't execute if no axes are moving
        if not hasMove then
            return true  -- No movement needed, consider it successful
        end

        gcode = gcode .. string.format(" F%.1f", feed)
        mc.mcCntlGcodeExecuteWait(inst, gcode)

        -- Check if probe triggered (collision detection)
        local probeHandle = mc.mcSignalGetHandle(inst, mc.ISIG_PROBE1)
        local probeTriggered = mc.mcSignalGetState(probeHandle) == 1

        -- Success = probe NOT triggered (no collision)
        -- Failure = probe triggered (hit something)
        if probeTriggered then
            -- Log collision for debugging
            local logPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Logs\\ProtectedMove_Failures.txt"
            local logFile = io.open(logPath, "a")
            if logFile then
                local endXWork = mc.mcAxisGetPos(inst, mc.X_AXIS)
                local endYWork = mc.mcAxisGetPos(inst, mc.Y_AXIS)
                local endZWork = mc.mcAxisGetPos(inst, mc.Z_AXIS)
                local endXMach = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
                local endYMach = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
                local endZMach = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

                logFile:write(string.format("[%s] ProtectedMove Collision:\n", os.date("%Y-%m-%d %H:%M:%S")))
                logFile:write(string.format("  Type: %s, Feed: %.1f\n", moveType, feed))
                logFile:write(string.format("  Start Work: (%.4f, %.4f, %.4f)\n", startXWork, startYWork, startZWork))
                logFile:write(string.format("  Start Mach: (%.4f, %.4f, %.4f)\n", startXMachine, startYMachine, startZMachine))
                logFile:write(string.format("  End Work:   (%.4f, %.4f, %.4f)\n", endXWork, endYWork, endZWork))
                logFile:write(string.format("  End Mach:   (%.4f, %.4f, %.4f)\n", endXMach, endYMach, endZMach))
                logFile:write("  PROBE TRIGGERED - Collision detected\n")
                logFile:write("\n")
                logFile:close()
            end
            return false
        end

        return true  -- Success - no collision
    end
    
    -- First attempt at requested feedrate
    if attemptMove(feedrate) then
        return true
    end

    -- Move failed. Return to start and try again at reduced speed
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f Z%.4f", startXMachine, startYMachine, startZMachine))
    local retryFeedrate = math.max(feedrate * RETRY_FEEDRATE_FACTOR, MIN_RETRY_FEEDRATE)
    if attemptMove(retryFeedrate) then
        return true
    end

    -- Both attempts failed - return to start position
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F200", startXMachine, startYMachine))

    mc.mcCntlSetLastError(inst, string.format("ProtectedMove failed: collision detected after retry. Target(%.4f,%.4f,%.4f)", targetX, targetY, targetZ))
    return false
end


-- Move to work zero for specified axes, handling G68 rotation
-- moveX: boolean to move X axis to 0
-- moveY: boolean to move Y axis to 0
function ProbeScripts.MoveToCenter(inst, moveX, moveY)
    if not moveX and not moveY then
        return true  -- Nothing to do
    end

    -- Check for active G68 rotation
    local g68Active = false
    local savedRotation, savedCenterX, savedCenterY

    if mc.mcCntlGetPoundVar(inst, 4016) == 68 then
        g68Active = true
        -- Save G68 parameters
        savedRotation = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION)
        savedCenterX = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION_X)
        savedCenterY = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION_Y)

        -- Temporarily cancel G68
        mc.mcCntlGcodeExecuteWait(inst, "G69")
    end

    -- Build move command
    local moveCmd = "G90 G1"
    if moveX then
        moveCmd = moveCmd .. " X0"
    end
    if moveY then
        moveCmd = moveCmd .. " Y0"
    end
    moveCmd = moveCmd .. " F200"

    -- Execute the move
    local rc = mc.mcCntlGcodeExecuteWait(inst, moveCmd)

    -- Restore G68 if it was active
    if g68Active then
        mc.mcCntlGcodeExecuteWait(inst, string.format("G68 X%.4f Y%.4f R%.4f",
                                                      savedCenterX, savedCenterY, savedRotation))
    end

    return rc == mc.MERROR_NOERROR
end


-- Returns calibration offset values for each direction
function ProbeScripts.SingleTapCalibrate(inst, feedrate, probeZ)    
    -- Results storage
    local doubleResults = {}
    local singleResults = {
        ["+X"] = {},
        ["-X"] = {},
        ["+Y"] = {},
        ["-Y"] = {}
    }
    
    if probeZ then
        singleResults["-Z"] = {}
    end

    -- Double tap all four sides
    doubleResults["+X"] = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    doubleResults["-X"] = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    doubleResults["+Y"] = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    doubleResults["-Y"] = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
    
    -- Calculate and move to center
    local centerX = (doubleResults["+X"] + doubleResults["-X"]) / 2
    local centerY = (doubleResults["+Y"] + doubleResults["-Y"]) / 2
    
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F100", centerX, centerY))

    if probeZ then
        doubleResults["-Z"] = ProbeScripts.Probe(inst, 5, false, true, nil, nil, false, nil)
    end

    -- Single tap probe calibration moves
    for cycle = 1, 3 do
        singleResults["+X"][cycle] = ProbeScripts.Probe(inst, 1, false, true, nil, feedrate, true, nil)
        singleResults["-X"][cycle] = ProbeScripts.Probe(inst, 2, false, true, nil, feedrate, true, nil)
        singleResults["+Y"][cycle] = ProbeScripts.Probe(inst, 3, false, true, nil, feedrate, true, nil)
        singleResults["-Y"][cycle] = ProbeScripts.Probe(inst, 4, false, true, nil, feedrate, true, nil)
        if probeZ then
            singleResults["-Z"][cycle] = ProbeScripts.Probe(inst, 5, false, true, nil, feedrate, true, nil)
        end
    end

    local calibrationOffsets = {}
    
    for direction, singles in pairs(singleResults) do
        local sum = 0
        for _, singleValue in ipairs(singles) do
            sum = sum + (singleValue - doubleResults[direction])
        end
        calibrationOffsets[direction] = sum / #singles
    end

    return calibrationOffsets
end


-- Core probe function wrapper to .ProbeXYZ (depricated M311)
function ProbeScripts.Probe(inst, direction, setDatum, returnToStart, maxTravel, fastFeed, singleTap, finalRetract)
    -- Abort immediately if machine was stopped (cycle stop, e-stop, etc.)
    local state = mc.mcCntlGetState(inst)
    if state == 0 or state == 1 then  -- IDLE or HOLD
        -- Clean up machine state BEFORE throwing error
        -- This prevents UI lockup even if error propagates uncaught
        pcall(function()
            mc.mcCntlGcodeExecuteWait(inst, "G69")  -- Cancel any G68 rotation
            mc.mcCntlMachineStateClear(inst)
        end)
        error("MACHINE_STOPPED", 0)
    end

    -- Map parameters to ProbeXYZ signature
    local mappedFastFeed = fastFeed or mc.mcCntlGetPoundVar(inst, 516)
    local mappedBackoff = mc.mcCntlGetPoundVar(inst, 519)
    local mappedSlowFeed = singleTap and 0 or mc.mcCntlGetPoundVar(inst, 517)
    local mappedMaxTravel = maxTravel or mc.mcCntlGetPoundVar(inst, 518)
    
    -- Handle finalRetract parameter
    local mappedFinalRetract
    if returnToStart then
        mappedFinalRetract = -1  -- Return to start position
    elseif finalRetract ~= nil then
        mappedFinalRetract = finalRetract
    else
        mappedFinalRetract = mc.mcCntlGetPoundVar(inst, 520)
    end
    
    -- Call ProbeXYZ with mapped parameters
    local machineEdge, workEdge, probeSuccess = ProbeScripts.ProbeXYZ(inst, 
        direction,
        mappedFastFeed,
        mappedBackoff,
        mappedSlowFeed,
        mappedMaxTravel,
        mappedFinalRetract,
        setDatum and 1 or 0
    )

    local edgeValue
    if setDatum then
        edgeValue = 0  -- Always return 0 when setting datum
    else
        edgeValue = workEdge or 0  -- Return workEdge on success, 0 on failure (safer than nil)
    end
    
    return edgeValue, probeSuccess == 1
end


-- Complete ShowDialog wrapper with all functionality preserved
function ProbeScripts.ShowDialog(inst, title, fields, profileSection, options)
    options = options or {}
    local tempPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Temp\\"
    
    -- Get unique sequence number
    local hSequence = mc.mcRegGetHandle(inst, "iRegs0/DialogSequence")
    local sequence = mc.mcRegGetValue(hSequence) + 1
    mc.mcRegSetValue(hSequence, sequence)
    
    -- Create temp directory if needed (silent, no cmd window)
    if not wx.wxDirExists(tempPath) then
        wx.wxMkdir(tempPath)
    end
    
    -- Process fields for serialization
    local function processFields(fields, profileSection)
        local processed = {}
        
        for i, field in ipairs(fields) do
            local pf = {}
            
            -- Copy basic properties
            for k, v in pairs(field) do
                if type(v) ~= "function" then
                    pf[k] = v
                end
            end
            
            -- Load defaults from profile (unless persist == false)
            if field.key and field.persist ~= false then
                if field.type == "number" then
                    pf.default = mc.mcProfileGetDouble(inst, profileSection, field.key, field.default or 0)
                elseif field.type == "checkbox" then
                    pf.default = mc.mcProfileGetInt(inst, profileSection, field.key, field.default or 0)
                elseif field.type == "radio" or field.type == "direction" or field.type == "choice" then
                    pf.default = mc.mcProfileGetInt(inst, profileSection, field.key, field.default or 0)
                elseif field.type == "text" then
                    pf.default = mc.mcProfileGetString(inst, profileSection, field.key, field.default or "")
                end
            end
            
            -- Handle explicit min/max first (most reliable)
            if field.min ~= nil or field.max ~= nil then
                pf.validate = true
                pf.validateMin = field.min or -999999
                pf.validateMax = field.max or 999999
                pf.validateMsg = field.validateMsg or "Value out of range"
            -- Handle validation functions
            elseif field.validate and type(field.validate) == "function" then
                -- For safety, just set wide bounds and let the validate function handle it
                -- The validate function will be called when OK is pressed
                pf.validate = true
                pf.validateMin = -999999
                pf.validateMax = 999999
                pf.validateFunc = field.validate  -- Store the function for later validation
                pf.validateMsg = "Invalid value"
            end
            
            -- Handle onChange flag
            if field.onChange then
                pf.onChange = true
            end
            
            -- Handle constraintHandler for direction fields
            if field.constraintHandler then
                pf.constraintHandler = true
                -- Add flags based on the constraint type
                -- This is simplified - in practice would need to analyze the function
            end
            
            -- Process children recursively
            if field.children then
                pf.children = processFields(field.children, profileSection)
            end
            
            processed[i] = pf
        end
        
        return processed
    end
    
    local processedFields = processFields(fields, profileSection or "Dialog")
    
    -- Serialize fields to file
    local function serializeTable(t, indent)
        indent = indent or ""
        local result = "{\n"
        
        for k, v in pairs(t) do
            result = result .. indent .. "  "
            
            -- Key
            if type(k) == "string" then
                result = result .. k .. " = "
            else
                result = result .. "[" .. k .. "] = "
            end
            
            -- Value
            if type(v) == "string" then
                result = result .. string.format("%q", v)
            elseif type(v) == "number" or type(v) == "boolean" then
                result = result .. tostring(v)
            elseif type(v) == "table" then
                result = result .. serializeTable(v, indent .. "  ")
            else
                result = result .. "nil"
            end
            
            result = result .. ",\n"
        end
        
        return result .. indent .. "}"
    end
    
    -- Write fields to Lua file
    local fieldsFile = io.open(tempPath .. string.format("dialog_fields_%d.lua", sequence), "w")
    if fieldsFile then
        fieldsFile:write("return " .. serializeTable(processedFields))
        fieldsFile:close()
    end
    
    -- Write request parameters
    local requestFile = io.open(tempPath .. string.format("dialog_request_%d.txt", sequence), "w")
    if requestFile then
        requestFile:write(string.format("title=%s\n", title or "Dialog"))
        requestFile:write(string.format("profileSection=%s\n", profileSection or "Dialog"))

        if options.width then
            requestFile:write(string.format("width=%d\n", options.width))
        end

        if options.buttonLabels then
            requestFile:write(string.format("okLabel=%s\n", options.buttonLabels.ok or "OK"))
            requestFile:write(string.format("cancelLabel=%s\n", options.buttonLabels.cancel or "Cancel"))
        end

        requestFile:close()
    end
    
    -- Signal the screen
    local hType = mc.mcRegGetHandle(inst, "iRegs0/DialogType")
    local hRequest = mc.mcRegGetHandle(inst, "iRegs0/DialogRequest")
    local hResponse = mc.mcRegGetHandle(inst, "iRegs0/DialogResponse")
    
    mc.mcRegSetValue(hResponse, 0)
    mc.mcRegSetValueString(hType, "SHOW_DIALOG")
    mc.mcRegSetValue(hRequest, 1)
    
    -- Wait for response
    while mc.mcRegGetValue(hResponse) == 0 do
        wx.wxMilliSleep(50)
        wx.wxSafeYield()
    end
    
    -- Read response
    local responseFile = tempPath .. string.format("dialog_response_%d.txt", sequence)
    local respFile = io.open(responseFile, "r")
    
    local result = {}
    local success = false
    
    for line in respFile:lines() do
        local key, value = line:match("^([^=]+)=(.*)$")
        if key == "success" then
            success = (value == "true")
        elseif key then
            if value == "true" then value = true
            elseif value == "false" then value = false
            elseif tonumber(value) then value = tonumber(value)
            end
            result[key] = value
        end
    end
    
    respFile:close()
    os.remove(responseFile)
    
    -- Clear response flag
    mc.mcRegSetValue(hResponse, 0)
    
    -- Save to profile if successful
    if success then
        for key, value in pairs(result) do
            -- Find field type and persist setting
            local fieldType = nil
            local shouldPersist = true
            for _, field in ipairs(fields) do
                if field.key == key then
                    fieldType = field.type
                    shouldPersist = field.persist ~= false
                    break
                end
                -- Check children
                if field.children then
                    for _, child in ipairs(field.children) do
                        if child.key == key then
                            fieldType = child.type
                            shouldPersist = child.persist ~= false
                            break
                        end
                    end
                end
            end

            -- Save based on type (skip if persist == false)
            if shouldPersist then
                if fieldType == "number" then
                    mc.mcProfileWriteDouble(inst, profileSection, key, value)
                elseif fieldType == "checkbox" then
                    mc.mcProfileWriteInt(inst, profileSection, key, value and 1 or 0)
                elseif fieldType == "radio" or fieldType == "direction" or fieldType == "choice" then
                    mc.mcProfileWriteInt(inst, profileSection, key, value)
                elseif fieldType == "text" then
                    mc.mcProfileWriteString(inst, profileSection, key, tostring(value))
                end
            end
        end

        mc.mcProfileFlush(inst)
        return result
    else
        return nil
    end
end


-- Show heatmap dialog via screen context (avoids crashes from creating dialogs in macro context)
-- Returns true if user clicked Apply, false if Cancel/closed
function ProbeScripts.ShowHeatmap(inst, params)
    local tempPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Temp\\"

    -- Get unique sequence number
    local hSequence = mc.mcRegGetHandle(inst, "iRegs0/DialogSequence")
    local sequence = mc.mcRegGetValue(hSequence) + 1
    mc.mcRegSetValue(hSequence, sequence)

    -- Create temp directory if needed
    if not wx.wxDirExists(tempPath) then
        wx.wxMkdir(tempPath)
    end

    -- Serialize grid data to Lua file
    local dataFile = io.open(tempPath .. string.format("heatmap_data_%d.lua", sequence), "w")
    if dataFile then
        dataFile:write("return {\n")
        dataFile:write(string.format("  xCount = %d,\n", params.xCount))
        dataFile:write(string.format("  yCount = %d,\n", params.yCount))
        dataFile:write(string.format("  zMin = %.8f,\n", params.zMin))
        dataFile:write(string.format("  zMax = %.8f,\n", params.zMax))
        dataFile:write(string.format("  gridWidth = %.8f,\n", params.gridWidth or 1))
        dataFile:write(string.format("  gridHeight = %.8f,\n", params.gridHeight or 1))

        -- Serialize grid as nested table
        dataFile:write("  grid = {\n")
        for row = 0, params.yCount - 1 do
            dataFile:write("    {")
            for col = 0, params.xCount - 1 do
                if col > 0 then dataFile:write(", ") end
                dataFile:write(string.format("%.8f", params.grid[row][col]))
            end
            dataFile:write("},\n")
        end
        dataFile:write("  }\n")
        dataFile:write("}\n")
        dataFile:close()
    else
        return false, "Failed to write heatmap data"
    end

    -- Write request parameters
    local requestFile = io.open(tempPath .. string.format("heatmap_request_%d.txt", sequence), "w")
    if requestFile then
        requestFile:write(string.format("sequence=%d\n", sequence))
        requestFile:close()
    end

    -- Signal the screen
    local hType = mc.mcRegGetHandle(inst, "iRegs0/DialogType")
    local hRequest = mc.mcRegGetHandle(inst, "iRegs0/DialogRequest")
    local hResponse = mc.mcRegGetHandle(inst, "iRegs0/DialogResponse")

    mc.mcRegSetValue(hResponse, 0)
    mc.mcRegSetValueString(hType, "SHOW_HEATMAP")
    mc.mcRegSetValue(hRequest, 1)

    -- Wait for response
    local timeout = 300000  -- 5 minute timeout (user may look at heatmap for a while)
    local startTime = os.clock()
    while mc.mcRegGetValue(hResponse) == 0 do
        if (os.clock() - startTime) * 1000 > timeout then
            return false, "Timeout waiting for heatmap dialog"
        end
        wx.wxMilliSleep(50)
        wx.wxSafeYield()
    end

    -- Read response
    local responseFile = tempPath .. string.format("heatmap_response_%d.txt", sequence)
    local respFile = io.open(responseFile, "r")

    local applyMap = false
    if respFile then
        for line in respFile:lines() do
            local key, value = line:match("^([^=]+)=(.*)$")
            if key == "apply" then
                applyMap = (value == "true")
            end
        end
        respFile:close()
        os.remove(responseFile)
    end

    -- Clear response flag
    mc.mcRegSetValue(hResponse, 0)

    return applyMap
end


-- Generic results display with flexible formatting
function ProbeScripts.DisplayResults(inst, results, title, options)
    options = options or {}
    
    -- Format a value for display
    local function formatValue(value, decimals)
        decimals = decimals or 4
        if type(value) == "number" then
            return string.format("%." .. decimals .. "f", value)
        elseif type(value) == "boolean" then
            return value and "Yes" or "No"
        elseif value == nil then
            return "N/A"
        else
            return tostring(value)
        end
    end
    
    -- Build status message (single line for status bar)
    local statusMessage = ""
    if options.statusFormat then
        -- Use custom format string if provided
        statusMessage = options.statusFormat
        for key, value in pairs(results) do
            local placeholder = "{" .. key .. "}"
            if string.find(statusMessage, placeholder) then
                statusMessage = string.gsub(statusMessage, placeholder, formatValue(value))
            end
        end
    else
        -- Auto-build status from primary keys
        statusMessage = title .. ":"
        local primaryKeys = options.primaryKeys or {}
        if #primaryKeys == 0 then
            -- If no primary keys specified, use first 3 numeric values
            local count = 0
            for key, value in pairs(results) do
                if type(value) == "number" and count < 3 then
                    statusMessage = statusMessage .. string.format(" %s=%s", key, formatValue(value))
                    count = count + 1
                end
            end
        else
            -- Use specified primary keys
            for _, key in ipairs(primaryKeys) do
                if results[key] ~= nil then
                    statusMessage = statusMessage .. string.format(" %s=%s", key, formatValue(results[key]))
                end
            end
        end
    end
    
    -- Update status bar
    mc.mcCntlSetLastError(inst, statusMessage)
    
    -- Build detailed message if needed
    if options.showDetails then
        local detailMessage = title .. "\n"
        detailMessage = detailMessage .. string.rep("=", string.len(title)) .. "\n\n"
        
        -- Sort keys for consistent display
        local sortedKeys = {}
        for key, _ in pairs(results) do
            table.insert(sortedKeys, key)
        end
        table.sort(sortedKeys)
        
        -- Find longest key for alignment
        local maxKeyLen = 0
        for _, key in ipairs(sortedKeys) do
            if string.len(key) > maxKeyLen then
                maxKeyLen = string.len(key)
            end
        end
        
        -- Display each result
        for _, key in ipairs(sortedKeys) do
            local value = results[key]
            -- Skip internal/hidden keys if specified
            if not (options.hideKeys and options.hideKeys[key]) then
                local padding = string.rep(" ", maxKeyLen - string.len(key))
                detailMessage = detailMessage .. string.format("%s:%s  %s\n", 
                                                              key, padding, 
                                                              formatValue(value))
            end
        end
        
        -- Show dialog
        wx.wxMessageBox(detailMessage, title, wx.wxOK + wx.wxICON_INFORMATION)
    end
    
    -- Log to file if specified
    if options.logFile then
        local file = io.open(options.logFile, "a")
        if file then
            file:write(os.date("[%Y-%m-%d %H:%M:%S] "))
            file:write(statusMessage)
            file:write("\n")
            file:close()
        end
    end
    
    -- Store in profile if key provided
    if options.profileKey then
        mc.mcProfileWriteString(inst, "ProbeResults", options.profileKey, statusMessage)
        mc.mcProfileFlush(inst)
    end
    
    return statusMessage
end


-- Check if probe T90 is deployed
function ProbeScripts.CheckProbeDeployed(inst)
    local currentTool = mc.mcToolGetCurrent(inst)

    if currentTool == 90 then
        return true
    end

    local result = wx.wxMessageBox(
        "Touch probe (T90) is not active.\nCurrent tool: T" .. currentTool .. "\n\nWould you like to change to T90?",
        "Tool Change Required",
        wx.wxYES_NO + wx.wxICON_QUESTION
    )
    
    if result == wx.wxYES then
        mc.mcCntlGcodeExecuteWait(inst, "T90")
        ProbeScripts.M6_ToolChange(inst)
        mc.mcCntlSetLastError(inst, "Tool changed to T90 - Ready to probe")
    else
        return false
    end
end


-- Probe outside an edge by moving out first to avoid collisions
function ProbeScripts.ProbeOutside(inst, direction, outDistance, zDown, moveSpeed)
    -- moveSpeed: optional feed rate for XY traverse and retract moves (default 200)
    local xySpeed = moveSpeed or 200

    local dirMap = {
        [1] = {axis = mc.X_AXIS, letter = "X", sign = 1},   -- +X
        [2] = {axis = mc.X_AXIS, letter = "X", sign = -1},  -- -X
        [3] = {axis = mc.Y_AXIS, letter = "Y", sign = 1},   -- +Y
        [4] = {axis = mc.Y_AXIS, letter = "Y", sign = -1}   -- -Y
    }
    local info = dirMap[direction]

    -- Capture starting machine positions for all axes
    local startXMachine = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local startYMachine = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
    local startZMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Move out clamped just under the soft limit
    local cur   = mc.mcAxisGetMachinePos(inst, info.axis)
    local minL  = mc.mcAxisGetSoftlimitMin(inst, info.axis) + 0.05
    local maxL  = mc.mcAxisGetSoftlimitMax(inst, info.axis) - 0.05
    local span  = (info.sign > 0) and (maxL - cur) or (cur - minL)
    local inc   = info.sign * math.max(0, math.min(math.abs(outDistance or 0), span))
    local moveOutSuccess = ProbeScripts.ProtectedMove(inst, "inc", (info.letter=="X") and inc or nil, (info.letter=="Y") and inc or nil, nil, xySpeed)

    if not moveOutSuccess then
        -- Horizontal move failed, already returned to start by ProtectedMove
        mc.mcCntlSetLastError(inst, string.format("%s traverse move failed", info.letter))
        return nil
    end

    -- Protected drop down (incremental Z-)
    local dropSuccess = ProbeScripts.ProtectedMove(inst, "inc", nil, nil, -zDown, 100)

    if not dropSuccess then
        -- Z drop failed (hit something), ProtectedMove returned to position after X/Y move
        -- Need to return to original starting position
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F%.0f", startXMachine, startYMachine, xySpeed))
        mc.mcCntlSetLastError(inst, string.format("%s width too small - collision during Z drop", info.letter))
        return nil
    end
    
    -- Calculate probe direction
    local probeDirection
    if direction == 1 then probeDirection = 2      -- Moved +X, probe -X
    elseif direction == 2 then probeDirection = 1  -- Moved -X, probe +X
    elseif direction == 3 then probeDirection = 4  -- Moved +Y, probe -Y
    elseif direction == 4 then probeDirection = 3  -- Moved -Y, probe +Y
    end
    
    -- Perform the probe with 0.25in retract
    local edgeWork, success = ProbeScripts.Probe(inst, probeDirection, false, false, nil, nil, false, 0.25)
    if not success then
        mc.mcCntlSetLastError(inst, string.format("Probe failed in %s direction", info.letter))
            -- Return to start using machine coords
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F%.0f", startXMachine, startYMachine, xySpeed))
        return nil
    end

    -- Return to start using machine coords
    -- First move Z up
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))
    -- Then move X and Y back
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F%.0f", startXMachine, startYMachine, xySpeed))

    return edgeWork
end


-- Returns: "cancel_g68", "keep_g68", or nil (user cancelled)
function ProbeScripts.CheckG68Rotation(inst)
    -- Check if G68 rotation is currently active
    local modalGroup16 = mc.mcCntlGetPoundVar(inst, 4016)
    if modalGroup16 ~= 68 then
        return "no_rotation"
    end

    local currentRotation = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION)
    local rotationX = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION_X)
    local rotationY = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION_Y)
    
    local message = string.format("G68 rotation is currently active:\nAngle: %.4fÂ°\nCenter: X%.4f Y%.4f\n\nHow would you like to proceed?",
                                 currentRotation, rotationX, rotationY)

    local dialog = wx.wxMessageDialog(wx.NULL, message, "Active G68 Rotation Detected", 
                                      wx.wxYES_NO + wx.wxCANCEL + wx.wxICON_WARNING)
    
    dialog:SetYesNoCancelLabels("Cancel G68 and Run", "Keep G68 and Run", "Cancel")
    
    local result = dialog:ShowModal()
    dialog:Destroy()
    
    if result == wx.wxID_YES then
        mc.mcCntlGcodeExecuteWait(inst, "G69")
        mc.mcCntlSetLastError(inst, "G68 rotation cancelled")
        return "cancel_g68"
    elseif result == wx.wxID_NO then
        return "keep_g68"
    else
        return nil
    end
end

-- Performs touch probe operation in specified direction
function ProbeScripts.ProbeXYZ(inst, direction, fastFeed, backoff, slowFeed, maxTravel, finalRetract, setDatum)
    local probeSuccess = 0

    -- Direction mapping: axis, direction multiplier, axis letter
    local dirMap = {
        [1] = {mc.X_AXIS,  1, "X"},
        [2] = {mc.X_AXIS, -1, "X"},
        [3] = {mc.Y_AXIS,  1, "Y"},
        [4] = {mc.Y_AXIS, -1, "Y"},
        [5] = {mc.Z_AXIS, -1, "Z"}
    }
    
    local axis, dir, axisLetter = table.unpack(dirMap[direction])
    
    -- Store starting position in machine coordinates for all axes
    local startXMachine = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local startYMachine = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
    local startZMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Get the starting position for the probed axis
    local axisStartPos
    if axis == mc.X_AXIS then
        axisStartPos = startXMachine
    elseif axis == mc.Y_AXIS then
        axisStartPos = startYMachine
    else  -- mc.Z_AXIS
        axisStartPos = startZMachine
    end

    -- Helper function to attempt unsticking probe
    local function attemptUnstickProbe(probeSig, contactPos, feedRate)
        local maxAttempts = 3
        local pushDistances = {0.01, 0.05, 0.1}  -- Progressive push distances

        for attempt = 1, maxAttempts do
            -- Check if probe is clear
            if mc.mcSignalGetState(probeSig) ~= 1 then
                -- Probe cleared immediately
                if attempt > 1 then
                    mc.mcCntlSetLastError(inst, string.format("Probe unstuck after %d attempt(s)", attempt - 1))
                end
                return true
            end

            -- Probe still triggered - wait 500ms for signal to settle, then check again
            wx.wxMilliSleep(500)
            if mc.mcSignalGetState(probeSig) ~= 1 then
                -- Probe cleared after settle delay
                if attempt > 1 then
                    mc.mcCntlSetLastError(inst, string.format("Probe unstuck after %d attempt(s)", attempt - 1))
                end
                return true
            end

            -- Still stuck, try unstick maneuver
            local pushInDistance = pushDistances[attempt]
            mc.mcCntlSetLastError(inst, string.format("Probe stuck - unstick attempt %d of %d (push %.3f\")",
                                                      attempt, maxAttempts, pushInDistance))

            -- Move to contact position plus extra distance into surface
            local targetPos = contactPos + (dir * pushInDistance)
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 %s%.4f F%.1f", axisLetter, targetPos, feedRate))

            -- Retract ALL THE WAY BACK to original starting position with rapid move
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 %s%.4f", axisLetter, axisStartPos))
        end

        -- Check one final time - if cleared immediately, we're done
        if mc.mcSignalGetState(probeSig) ~= 1 then
            mc.mcCntlSetLastError(inst, string.format("Probe unstuck after %d attempt(s)", maxAttempts))
            return true
        end

        -- Still triggered, wait 500ms and check once more
        wx.wxMilliSleep(500)
        if mc.mcSignalGetState(probeSig) ~= 1 then
            mc.mcCntlSetLastError(inst, string.format("Probe unstuck after %d attempt(s)", maxAttempts))
            return true
        end

        mc.mcCntlSetLastError(inst, string.format("Probe stuck after %d unstick attempts - manual intervention required", maxAttempts))
        return false
    end

    -- Helper function to check if probe is clear with settle delay
    -- If probe clears immediately, return true right away
    -- If probe is still triggered, wait 500ms for signal to settle, then check again
    local function isProbeCleared(probeSig)
        if mc.mcSignalGetState(probeSig) ~= 1 then
            return true  -- Cleared immediately, no delay needed
        end
        -- Still triggered, wait for signal to settle and check again
        wx.wxMilliSleep(500)
        return mc.mcSignalGetState(probeSig) ~= 1
    end

    -- Check probe signal isn't already triggered
    local probeHandle = mc.mcSignalGetHandle(inst, mc.ISIG_PROBE1)
    local probeState = mc.mcSignalGetState(probeHandle)
    if probeState == 1 then  -- Probe already triggered
        mc.mcCntlSetLastError(inst, "Probe error: Probe already triggered")
        error("Probe already triggered - check clearance")
    end

    -- Get per-direction probe diameters from PVs 511-515
    -- PV 511: +X, PV 512: -X, PV 513: +Y, PV 514: -Y, PV 515: Z offset
    local probeDiameters = {
        [1] = mc.mcCntlGetPoundVar(inst, 511),  -- +X
        [2] = mc.mcCntlGetPoundVar(inst, 512),  -- -X
        [3] = mc.mcCntlGetPoundVar(inst, 513),  -- +Y
        [4] = mc.mcCntlGetPoundVar(inst, 514),  -- -Y
        [5] = mc.mcCntlGetPoundVar(inst, 515)   -- Z axis, effective Z probe diameter
    }

    -- Get the appropriate probe radius for this direction
    local probeRadius = probeDiameters[direction] / 2

    -- Clamp maxTravel to soft limit
    local currentPos = mc.mcAxisGetMachinePos(inst, axis)
    if dir > 0 then
        maxTravel = math.min(maxTravel or 10, mc.mcAxisGetSoftlimitMax(inst, axis) - currentPos - 0.05)
    else
        maxTravel = math.min(maxTravel or 10, currentPos - mc.mcAxisGetSoftlimitMin(inst, axis) - 0.05)
    end

    -- Fast probe
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G31.1 %s%.4f F%.1f", axisLetter, dir * (maxTravel or 10), fastFeed))

    -- Check if probe triggered
    local probeSig = mc.mcSignalGetHandle(inst, mc.ISIG_PROBE1)
    probeSuccess = mc.mcSignalGetState(probeSig)

    -- Two-tap probe if slow feed provided
    if slowFeed and slowFeed > 0 and backoff > 0 then
        local firstStrike = mc.mcAxisGetProbePos(inst, axis, 1)  -- Get machine position
        local firstStrikeWork = mc.mcAxisGetProbePos(inst, axis, 0)  -- Get work position
        -- Incremental retract from probe strike
        mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 %s%.4f F50", axisLetter, -dir * backoff))

        -- Check if probe is still triggered after retract (with settle delay) and attempt unstick if needed
        if not isProbeCleared(probeSig) then
            if not attemptUnstickProbe(probeSig, firstStrike, fastFeed) then
                mc.mcCntlSetPoundVar(inst, 393, 0)
                return nil, nil, 0
            end
            -- After unstick, we're back at axisStartPos - return to backoff position from first strike
            local slowProbeStartPos = firstStrike - (dir * backoff)
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 %s%.4f", axisLetter, slowProbeStartPos))
        end

        -- Store position before slow probe to verify strike occurred
        local posBeforeSlowProbe = mc.mcAxisGetMachinePos(inst, axis)

        -- Slow probe
        mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G31.1 %s%.4f F%.1f", axisLetter, dir * (backoff * 2), slowFeed))

        -- Check success by verifying probe position changed (probe triggered at some point)
        -- Don't rely on signal still being latched - probe may have re-seated
        local slowStrike = mc.mcAxisGetProbePos(inst, axis, 1)
        local travelDistance = math.abs(slowStrike - posBeforeSlowProbe)

        -- If probe traveled less than the full commanded distance, it hit something
        if travelDistance < (backoff * 2 - 0.001) then
            probeSuccess = 1
        else
            -- Probe traveled full distance without triggering - actual miss
            probeSuccess = 0
        end
    end
    
    -- Final retract handling
    if finalRetract then
        if finalRetract == -1 then
            -- Return to starting position using machine coordinates for all axes
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F200", startXMachine, startYMachine))

            -- Check if probe is still triggered after retract (with settle delay) and attempt unstick if needed
            if not isProbeCleared(probeSig) then
                local contactPos = mc.mcAxisGetProbePos(inst, axis, 1)  -- Get last probe contact in machine coords

                if not attemptUnstickProbe(probeSig, contactPos, fastFeed) then
                    mc.mcCntlSetPoundVar(inst, 393, 0)
                    return nil, nil, 0
                end
            end
        elseif finalRetract > 0 then
            -- Incremental custom retract clamped to soft limit
            local pos = mc.mcAxisGetMachinePos(inst, axis)
            local tgt = math.min(mc.mcAxisGetSoftlimitMax(inst, axis) - 0.05,
                        math.max(mc.mcAxisGetSoftlimitMin(inst, axis) + 0.05, pos - dir * finalRetract))

            mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 %s%.4f F100", axisLetter, tgt - pos))

            -- Check if probe is still triggered after retract (with settle delay) and attempt unstick if needed
            if not isProbeCleared(probeSig) then
                local contactPos = mc.mcAxisGetProbePos(inst, axis, 1)  -- Get last probe contact in machine coords

                if not attemptUnstickProbe(probeSig, contactPos, fastFeed) then
                    mc.mcCntlSetPoundVar(inst, 393, 0)
                    return 0, 0, 0
                end
            end
        end
    end

    -- Return nil on miss
    if probeSuccess ~= 1 then
        mc.mcCntlSetPoundVar(inst, 393, 0)
        return nil, nil, 0
    end

    -- Get final strike positions
    local strikePosMachine = mc.mcAxisGetProbePos(inst, axis, 1)
    local strikePosWork = mc.mcAxisGetProbePos(inst, axis, 0)
    
    -- Calculate edge positions, compensate for probe ball
    local machineEdge, workEdge
    if axis == mc.Z_AXIS then
        -- Z axis, apply Z offset compensation (effective Z probe diameter)
        -- For Z, the offset acts like a probe radius compensation
        machineEdge = strikePosMachine + (dir * probeRadius)
        workEdge = strikePosWork + (dir * probeRadius)
    else
        machineEdge = strikePosMachine + (dir * probeRadius)
        workEdge = strikePosWork + (dir * probeRadius)
    end
    
    if setDatum == 1 then
        local currentPos = mc.mcAxisGetPos(inst, axis)
        -- Calculate what to set current position to so edge becomes 0
        local setValue = currentPos - workEdge
        -- Apply datum using mcAxisSetPos
        mc.mcAxisSetPos(inst, axis, setValue)
        local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
        local offsetNum = 54
        if modalOffset >= 54 and modalOffset <= 59 then
            offsetNum = math.floor(modalOffset + 0.5)
        end
        
        mc.mcCntlSetLastError(inst, string.format("G%d %s0 set (edge at %.4f zeroed)", 
                                                  offsetNum, axisLetter, workEdge))

        workEdge = 0.0
    end

    -- 391 = last probe machine position
    -- 392 = last probe work position  
    -- 393 = probe success flag (0 or 1)
    mc.mcCntlSetPoundVar(inst, 391, machineEdge)
    mc.mcCntlSetPoundVar(inst, 392, workEdge)
    mc.mcCntlSetPoundVar(inst, 393, probeSuccess and 1 or 0)

    return machineEdge, workEdge, probeSuccess
end



--===================== Begin Probe Scripts =====================--



-- M310 Tool Height Measurement
function ProbeScripts.M310_ProbeToolHeight(inst)
    -- Get current tool
    local tool = mc.mcToolGetCurrent(inst)

    -- Capture previous H offset before probing
    local previousHeight = mc.mcToolGetData(inst, mc.MTOOL_MILL_HEIGHT, tool) or 0

    -- Configuration from pound variables
    local SAFE_Z = mc.mcCntlGetPoundVar(inst, 523)
    local PROBE_STATION_X = mc.mcCntlGetPoundVar(inst, 526)
    local PROBE_STATION_Y = mc.mcCntlGetPoundVar(inst, 527)
    local SURFACE_Z = mc.mcCntlGetPoundVar(inst, 528)
    local PROBE_MAX_DEPTH = mc.mcCntlGetPoundVar(inst, 529)
    local HEIGHT_FAST_FEED = mc.mcCntlGetPoundVar(inst, 530)
    local HEIGHT_SLOW_FEED = mc.mcCntlGetPoundVar(inst, 531)
    local HEIGHT_RETRACT = mc.mcCntlGetPoundVar(inst, 532)
    
    -- Calculate position offsets based on tool type
    local stationX = PROBE_STATION_X
    local stationY = PROBE_STATION_Y

    -- T0 (spindle rim) needs spindle probe X offset from PV 533
    if tool == 0 then
        local spindleXOffset = mc.mcCntlGetPoundVar(inst, 533)
        stationX = stationX + spindleXOffset
    else
        -- All tools (physical and virtual) can have ProbeXOffset
        local probeXOffset = mc.mcToolGetDataExDbl(inst, tool, "ProbeXOffset")
        probeXOffset = probeXOffset or 0
        stationX = stationX + probeXOffset

        -- Virtual tools (T90-T99) additionally need tool table offset compensation
        if tool >= 90 and tool <= 99 then
            local toolXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, tool)
            local toolYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, tool)
            toolXOffset = toolXOffset or 0
            toolYOffset = toolYOffset or 0
            stationX = stationX + toolXOffset
            stationY = stationY + toolYOffset
        end
    end
    
    -- Move to probe station using helper functions
    mc.mcCntlGcodeExecuteWait(inst, "G49")
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z0")
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f", stationX, stationY))

    -- Save laser state before probing (ESS disables test mode during G31)
    local savedLaserEnable = 0
    local savedLaserActivate = 0
    if tool == 91 then
        local hregEnable = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Enable")
        local hregActivate = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Activate")
        if hregEnable ~= 0 then
            savedLaserEnable = mc.mcRegGetValue(hregEnable)
        end
        if hregActivate ~= 0 then
            savedLaserActivate = mc.mcRegGetValue(hregActivate)
        end
    end

    -- Perform measurement - all tools now use G31 method
    -- Calculate probe travel distance
    local travelDistance = -math.abs(PROBE_MAX_DEPTH)

    -- First probe (fast)
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G31 Z%.4f F%.1f", travelDistance, HEIGHT_FAST_FEED))
    local strike1 = mc.mcAxisGetProbePos(inst, mc.Z_AXIS, 1)  -- machine coords

    -- Retract
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", strike1 + HEIGHT_RETRACT))

    -- Turn on air blast to clean probe surface
    local hOutput8 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT8)
    mc.mcSignalSetState(hOutput8, 1)

    -- Second probe (slow)
    -- Probe slightly past the first strike position
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G31 Z%.4f F%.1f", -(HEIGHT_RETRACT + 0.1), HEIGHT_SLOW_FEED))
    local measuredZ = mc.mcAxisGetProbePos(inst, mc.Z_AXIS, 1)  -- machine coords

    -- Turn off air blast
    mc.mcSignalSetState(hOutput8, 0)
    
    -- For T0, save spindle rim position as the reference
    if tool == 0 then
        mc.mcCntlSetPoundVar(inst, 528, measuredZ)  -- Save spindle rim position
        SURFACE_Z = measuredZ  -- Update local variable
        toolHeight = 0  -- T0 height is 0 by definition (it IS the reference)
    else
        -- Calculate tool height relative to spindle rim (SURFACE_Z)
        toolHeight = measuredZ - SURFACE_Z
    end

    mc.mcToolSetData(inst, mc.MTOOL_MILL_HEIGHT, tool, toolHeight)

    -- Retract to Z0
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z0")

    -- Apply H offset (only for tools > 0)
    if tool > 0 then
        mc.mcCntlGcodeExecuteWait(inst, string.format("G43 H%d", tool))
    end

    -- Restore laser state after probing (if it was saved)
    if tool == 91 and (savedLaserEnable == 1 or savedLaserActivate == 1) then
        local hregEnable = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Enable")
        local hregActivate = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Activate")
        if savedLaserEnable == 1 and hregEnable ~= 0 then
            mc.mcRegSetValue(hregEnable, 1)
        end
        if savedLaserActivate == 1 and hregActivate ~= 0 then
            mc.mcRegSetValue(hregActivate, 1)
        end
    end

    mc.mcCntlSetLastError(inst, string.format("T%d measured: Height = %.4f (was %.4f)", tool, toolHeight, previousHeight))
    return 0
end




-- M6 Tool Change Function
function ProbeScripts.M6_ToolChange(inst)
    local bootWasDown = false

    -- Set M6 in-progress flag (used by UI to disable override controls)
    mc.mcCntlSetPoundVar(inst, 499, 1)

    -- Capture current FRO and RRO values
    local savedFRO = mc.mcCntlGetFRO(inst)
    local savedRRO = mc.mcCntlGetRRO(inst)

    -- Set FRO and RRO to 100% for tool change
    mc.mcCntlSetFRO(inst, 100)
    mc.mcCntlSetRRO(inst, 100)

    -- Configuration from pound variables
    local Z_CLEARANCE = mc.mcCntlGetPoundVar(inst, 523)     -- Z clearance above tool pocket (relative)
    local PULLOUT_DIST = mc.mcCntlGetPoundVar(inst, 524)    -- Y pullout distance
    local APPROACH_FEED = mc.mcCntlGetPoundVar(inst, 525)   -- Approach feedrate

    -- Get current and requested tools
    local current = mc.mcToolGetCurrent(inst)
    local requested = mc.mcToolGetSelected(inst)

    -- Movement error handling
    local function GcodeExecuteWait(gcode)
        local rc = mc.mcCntlGcodeExecuteWait(inst, gcode)
        if rc ~= mc.MERROR_NOERROR then
            -- Restore FRO and RRO before error
            mc.mcCntlSetFRO(inst, savedFRO)
            mc.mcCntlSetRRO(inst, savedRRO)
            -- Clear M6 in-progress flag
            mc.mcCntlSetPoundVar(inst, 499, 0)
            error("Motion aborted")
        end
    end

    -- Save boot state and raise
    local hDustBoot = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3)
    if mc.mcSignalGetState(hDustBoot) == 1 then
        bootWasDown = true
        mc.mcSignalSetState(hDustBoot, 0)
    end

    -- Deploy or restore dust boot
    local function SetBootState()
        local bootAuto = mc.mcSignalGetState(mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT52)) == 1
        local machState = mc.mcCntlGetState(inst)
        local isFileRun = (machState >= 100 and machState < 200) -- only file runs

        if bootWasDown or (bootAuto and isFileRun and requested > 0 and requested < 90) then
            mc.mcSignalSetState(hDustBoot, 1)
        end
    end

    -- Same tool - just sync H offset, don't touch boot
    if current == requested then
        if requested > 0 and requested < 90 then
            GcodeExecuteWait("G49")
            GcodeExecuteWait(string.format("G43 H%d", requested))
            SetBootState()
        end
        -- Restore FRO and RRO to saved values
        mc.mcCntlSetFRO(inst, savedFRO)
        mc.mcCntlSetRRO(inst, savedRRO)
        -- Clear M6 in-progress flag
        mc.mcCntlSetPoundVar(inst, 499, 0)
        return 0
    end
    
    -- Helper function to drop current physical tool
    -- targetTool: the tool we're picking up next (for group-based retract height)
    local function dropTool(targetTool)
        local pocketX = mc.mcToolGetDataExDbl(inst, current, "XToolChange")
        local pocketY = mc.mcToolGetDataExDbl(inst, current, "YToolChange")
        local pocketZ = mc.mcToolGetDataExDbl(inst, current, "ZToolChange")

        -- Stop spindle if running
        local hInput13 = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT13)
        if mc.mcSignalGetState(hInput13) == 1 then
            mc.mcSpindleSetDirection(inst, 0)
        end

        -- Move to Z0
        GcodeExecuteWait("G90 G53 G0 Z0")

        -- Move to X and Y-pullout position (behind the pocket)
        GcodeExecuteWait(string.format("G90 G53 G0 X%.4f Y%.4f", pocketX, pocketY - PULLOUT_DIST))

        -- Descend to pocket Z
        GcodeExecuteWait(string.format("G90 G53 G0 Z%.4f", pocketZ))

        -- Move forward into pocket
        GcodeExecuteWait(string.format("G90 G53 G1 Y%.4f F%.1f", pocketY, APPROACH_FEED))

        -- Unlock clamp
        local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        mc.mcSignalSetState(hOutput2, 1)

        -- Wait in 100ms cycles until INPUT17 goes LOW and OUTPUT2 reads HIGH
        local hInput17 = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
        while true do
            local in17  = mc.mcSignalGetState(hInput17)
            local out2  = mc.mcSignalGetState(hOutput2)
            if in17 == 0 and out2 == 1 then
                break
            end
            wx.wxMilliSleep(100)
        end
        wx.wxMilliSleep(100)

        -- Retract height depends on whether target is in same group
        -- Group 1: tools 1-9, Group 2: tools 10-89
        local sameGroup = (current <= 9 and targetTool <= 9) or (current >= 10 and targetTool >= 10)

        if sameGroup and targetTool > 0 and targetTool < 90 then
            -- Same group: retract to target tool Z + clearance
            local targetZ = mc.mcToolGetDataExDbl(inst, targetTool, "ZToolChange")
            GcodeExecuteWait(string.format("G90 G53 G0 Z%.4f", targetZ + Z_CLEARANCE))
        else
            -- Different group or going to virtual/T0: retract to Z0
            GcodeExecuteWait("G90 G53 G0 Z0")
        end
    end
    
    -- Helper function to retract virtual tool
    local function retractVirtual()
        if current == 90 then
            -- Retract probe
            local hOutput7 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
            mc.mcSignalSetState(hOutput7, 0)
        elseif current == 91 then
            -- Retract laser and disable firing
            local hOutput1 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
            mc.mcSignalSetState(hOutput1, 0)
            -- Also disable laser firing for safety
            local hregActivate = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Activate")
            mc.mcRegSetValue(hregActivate, 0)
            mc.mcSignalSetState(mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT9), 0)
        end
    end
    
    -- ===== Virtual Tool Handling (T90-T99) =====
    if requested >= 90 then
        -- Drop current physical tool if any
        if current > 0 and current < 90 then
            dropTool(requested)
        end

        -- Lock clamp
        local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        mc.mcSignalSetState(hOutput2, 0)

        -- Retract current virtual tool if any
        retractVirtual()

        -- Move to Z0 for virtual tool deployment
        GcodeExecuteWait("G90 G53 G0 Z0")
        
        -- Deploy requested virtual tool
        if requested == 90 then
            local hOutput7 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
            mc.mcSignalSetState(hOutput7, 1)
        elseif requested == 91 then
            local hOutput1 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
            mc.mcSignalSetState(hOutput1, 1)
        end
        
        -- Set tool and apply offsets (G43 automatically applies X/Y from tool table)
        mc.mcToolSetCurrent(inst, requested)
        GcodeExecuteWait(string.format("G43 H%d", requested))
        mc.mcCntlSetPoundVar(inst, 550, requested)

        -- Clear M6 in-progress flag
        mc.mcCntlSetPoundVar(inst, 499, 0)
        return 0
    end
    
    -- ===== T0 = Clear Tool =====
    if requested == 0 then
        -- Retract virtual tool
        retractVirtual()
        -- Drop physical tool
        if current > 0 and current < 90 then
            dropTool(requested)
        end

        -- Lock clamp
        local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        mc.mcSignalSetState(hOutput2, 0)

        mc.mcToolSetCurrent(inst, 0)
        GcodeExecuteWait("G49")
        mc.mcCntlSetPoundVar(inst, 550, 0)
        GcodeExecuteWait("G90 G53 G0 Z0")
        -- Clear M6 in-progress flag
        mc.mcCntlSetPoundVar(inst, 499, 0)
        return 0
    end
    
    -- ===== Physical Tool Change (T1-T89) =====

    -- Drop current physical tool or prepare for pickup
    if current > 0 and current < 90 and current ~= requested then
        dropTool(requested)
        -- dropTool leaves us at appropriate Z, ready for next pocket
    else
        retractVirtual()

        -- Clear virtual tool immediately so UI updates
        if current >= 90 then
            mc.mcToolSetCurrent(inst, 0)
        end

        -- Move to Z0 for both T0 and virtual tools
        GcodeExecuteWait("G90 G53 G0 Z0")

        -- Open clamp
        local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        mc.mcSignalSetState(hOutput2, 1)
    end
    
    -- Get tool pocket position
    local pocketX = mc.mcToolGetDataExDbl(inst, requested, "XToolChange")
    local pocketY = mc.mcToolGetDataExDbl(inst, requested, "YToolChange")
    local pocketZ = mc.mcToolGetDataExDbl(inst, requested, "ZToolChange")
    
    -- Move to pocket position
    GcodeExecuteWait(string.format("G90 G53 G0 X%.4f Y%.4f", pocketX, pocketY))
    GcodeExecuteWait(string.format("G90 G53 G1 Z%.4f F%.1f", pocketZ, APPROACH_FEED))
    
    -- Lock clamp
    local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
    mc.mcSignalSetState(hOutput2, 0)

    -- Wait for tool present signal with debounce (500ms timeout, 100ms debounce)
    local h = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    local t, stable = 0, 0
    while t < 500 do
        if mc.mcSignalGetState(h) == 1 then
            stable = stable + 50
            if stable >= 100 then break end
        else
            stable = 0
        end
        wx.wxMilliSleep(50)
        t = t + 50
    end
    if stable < 100 then
        -- Tool pickup failed - clear tool state
        mc.mcToolSetCurrent(inst, 0)
        mc.mcCntlSetPoundVar(inst, 550, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        -- Restore FRO and RRO before error
        mc.mcCntlSetFRO(inst, savedFRO)
        mc.mcCntlSetRRO(inst, savedRRO)
        -- Clear M6 in-progress flag
        mc.mcCntlSetPoundVar(inst, 499, 0)
        error(string.format("Failed to pick up T%d - tool presence not detected", requested))
    end

    -- Pullout movement
    local pulloutY = pocketY - PULLOUT_DIST
    GcodeExecuteWait(string.format("G90 G53 G1 Y%.4f F%.1f", pulloutY, APPROACH_FEED))

    -- Retract to Z0
    GcodeExecuteWait("G90 G53 G0 Z0")
    
    -- Set current tool
    mc.mcToolSetCurrent(inst, requested)
    mc.mcCntlSetPoundVar(inst, 550, requested)
    
    -- ===== Height Measurement =====
    local autoProbe = mc.mcToolGetDataExInt(inst, requested, "AutoProbe")
    
    if autoProbe == 1 then
        -- Call M310 directly to measure tool height
        ProbeScripts.M310_ProbeToolHeight(inst)
    else
        -- Just apply existing H offset
        local existingHeight = mc.mcToolGetData(inst, mc.MTOOL_MILL_HEIGHT, requested) or 0
        GcodeExecuteWait("G49")
        GcodeExecuteWait(string.format("G43 H%d", requested))
        mc.mcCntlSetLastError(inst, string.format("T%d: Applied H = %.4f", requested, existingHeight))
    end
    
    SetBootState()

    -- Restore FRO and RRO to saved values
    mc.mcCntlSetFRO(inst, savedFRO)
    mc.mcCntlSetRRO(inst, savedRRO)

    -- Clear M6 in-progress flag
    mc.mcCntlSetPoundVar(inst, 499, 0)

    return 0
end


function ProbeScripts.ProbeZ(inst)
    if not RequestMaintenance() then return end
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Build dialog
    local fields = {
        {type = "instructions", text = "Probe downward (-Z) to find surface"},
        {type = "separator"},
        
        {type = "radio", key = "action", label = "Action:",
         options = {"Set Z Datum at Surface", "Display Probed Position"},
         default = 0},
    }

    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Z Probe", fields, "SimpleZProbe")
    
    if not params then return end

    -- Perform probe with return to start
    local setDatum = (params.action == 0)
    local edgeWork, success = ProbeScripts.Probe(inst, 5, setDatum, true, nil, nil, false, nil)

    if not success then
        mc.mcCntlSetLastError(inst, "Z Probe failed")
        return
    end
    
    -- Display results if not setting datum
    if params.action == 1 then
        local edgeMachine = mc.mcCntlGetPoundVar(inst, 391)
        local results = {
            MachineZ = edgeMachine,
            WorkZ = edgeWork
        }
        ProbeScripts.DisplayResults(inst, results, "Z Probe Results", {
            statusFormat = "Z Probe: Machine={MachineZ} Work={WorkZ}",
            showDetails = true
        })
    end
end


function ProbeScripts.ProbeXY(inst)
    if not RequestMaintenance() then return end
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Build dialog
    local fields = {
        {type = "instructions", text = "Select probe direction and action"},
        {type = "separator"},
        
        {type = "direction", key = "direction", 
         label = "Probe Direction:",
         tooltip = "Select the direction to probe from current position",
         default = 0},  -- Default to +X
        
        {type = "separator"},
        
        {type = "radio", key = "action", 
         label = "Action:",
         options = {"Set Datum", "Set/Center", "Show Position"},
         columns = 3,  -- Display all options on one line
         tooltip = "Set Datum: Zero at edge | Set/Center: Zero between two edges | Show Position: Display only",
         default = 0}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "XY Probe", fields, "SimpleXYProbe")
    
    if not params then return end

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end
    
    -- Map dialog direction (0=+X, 1=-X, 2=+Y, 3=-Y) to ProbeXYZ direction (1=+X, 2=-X, 3=+Y, 4=-Y)
    local ProbeXYZDirection = params.direction + 1
    
    -- Determine axis info
    local isXAxis = (ProbeXYZDirection <= 2)
    local axisLetter = isXAxis and "X" or "Y"
    local axisNum = isXAxis and 0 or 1  -- For GetPos: 0=X, 1=Y
    local directionSign = ((ProbeXYZDirection == 1) or (ProbeXYZDirection == 3)) and "+" or "-"
    
    -- Handle Set/Center datum option
    if params.action == 1 then  -- Set/Center
        -- Determine which PV to use (300 for X, 301 for Y)
        local pv = isXAxis and 300 or 301
        local storedPosMachine = mc.mcCntlGetPoundVar(inst, pv)

        -- Check if we have a stored position for this axis
        if storedPosMachine ~= 0 then
            -- Second call for this axis - calculate center and set datum

            -- Probe the edge
            local edgeWork, success = ProbeScripts.Probe(inst, ProbeXYZDirection, false, true, nil, nil, false, nil)

            if not success then
                mc.mcCntlSetLastError(inst, string.format("%s%s Probe failed - no contact detected", directionSign, axisLetter))
                return
            end

            -- Get the machine position of this probe
            local edgeMachine = mc.mcCntlGetPoundVar(inst, 391)

            -- Calculate center in machine coordinates
            local centerMachine = (storedPosMachine + edgeMachine) / 2
            local width = math.abs(storedPosMachine - edgeMachine)

            -- Get current machine position
            local currentMachine = mc.mcAxisGetMachinePos(inst, axisNum)

            -- Calculate the offset from current position to center (matching ScreenLoad logic)
            local workOffset = centerMachine - currentMachine

            -- Set datum at center (matching ScreenLoad SetCenter approach)
            mc.mcAxisSetPos(inst, axisNum, -workOffset)

            -- Clear the PV
            mc.mcCntlSetPoundVar(inst, pv, 0)

            -- Get current work offset
            local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
            local offsetNum = 54
            if modalOffset >= 54 and modalOffset <= 59 then
                offsetNum = math.floor(modalOffset + 0.5)
            end

            -- Display results
            local results = {
                Width = width,
                CenterMachine = centerMachine,
                Edge1Machine = storedPosMachine,
                Edge2Machine = edgeMachine
            }

            ProbeScripts.DisplayResults(inst, results, "Center Set Results", {
                statusFormat = string.format("G%d %s0 set at center (machine %.4f), Width=%.4f",
                                           offsetNum, axisLetter, centerMachine, width),
                showDetails = false
            })

        else
            -- First call for this axis - store position and end

            -- Probe the edge
            local edgeWork, success = ProbeScripts.Probe(inst, ProbeXYZDirection, false, true, nil, nil, false, nil)

            if not success then
                mc.mcCntlSetLastError(inst, string.format("%s%s Probe failed - no contact detected", directionSign, axisLetter))
                return
            end

            -- Store the machine position in the PV
            local edgeMachine = mc.mcCntlGetPoundVar(inst, 391)
            mc.mcCntlSetPoundVar(inst, pv, edgeMachine)

            -- Notify user
            mc.mcCntlSetLastError(inst, string.format("%s: First point set at machine %.4f - Move to opposite edge and run again",
                                                      axisLetter, edgeMachine))

            -- Display simple result
            local results = {
                ["Machine" .. axisLetter] = edgeMachine,
                ["Work" .. axisLetter] = edgeWork,
                Status = "First edge stored"
            }

            ProbeScripts.DisplayResults(inst, results, "Set/Center - First Edge", {
                statusFormat = string.format("%s first edge at machine %.4f - Ready for second edge",
                                           axisLetter, edgeMachine),
                showDetails = false
            })
        end

    else
        -- Original edge probe or display position
        local setDatum = (params.action == 0)
        local edgeWork, success = ProbeScripts.Probe(inst, ProbeXYZDirection, setDatum, true, nil, nil, false, nil)
        
        if not success then
            mc.mcCntlSetLastError(inst, string.format("%s%s Probe failed - no contact detected", directionSign, axisLetter))
            return
        end
        
        -- Display results if not setting datum
        if params.action == 2 then  -- Display position (action index shifted due to new option)
            local edgeMachine = mc.mcCntlGetPoundVar(inst, 391)
            local results = {
                ["Machine" .. axisLetter] = edgeMachine,
                ["Work" .. axisLetter] = edgeWork,
                Direction = directionSign .. axisLetter
            }
            
            ProbeScripts.DisplayResults(inst, results, "XY Probe Results", {
                statusFormat = string.format("%s Probe: Machine={Machine%s} Work={Work%s}", 
                                            directionSign .. axisLetter, axisLetter, axisLetter),
                showDetails = true
            })
        end
    end
end



function ProbeScripts.ProbeOutsideCenter(inst)
    if not RequestMaintenance() then return end
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Build dialog
    local fields = {
        {type = "instructions", text = "Position probe above center of stock.\nProbe will find top surface, then measure edges."},
        {type = "separator"},
        
        {type = "grid", columns = 2, spacing = 15, children = {
            {type = "number", key = "traverseHeight", label = "Traverse:",
             width = 60,
             default = 0.5,
             tooltip = "Height above surface for safe rapid moves",
             min = 0.001,
             max = 10,
             validateMsg = "Must be between 0-10"},

            {type = "number", key = "dropHeight", label = "Z Drop:",
             width = 60,
             default = 0.1,
             tooltip = "Distance to drop below surface for edge probing",
             min = 0.001,
             max = 2,
             validateMsg = "Must be between 0-2"}
        }},
        
        {type = "separator"},
        
        {type = "grid", columns = 2, spacing = 15, children = {
            {type = "number", key = "xWidth", label = "X Width:",
             width = 60,
             default = 0,
             tooltip = "Expected width in X direction (0 to skip)",
             min = 0,
             max = 100,
             validateMsg = "Must be between 0-100"},

            {type = "number", key = "yWidth", label = "Y Width:",
             width = 60,
             default = 0,
             tooltip = "Expected width in Y direction (0 to skip)",
             min = 0,
             max = 100,
             validateMsg = "Must be between 0-100"}
        }},
        
        {type = "separator"},
        
        {type = "checkbox", key = "setZDatum", label = "Set Z Datum at Surface", 
         default = 1,
         tooltip = "Zero the Z axis at the probed surface"},
         
        {type = "checkbox", key = "moveToCenter", 
         label = "Move to Center",
         default = 0,
         tooltip = "Move to the calculated center position after probing"}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Outside Center Probe", fields, "ProbeOutsideCenter")
    if not params then return end

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end
    
    -- Validate at least one axis has width
    if params.xWidth <= 0 and params.yWidth <= 0 then
        wx.wxMessageBox("At least one axis must have a width greater than 0", 
                       "Invalid Parameters", 
                       wx.wxOK + wx.wxICON_ERROR)
        return
    end
    
    -- First probe down to find surface
    local surfaceWork, zSuccess = ProbeScripts.Probe(inst, 5, params.setZDatum, false, nil, nil, false, params.traverseHeight)
    
    if not zSuccess then
        mc.mcCntlSetLastError(inst, "Z Probe failed - no surface detected")
        return
    end
    
    local results = {}
    
    -- Helper function to probe an axis (returns center and width, doesn't set datum)
    local function probeAxis(axisLetter, width, dir1, dir2)
        local edge1 = ProbeScripts.ProbeOutside(inst, dir1, width / 2, params.traverseHeight + params.dropHeight)
        if not edge1 then return nil, nil end

        local edge2 = ProbeScripts.ProbeOutside(inst, dir2, width / 2, params.traverseHeight + params.dropHeight)
        if not edge2 then return nil, nil end

        return (edge1 + edge2) / 2, math.abs(edge1 - edge2)
    end

    -- Probe and store results
    local xCenter, xWidth, yCenter, yWidth

    if params.xWidth > 0 then
        xCenter, xWidth = probeAxis("X", params.xWidth, 2, 1)  -- 2=-X, 1=+X
        if not xCenter then return end
    end

    if params.yWidth > 0 then
        yCenter, yWidth = probeAxis("Y", params.yWidth, 4, 3)  -- 4=-Y, 3=+Y
        if not yCenter then return end
    end
    
    -- All probing successful, set datums
    if xCenter then
        local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
        mc.mcAxisSetPos(inst, mc.X_AXIS, currentXPos - xCenter)
        results.X = "0 at center"
        results.XWidth = xWidth
    end
    
    if yCenter then
        local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
        mc.mcAxisSetPos(inst, mc.Y_AXIS, currentYPos - yCenter)
        results.Y = "0 at center"
        results.YWidth = yWidth
    end
    
    -- Display final results
    local statusMsg = "Center set:"
    
    if params.setZDatum then
        results.Z = "0 at surface"
        statusMsg = statusMsg .. " Z=0"
    end
    
    if results.XWidth then
        statusMsg = statusMsg .. string.format(" X=0 (W=%.4f)", results.XWidth)
    end
    
    if results.YWidth then
        statusMsg = statusMsg .. string.format(" Y=0 (W=%.4f)", results.YWidth)
    end
    
    ProbeScripts.DisplayResults(inst, results, "Outside Center Probe Complete", {
        statusFormat = statusMsg,
        showDetails = false
    })

    -- Move to center if requested (only for axes that were probed)
    if params.moveToCenter then
        local moveX = (params.xWidth > 0)  -- Move X if it was probed
        local moveY = (params.yWidth > 0)  -- Move Y if it was probed
        ProbeScripts.MoveToCenter(inst, moveX, moveY)

        local movedAxes = {}
        if moveX then table.insert(movedAxes, "X") end
        if moveY then table.insert(movedAxes, "Y") end
    end
end


function ProbeScripts.ProbeInsideCenter(inst)
    if not RequestMaintenance() then return end
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Build dialog
    local fields = {
        {type = "instructions", text = "Position probe at approximate center of pocket/bore.\nProbe will find edges and set datum at calculated center."},
        {type = "separator"},
        
        {type = "radio", key = "axes", 
         label = "Probe Axes:",
         options = {"X Only", "Y Only", "X and Y"},
         columns = 3,
         default = 2},  -- Default to both axes
         
        {type = "checkbox", key = "moveToCenter", 
         label = "Move to Center",
         default = 0,
         tooltip = "Move to the calculated center position after probing"}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Inside Center Probe", fields, "ProbeInsideCenter")
    
    if not params then return end

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end
    
    local probeX = (params.axes == 0 or params.axes == 2)
    local probeY = (params.axes == 1 or params.axes == 2)
    
    local results = {}
    local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
    local offsetNum = 54
    if modalOffset >= 54 and modalOffset <= 59 then
        offsetNum = math.floor(modalOffset + 0.5)
    end
    
    -- Probe X axis if selected
    if probeX then
        -- Probe +X direction (1), returns to start automatically
        local xEdge1Work, success1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)

        if not success1 then
            mc.mcCntlSetLastError(inst, "+X Probe failed - no contact detected")
            return
        end

        -- Probe -X direction (2), returns to start automatically
        local xEdge2Work, success2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)

        if not success2 then
            mc.mcCntlSetLastError(inst, "-X Probe failed - no contact detected")
            return
        end
        
        -- Calculate center and width
        local xCenter = (xEdge1Work + xEdge2Work) / 2
        local xWidth = math.abs(xEdge1Work - xEdge2Work)
        
        -- Set X datum at center (without moving)
        local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
        local newXPosition = currentXPos - xCenter
        mc.mcAxisSetPos(inst, mc.X_AXIS, newXPosition)
        
        results.XWidth = xWidth
        results.XCenter = 0  -- Now at center
    end
    
    -- Probe Y axis if selected
    if probeY then
        -- Probe +Y direction (3), returns to start automatically
        local yEdge1Work, success1 = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)

        if not success1 then
            mc.mcCntlSetLastError(inst, "+Y Probe failed - no contact detected")
            return
        end

        -- Probe -Y direction (4), returns to start automatically
        local yEdge2Work, success2 = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)

        if not success2 then
            mc.mcCntlSetLastError(inst, "-Y Probe failed - no contact detected")
            return
        end
        
        -- Calculate center and width
        local yCenter = (yEdge1Work + yEdge2Work) / 2
        local yWidth = math.abs(yEdge1Work - yEdge2Work)
        
        -- Set Y datum at center (without moving)
        local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
        local newYPosition = currentYPos - yCenter
        mc.mcAxisSetPos(inst, mc.Y_AXIS, newYPosition)
        
        results.YWidth = yWidth
        results.YCenter = 0  -- Now at center
    end
    
    -- Build status message
    local statusMsg = string.format("G%d set:", offsetNum)
    
    if results.XWidth then
        statusMsg = statusMsg .. string.format(" X=0 (Width=%.4f)", results.XWidth)
    end
    
    if results.YWidth then
        statusMsg = statusMsg .. string.format(" Y=0 (Width=%.4f)", results.YWidth)
    end
    
    -- Display results
    ProbeScripts.DisplayResults(inst, results, "Inside Center Probe Complete", {
        statusFormat = statusMsg,
        showDetails = false
    })

    -- Move to center if requested (only for axes that were probed)
    if params.moveToCenter then
        local moveX = probeX  -- Move X if it was probed
        local moveY = probeY  -- Move Y if it was probed
        ProbeScripts.MoveToCenter(inst, moveX, moveY)

        local movedAxes = {}
        if moveX then table.insert(movedAxes, "X") end
        if moveY then table.insert(movedAxes, "Y") end
    end
end


function ProbeScripts.FindAngle(inst)
    if not RequestMaintenance() then return end
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    local lastTraverseDistance = mc.mcProfileGetDouble(inst, "ProbeFindAngle", "traverseDistance", 1.0)
    
    -- Build dialog
    local fields = {
        {type = "instructions", text = "Probe two points to find part angle.\nFirst probe, traverse, second probe, then calculate angle."},
        {type = "separator"},
        
        {type = "direction", key = "probeDirection", 
        label = "Probe Direction:",
        tooltip = "Direction to probe for both measurements",
        default = 0},  -- Default to +X
        
        {type = "direction", key = "traverseDirection", 
        label = "Traverse Direction:",
        tooltip = "Direction to move between probe points (must be perpendicular)",
        default = 2},  -- Default to +Y
        
        {type = "separator"},
        
        {type = "number", key = "traverseDistance",
         label = "Traverse Distance:",
         default = lastTraverseDistance,
         tooltip = "Distance to move in traverse direction between probes",
         min = 0.001,
         max = 50,
         validateMsg = "Must be between 0-50"}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Find Angle", fields, "ProbeFindAngle")
    
    if not params then return end

    -- Validate directions are perpendicular
    local probeIsX = (params.probeDirection <= 1)
    local traverseIsX = (params.traverseDirection <= 1)

    if probeIsX == traverseIsX then
        wx.wxMessageBox("Probe and traverse directions must be perpendicular!\n\nPlease select different axes.",
                    "Invalid Selection", wx.wxOK + wx.wxICON_ERROR)
        return ProbeScripts.FindAngle(inst)  -- Restart dialog
    end

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end

    mc.mcProfileWriteDouble(inst, "ProbeFindAngle", "traverseDistance", params.traverseDistance)
    mc.mcProfileFlush(inst)

    -- Map dialog directions to ProbeXYZ directions
    local ProbeXYZProbeDir = params.probeDirection + 1
    local ProbeXYZTraverseDir = params.traverseDirection + 1

    local axisInfo = {
        [1] = {axis = mc.X_AXIS, letter = "X", sign = 1},
        [2] = {axis = mc.X_AXIS, letter = "X", sign = -1},
        [3] = {axis = mc.Y_AXIS, letter = "Y", sign = 1},
        [4] = {axis = mc.Y_AXIS, letter = "Y", sign = -1}
    }
    
    local probeInfo = axisInfo[ProbeXYZProbeDir]
    local traverseInfo = axisInfo[ProbeXYZTraverseDir]
    
    -- Store original position in machine coordinates
    local startX = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local startY = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
    
    -- First probe
    local probe1Work, success1 = ProbeScripts.Probe(inst, ProbeXYZProbeDir, false, true, nil, nil, false, nil)
    
    if not success1 or probe1Work == nil then
        mc.mcCntlSetLastError(inst, string.format("First probe failed in %s%s direction", 
                                                  probeInfo.sign > 0 and "+" or "-", 
                                                  probeInfo.letter))
        return
    end
    
    -- Protected traverse to second position using ProtectedMove
    local traverseX = (traverseInfo.letter == "X") and (startX + traverseInfo.sign * params.traverseDistance) or startX
    local traverseY = (traverseInfo.letter == "Y") and (startY + traverseInfo.sign * params.traverseDistance) or startY

    if not ProbeScripts.ProtectedMove(inst, "mach", traverseX, traverseY, nil, 200) then
        -- Return to original start position
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f", startX, startY))
        mc.mcCntlSetLastError(inst, "Traverse collision detected - check clearance")
        return
    end

    -- Second probe
    local probe2Work, success2 = ProbeScripts.Probe(inst, ProbeXYZProbeDir, false, true, nil, nil, false, nil)
    
    if not success2 then
        -- Return to original start on failure
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f", startX, startY))
        mc.mcCntlSetLastError(inst, string.format("Second probe failed in %s%s direction", 
                                                  probeInfo.sign > 0 and "+" or "-", 
                                                  probeInfo.letter))
        return
    end

    -- Return to original starting position
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f", startX, startY))

    -- Calculate the angle (account for traverse direction sign)
    local probeDifference = probe2Work - probe1Work
    local angleRadians = math.atan(probeDifference / (traverseInfo.sign * params.traverseDistance))
    local angleDegrees = angleRadians * (180 / math.pi)
    
    -- Normalize angle to (-180, 180)
    local function normalize180(angle)
        angle = angle % 360
        if angle > 180 then
            angle = angle - 360
        elseif angle <= -180 then
            angle = angle + 360
        end
        return angle
    end

    -- Determine which axis the edge is nearest to
    local function findNearestAxis(angle)
        angle = normalize180(angle)
        
        -- Calculate smallest signed difference to each reference
        local refs = {
            {0, "X"}, {180, "X"}, {-180, "X"},
            {90, "Y"}, {-90, "Y"}
        }
        
        local bestDiff, bestAxis, bestRef = 999, "", 0
        for _, ref in ipairs(refs) do
            local diff = normalize180(angle - ref[1])
            if math.abs(diff) < math.abs(bestDiff) then
                bestDiff = diff
                bestAxis = ref[2]
                bestRef = ref[1]
            end
        end
        
        -- Determine sign for axis label
        local axisLabel = bestAxis
        if bestAxis == "X" and math.abs(bestRef) > 90 then
            axisLabel = "-X"
        elseif bestAxis == "X" then
            axisLabel = "+X"
        elseif bestRef < 0 then
            axisLabel = "-Y"
        else
            axisLabel = "+Y"
        end
        
        return axisLabel, bestDiff
    end
    
    -- Account for which axes are being used for probe and traverse
    local machineAngle = angleDegrees
    
    -- Adjust for Y traverse (rotate 90Â°)
    if traverseInfo.letter == "Y" then
        machineAngle = angleDegrees + 90
    end
    
    machineAngle = normalize180(machineAngle)

    
    -- Find nearest axis and angle from it
    local nearestAxis, angleFromAxis = findNearestAxis(machineAngle)
    
    -- Format the angle display
    local angleDisplay = string.format("Edge is %.3fÂ° from %s axis", math.abs(angleFromAxis), nearestAxis)
    
    -- Build description
    local angleDescription = string.format("%s\n\nProbe difference: %.4f %s\nTraverse distance: %.4f %s",
                                          angleDisplay, math.abs(probeDifference), probeInfo.letter,
                                          params.traverseDistance, traverseInfo.letter)
    
    -- Show results dialog with apply option
    local axisCore = nearestAxis:match("[XY]")  -- "X" or "Y"
    local rAngle = (axisCore == "Y") and -angleFromAxis or angleFromAxis

    local resultFields = {
        {type = "instructions", text = angleDescription},
        {type = "separator"},
        {type = "description", key = "rotateInfo",
        text = string.format("Apply G68 rotation of %.4f degrees to align with %s?",
                            rAngle, nearestAxis)}
    }


    local resultParams = ProbeScripts.ShowDialog(inst, "Angle Found", resultFields,
                                                 "ProbeFindAngleResult",
                                                 {ok = "Apply Rotation", cancel = "Cancel"})

    if resultParams then
        -- Apply G68 rotation
        local rotateCmd = string.format("G68 X0 Y0 R%.4f", rAngle)
        mc.mcCntlGcodeExecuteWait(inst, rotateCmd)
        mc.mcCntlSetLastError(inst, string.format("Rotation applied: %.4fÂ° to align with %s", 
                                                  rAngle, nearestAxis))
    else
        mc.mcCntlSetLastError(inst, string.format("Found: %.3fÂ° from %s (rotation not applied)", 
                                                  math.abs(angleFromAxis), nearestAxis))
    end
end



function ProbeScripts.CalibrateProbeDiameter(inst)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Get last used reference diameters from profile
    local lastBossDiameter = mc.mcProfileGetDouble(inst, "ProbeCalibration", "bossDiameter", 2.0)
    local lastBoreDiameter = mc.mcProfileGetDouble(inst, "ProbeCalibration", "boreDiameter", 1.0)
    local lastLiftHeight = mc.mcProfileGetDouble(inst, "ProbeCalibration", "liftHeight", 0.5)

    -- Build dialog
    local fields = {
        {type = "instructions", text = "Position probe inside the bore at desired calibration height."},
        {type = "instructions", text = "The bore and boss must be concentric for accurate calibration."},
        {type = "separator"},

        {type = "number", key = "boreDiameter",
         label = "Bore Reference Diameter:",
         default = lastBoreDiameter,
         tooltip = "Known inner diameter of the calibration bore",
         min = 0.001,
         max = 10,
         validateMsg = "Must be between 0-10"},

        {type = "number", key = "bossDiameter",
         label = "Boss Reference Diameter:",
         default = lastBossDiameter,
         tooltip = "Known outer diameter of the calibration boss",
         min = 0.001,
         max = 10,
         validateMsg = "Must be between 0-10"},

        {type = "number", key = "liftHeight",
         label = "Z Lift Height:",
         default = lastLiftHeight,
         tooltip = "Height to lift Z before moving out for boss probing",
         min = 0.001,
         max = 2,
         validateMsg = "Must be between 0-2"}
    }

    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Calibrate Probe Diameter", fields, "ProbeCalibration")
    if not params then return end

    -- Validate that bore is smaller than boss
    if params.boreDiameter >= params.bossDiameter then
        mc.mcCntlSetLastError(inst, "Error: Bore diameter must be smaller than boss diameter")
        return
    end

    -- Save reference diameters to profile
    mc.mcProfileWriteDouble(inst, "ProbeCalibration", "bossDiameter", params.bossDiameter)
    mc.mcProfileWriteDouble(inst, "ProbeCalibration", "boreDiameter", params.boreDiameter)
    mc.mcProfileWriteDouble(inst, "ProbeCalibration", "liftHeight", params.liftHeight)
    mc.mcProfileFlush(inst)

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end

    -- Store old probe diameter values before zeroing
    local oldProbeDiamPlusX = mc.mcCntlGetPoundVar(inst, 511)
    local oldProbeDiamMinusX = mc.mcCntlGetPoundVar(inst, 512)
    local oldProbeDiamPlusY = mc.mcCntlGetPoundVar(inst, 513)
    local oldProbeDiamMinusY = mc.mcCntlGetPoundVar(inst, 514)

    -- Helper function to restore original values on failure
    local function restoreOriginalValues()
        mc.mcCntlSetPoundVar(inst, 511, oldProbeDiamPlusX)
        mc.mcCntlSetPoundVar(inst, 512, oldProbeDiamMinusX)
        mc.mcCntlSetPoundVar(inst, 513, oldProbeDiamPlusY)
        mc.mcCntlSetPoundVar(inst, 514, oldProbeDiamMinusY)
    end

    -- Set probe diameters to 0 for calibration
    mc.mcCntlSetPoundVar(inst, 511, 0)
    mc.mcCntlSetPoundVar(inst, 512, 0)
    mc.mcCntlSetPoundVar(inst, 513, 0)
    mc.mcCntlSetPoundVar(inst, 514, 0)

    -- Store starting Z position (machine coordinates)
    local startZMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    mc.mcCntlSetLastError(inst, "Starting BORE calibration...")

    -- First probe X to get centered for Y probing
    local boreXPlus1, xPlusSuccess1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, 0)
    if not xPlusSuccess1 then
        mc.mcCntlSetLastError(inst, "Bore +X probe failed")
        restoreOriginalValues()
        return
    end

    local boreXMinus1, xMinusSuccess1 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, 0)
    if not xMinusSuccess1 then
        mc.mcCntlSetLastError(inst, "Bore -X probe failed")
        restoreOriginalValues()
        return
    end

    -- Move to X center
    local xCenterBore = (boreXPlus1 + boreXMinus1) / 2
    local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local xOffset = xCenterBore - currentXPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 X%.4f F200", xOffset))

    -- Probe bore Y (now centered in X)
    local boreYPlus, yPlusSuccess = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, 0)
    if not yPlusSuccess then
        mc.mcCntlSetLastError(inst, "Bore +Y probe failed")
        restoreOriginalValues()
        return
    end

    local boreYMinus, yMinusSuccess = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, 0)
    if not yMinusSuccess then
        mc.mcCntlSetLastError(inst, "Bore -Y probe failed")
        restoreOriginalValues()
        return
    end

    -- Move to Y center
    local yCenterBore = (boreYPlus + boreYMinus) / 2
    local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    local yOffset = yCenterBore - currentYPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 Y%.4f F200", yOffset))

    -- Final bore X probing (now centered in Y)
    local boreXPlus2, xPlusSuccess2 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, 0)
    if not xPlusSuccess2 then
        mc.mcCntlSetLastError(inst, "Final bore +X probe failed")
        restoreOriginalValues()
        return
    end

    local boreXMinus2, xMinusSuccess2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, 0)
    if not xMinusSuccess2 then
        mc.mcCntlSetLastError(inst, "Final bore -X probe failed")
        restoreOriginalValues()
        return
    end

    -- Calculate bore widths
    local boreXWidth = math.abs(boreXPlus2 - boreXMinus2)
    local boreYWidth = math.abs(boreYPlus - boreYMinus)

    mc.mcCntlSetLastError(inst, "Starting BOSS calibration...")

    -- Lift Z by liftHeight
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G0 Z%.4f", params.liftHeight))

    -- Calculate traverse distance for boss
    local bossTraverseDistance = params.bossDiameter / 2 + 0.5

    -- BOSS PROBING SEQUENCE
    -- First probe boss X to get centered
    local bossXMinus1 = ProbeScripts.ProbeOutside(inst, 2, bossTraverseDistance, params.liftHeight)
    if not bossXMinus1 then
        mc.mcCntlSetLastError(inst, "Boss -X probe failed")
        restoreOriginalValues()
        return
    end

    local bossXPlus1 = ProbeScripts.ProbeOutside(inst, 1, bossTraverseDistance, params.liftHeight)
    if not bossXPlus1 then
        mc.mcCntlSetLastError(inst, "Boss +X probe failed")
        restoreOriginalValues()
        return
    end

    -- Move to X center
    local xCenterBoss = (bossXMinus1 + bossXPlus1) / 2
    local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local xOffset = xCenterBoss - currentXPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 X%.4f F200", xOffset))

    -- Probe boss Y (now centered in X)
    local bossYMinus = ProbeScripts.ProbeOutside(inst, 4, bossTraverseDistance, params.liftHeight)
    if not bossYMinus then
        mc.mcCntlSetLastError(inst, "Boss -Y probe failed")
        restoreOriginalValues()
        return
    end

    local bossYPlus = ProbeScripts.ProbeOutside(inst, 3, bossTraverseDistance, params.liftHeight)
    if not bossYPlus then
        mc.mcCntlSetLastError(inst, "Boss +Y probe failed")
        restoreOriginalValues()
        return
    end

    -- Move to Y center
    local yCenterBoss = (bossYMinus + bossYPlus) / 2
    local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    local yOffset = yCenterBoss - currentYPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 Y%.4f F200", yOffset))

    -- Final boss X probing (now centered in Y)
    local bossXMinus2 = ProbeScripts.ProbeOutside(inst, 2, bossTraverseDistance, params.liftHeight)
    if not bossXMinus2 then
        mc.mcCntlSetLastError(inst, "Final boss -X probe failed")
        restoreOriginalValues()
        return
    end

    local bossXPlus2 = ProbeScripts.ProbeOutside(inst, 1, bossTraverseDistance, params.liftHeight)
    if not bossXPlus2 then
        mc.mcCntlSetLastError(inst, "Final boss +X probe failed")
        restoreOriginalValues()
        return
    end

    -- Calculate boss widths
    local bossXWidth = math.abs(bossXPlus2 - bossXMinus2)
    local bossYWidth = math.abs(bossYPlus - bossYMinus)

    -- Return to original Z height
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))

    local bossRadius = params.bossDiameter / 2
    local boreRadius = params.boreDiameter / 2
    local radiusDifference = bossRadius - boreRadius

    -- Calculate probe diameter for each direction
    local probeDiamPlusX = (bossXPlus2 - boreXPlus2) - radiusDifference
    local probeDiamMinusX = (boreXMinus2 - bossXMinus2) - radiusDifference
    local probeDiamPlusY = (bossYPlus - boreYPlus) - radiusDifference
    local probeDiamMinusY = (boreYMinus - bossYMinus) - radiusDifference

    -- Store the calculated probe diameters in PVs 511-514
    mc.mcCntlSetPoundVar(inst, 511, probeDiamPlusX)   -- +X
    mc.mcCntlSetPoundVar(inst, 512, probeDiamMinusX)  -- -X
    mc.mcCntlSetPoundVar(inst, 513, probeDiamPlusY)   -- +Y
    mc.mcCntlSetPoundVar(inst, 514, probeDiamMinusY)  -- -Y

    -- Save to profile
    mc.mcProfileWriteDouble(inst, "SystemSettings", "PV511", probeDiamPlusX)
    mc.mcProfileWriteDouble(inst, "SystemSettings", "PV512", probeDiamMinusX)
    mc.mcProfileWriteDouble(inst, "SystemSettings", "PV513", probeDiamPlusY)
    mc.mcProfileWriteDouble(inst, "SystemSettings", "PV514", probeDiamMinusY)
    mc.mcProfileFlush(inst)

    -- Display results
    mc.mcCntlSetLastError(inst, string.format("Probe Calibration Complete:"))
    mc.mcCntlSetLastError(inst, string.format("  +X Diameter: %.4f\" (was %.4f\")", probeDiamPlusX, oldProbeDiamPlusX))
    mc.mcCntlSetLastError(inst, string.format("  -X Diameter: %.4f\" (was %.4f\")", probeDiamMinusX, oldProbeDiamMinusX))
    mc.mcCntlSetLastError(inst, string.format("  +Y Diameter: %.4f\" (was %.4f\")", probeDiamPlusY, oldProbeDiamPlusY))
    mc.mcCntlSetLastError(inst, string.format("  -Y Diameter: %.4f\" (was %.4f\")", probeDiamMinusY, oldProbeDiamMinusY))

    return probeDiamPlusX, probeDiamMinusX, probeDiamPlusY, probeDiamMinusY
end

-- Probe Tool Position - Measures pull stud position and saves to tool table
function ProbeScripts.ProbeToolPosition(inst)
    if not RequestMaintenance() then return end
    if not ProbeScripts.CheckProbeDeployed(inst) then return end
    if not ProbeScripts.CheckG68Rotation(inst) then return end

    -- Hardcoded parameters for pull stud
    local pullStudWidth = 1.0
    local traverseHeight = 0.2
    local holderTaperHeight = 2.8
    local holderDropHeight = 0.1
    local traverseFeedrate = 50

    -- Build dialog to get tool number
    local fields = {
        {type = "instructions", text = "Position probe directly over the pull stud of the tool holder.\nThis will measure and save the tool's XYZ position in the tool table."},
        {type = "separator"},

        {type = "number", key = "toolNumber",
         label = "Tool Number:",
         width = 60,
         default = 1,
         isInteger = true,
         min = 1,
         max = 89,
         validateMsg = "Must be 1-89 (90+ are reserved for virtual tools)",
         tooltip = "Enter the tool number for this position (1-89)"}
    }

    local params = ProbeScripts.ShowDialog(inst, "Probe Tool Position", fields, "ProbeToolPosition")
    if not params then return end
    local toolNum = params.toolNumber

    mc.mcCntlSetLastError(inst, string.format("Probing tool T%d position...", toolNum))

    -- First probe down to find the top surface of the pull stud
    local surfaceWork, zSuccess = ProbeScripts.Probe(inst, 5, false, false, nil, nil, false, traverseHeight)
    if not zSuccess then
        mc.mcCntlSetLastError(inst, "Failed to find pull stud surface")
        return false
    end

    -- Get the latched probe Z position for accuracy
    local surfaceZMachine = mc.mcAxisGetProbePos(inst, mc.Z_AXIS, 1)  -- 1 = machine coords

    -- Probe pull stud XY position
    local dropHeight = traverseHeight + holderDropHeight

    local xPlusResult = ProbeScripts.ProbeOutside(inst, 1, pullStudWidth/2, dropHeight, traverseFeedrate)  -- 1 = +X
    if not xPlusResult then
        mc.mcCntlSetLastError(inst, "Failed to probe +X edge")
        return false
    end

    local xMinusResult = ProbeScripts.ProbeOutside(inst, 2, pullStudWidth/2, dropHeight, traverseFeedrate)  -- 2 = -X
    if not xMinusResult then
        mc.mcCntlSetLastError(inst, "Failed to probe -X edge")
        return false
    end

    local yPlusResult = ProbeScripts.ProbeOutside(inst, 3, pullStudWidth/2, dropHeight, traverseFeedrate)  -- 3 = +Y
    if not yPlusResult then
        mc.mcCntlSetLastError(inst, "Failed to probe +Y edge")
        return false
    end

    local yMinusResult = ProbeScripts.ProbeOutside(inst, 4, pullStudWidth/2, dropHeight, traverseFeedrate)  -- 4 = -Y
    if not yMinusResult then
        mc.mcCntlSetLastError(inst, "Failed to probe -Y edge")
        return false
    end

    -- Calculate center from probed edges
    local centerX = (xPlusResult + xMinusResult) / 2
    local centerY = (yPlusResult + yMinusResult) / 2

    -- Move probe to center of pull stud
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F100", centerX, centerY))

    -- Get the probe's position in machine coordinates at center
    local probeXMachine = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local probeYMachine = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)

    -- Calculate spindle position when probe is at center
    local probeXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90)
    local probeYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90)
    local centerXMachine = probeXMachine - probeXOffset
    local centerYMachine = probeYMachine - probeYOffset

    -- Calculate Z pickup height
    local probeHeight = mc.mcToolGetData(inst, mc.MTOOL_MILL_HEIGHT, 90)
    local zPickupHeight = surfaceZMachine - probeHeight - holderTaperHeight

    -- Save tool position to tool table
    mc.mcToolSetDataExDbl(inst, toolNum, "XToolChange", centerXMachine)
    mc.mcToolSetDataExDbl(inst, toolNum, "YToolChange", centerYMachine)
    mc.mcToolSetDataExDbl(inst, toolNum, "ZToolChange", zPickupHeight)

    -- Save tool table
    mc.mcToolSaveFile(inst)

    mc.mcCntlSetLastError(inst, string.format("T%d position saved: X%.4f Y%.4f Z%.4f",
        toolNum, centerXMachine, centerYMachine, zPickupHeight))

    return true
end



function ProbeScripts.CalibrateProbeOffset(inst)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end
    
    -- Build dialog with a checkbox to ensure proper dialog behavior
    local fields = {
        {type = "instructions", text = "Spindle must be manually centered over bore with work 0,0 set.\nPosition probe inside bore before starting.\nThis will calibrate T90 XY offsets in tool table."},
        {type = "separator"},
        {type = "checkbox", key = "confirm", label = "Ready to calibrate", default = 0}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Calibrate Probe Offset", fields, "ProbeOffsetCalibration")
    if not params or not params.confirm then return end
    
    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end

    -- Store old T90 offsets before zeroing
    local oldProbeOffsetX = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90)
    local oldProbeOffsetY = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90)

    -- Helper function to restore original values on failure
    local function restoreOriginalOffsets()
        mc.mcToolSetData(inst, mc.MTOOL_MILL_X, 90, oldProbeOffsetX)
        mc.mcToolSetData(inst, mc.MTOOL_MILL_Y, 90, oldProbeOffsetY)
        mc.mcCntlGcodeExecuteWait(inst, "G49 G43 H90")
    end

    -- Zero the T90 tool table XY offsets
    mc.mcToolSetData(inst, mc.MTOOL_MILL_X, 90, 0)
    mc.mcToolSetData(inst, mc.MTOOL_MILL_Y, 90, 0)

    -- Reload tool to apply zero offsets
    mc.mcCntlGcodeExecuteWait(inst, "G49 G43 H90")

    -- First X probe sequence
    local xEdge1Work, success = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    if not success then
        restoreOriginalOffsets()
        return
    end

    local xEdge2Work, success = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    if not success then
        restoreOriginalOffsets()
        return
    end

    -- Calculate X center and move there using incremental
    local xCenter = (xEdge1Work + xEdge2Work) / 2
    local xWidth = math.abs(xEdge1Work - xEdge2Work)
    local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local xOffset = xCenter - currentXPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 X%.4f F200", xOffset))

    -- Y probe sequence
    local yEdge1Work, success = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    if not success then
        restoreOriginalOffsets()
        return
    end

    local yEdge2Work, success = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
    if not success then
        restoreOriginalOffsets()
        return
    end

    -- Calculate Y center and move there using incremental
    local yCenter = (yEdge1Work + yEdge2Work) / 2
    local yWidth = math.abs(yEdge1Work - yEdge2Work)
    local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    local yOffset = yCenter - currentYPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 Y%.4f F200", yOffset))

    -- Second X probe sequence for refinement
    local xEdge1Work_2, success = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    if not success then
        restoreOriginalOffsets()
        return
    end

    local xEdge2Work_2, success = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    if not success then
        restoreOriginalOffsets()
        return
    end
    
    -- Calculate refined X center and move to final center
    local xCenterFinal = (xEdge1Work_2 + xEdge2Work_2) / 2
    local xWidthFinal = math.abs(xEdge1Work_2 - xEdge2Work_2)
    
    -- Move to final center position using incremental
    local currentXPos2 = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local xOffset2 = xCenterFinal - currentXPos2
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 X%.4f F200", xOffset2))
    
    -- Get current work coordinates - these are the probe offsets
    local probeOffsetX = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local probeOffsetY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    
    -- Apply offsets to T90 tool table as-is
    mc.mcToolSetData(inst, mc.MTOOL_MILL_X, 90, probeOffsetX)
    mc.mcToolSetData(inst, mc.MTOOL_MILL_Y, 90, probeOffsetY)
    
    -- Save tool table and reload offsets
    mc.mcToolSaveFile(inst)
    mc.mcCntlGcodeExecuteWait(inst, "G49 G43 H90")
    
    -- Display results
    local message = string.format(
        "T90 Offsets Calibrated:\nX: %.4f\" (was %.4f\")\nY: %.4f\" (was %.4f\")\n\nBore Width:\nX: %.4f\"\nY: %.4f\"",
        probeOffsetX, oldProbeOffsetX, probeOffsetY, oldProbeOffsetY, xWidthFinal, yWidth)

    mc.mcCntlSetLastError(inst, string.format("T90 offsets set: X%.4f (was %.4f) Y%.4f (was %.4f)", probeOffsetX, oldProbeOffsetX, probeOffsetY, oldProbeOffsetY))

    return probeOffsetX, probeOffsetY
end


function ProbeScripts.ProbeKeys(inst)
    -- ========== PRE-CHECKS ==========

    -- Heartbeat check helper (returns true if valid, false otherwise)
    local HEARTBEAT_FILE = "C:\\Mach4Hobby\\Profiles\\BLP\\Logs\\FUSION_HEARTBEAT.txt"
    local HEARTBEAT_MAX_AGE = 30  -- seconds - allow some slack for network latency

    local function checkHeartbeat()
        local heartbeatFile = io.open(HEARTBEAT_FILE, "r")
        if not heartbeatFile then return false end

        local heartbeatTimestamp = tonumber(heartbeatFile:read("*a"))
        heartbeatFile:close()

        if not heartbeatTimestamp then return false end

        local heartbeatAge = os.time() - heartbeatTimestamp
        return heartbeatAge <= HEARTBEAT_MAX_AGE
    end

    -- First heartbeat check (silent - don't show error yet)
    local firstHeartbeatOk = checkHeartbeat()

    -- Check probe deployment
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Check front vacuum is on (OUTPUT6)
    local vacFrontHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6)
    local vacFrontState = mc.mcSignalGetState(vacFrontHandle)
    if vacFrontState ~= 1 then
        wx.wxMessageBox("Front vacuum must be ON before running ProbeKeys.\n\nPlease turn on the front vacuum and try again.",
            "Vacuum Required", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check dust collection automation is enabled (OUTPUT50 = dustAuto, OUTPUT52 = bootAuto)
    local dustAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT50)
    local dustAutoState = mc.mcSignalGetState(dustAutoHandle)
    local bootAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT52)
    local bootAutoState = mc.mcSignalGetState(bootAutoHandle)

    if dustAutoState ~= 1 or bootAutoState ~= 1 then
        local missing = {}
        if dustAutoState ~= 1 then table.insert(missing, "Dust Collect Auto") end
        if bootAutoState ~= 1 then table.insert(missing, "Dust Boot Auto") end

        local result = wx.wxMessageBox(
            "The following automation settings are not enabled:\n\nâ¢ " .. table.concat(missing, "\nâ¢ ") ..
            "\n\nIt is recommended to enable these before running ProbeKeys.\n\nContinue anyway?",
            "Automation Warning", wx.wxYES_NO + wx.wxICON_WARNING)

        if result ~= wx.wxYES then
            return
        end
    end

    mc.mcCntlGcodeExecuteWait(inst, "G55")

    -- ========== DIALOG ==========

    local fields = {
        {type = "instructions",
         text = "Enter piano information for key probing.\nKey section will be auto-detected."},
        {type = "text", key = "make", label = "Piano Make",
         default = "Steinway",
         validate = function(value)
             if value:match("_") then
                 return false, "Piano Make cannot contain underscores (_)"
             end
             if value:match("^%s*$") then
                 return false, "Piano Make cannot be empty"
             end
             return true
         end},
        {type = "text", key = "serial", label = "Serial Number",
         default = "123456",
         validate = function(value)
             if value:match("_") then
                 return false, "Serial Number cannot contain underscores (_)"
             end
             if value:match("^%s*$") then
                 return false, "Serial Number cannot be empty"
             end
             return true
         end}
    }

    local params = ProbeScripts.ShowDialog(inst, "Piano Key Probing", fields, "ProbeKeys")
    if not params then return end

    -- Second heartbeat check - only show error if both checks failed
    local secondHeartbeatOk = checkHeartbeat()
    if not firstHeartbeatOk and not secondHeartbeatOk then
        wx.wxMessageBox("Fusion 360 add-in is not running.\n\nPlease start Fusion 360, open 'Parametrized Keytop Toolpath', and enable the Keytop Parametric Update add-in before probing.",
            "Fusion Not Running", wx.wxOK + wx.wxICON_ERROR)
        return
    end

    -- Cancel any existing G68 rotation
    mc.mcCntlGcodeExecuteWait(inst, "G69")

    -- ========== CONFIGURATION ==========

    local SINGLE_TAP_FEEDRATE = 40  -- IPM for single tap probes after calibration
    local KEY_SPACING = 1.7  -- inches between white keys
    local FIRST_KEY_X = 1.75  -- X position of first key center
    local BORE_SEPARATION = 46.0  -- inches between calibration bores
    local PROBE_DROP_DEPTH = 0.05  -- uniform drop depth for X and -Y probing
    local LINEARITY_THRESHOLD = 0.01  -- maximum deviation before adding extra probe points
    local safeTraverseZ = 2.0  -- safe Z height in work coords
    local ID_HOLE_DEPTH_THRESHOLD = -0.05  -- halfway between 0 and -0.1
    local SAMPLE_KEY_INTERVAL = 6  -- probe every 6th key (1, 7, 13, 19, 25)
    local NUM_KEYS = 26  -- total white keys per section

    -- Y positions for X edge probing
    local Y_POSITIONS = {-0.95, -0.35, 0.25, 1.10, 2.75, 4.25}
    local Y_POSITIONS_EXTRA_FRONT = {-1.05, -0.65, -0.05, 0.35}
    local Y_POSITIONS_EXTRA_BACK = {0.95, 1.95, 3.55, 4.35}

    -- Lower half key index table
    local LOWER_KEYS = {
        {1, 1}, {3, 2}, {4, 3}, {6, 4}, {8, 5}, {9, 6}, {11, 7}, {13, 8},
        {15, 9}, {16, 10}, {18, 11}, {20, 12}, {21, 13}, {23, 14}, {25, 15},
        {27, 16}, {28, 17}, {30, 18}, {32, 19}, {33, 20}, {35, 21}, {37, 22},
        {39, 23}, {40, 24}, {42, 25}, {44, 26}
    }

    -- Upper half key index table
    local UPPER_KEYS = {
        {45, 1}, {47, 2}, {49, 3}, {51, 4}, {52, 5}, {54, 6}, {56, 7}, {57, 8},
        {59, 9}, {61, 10}, {63, 11}, {64, 12}, {66, 13}, {68, 14}, {69, 15},
        {71, 16}, {73, 17}, {75, 18}, {76, 19}, {78, 20}, {80, 21}, {81, 22},
        {83, 23}, {85, 24}, {87, 25}, {88, 26}
    }

    -- Storage
    local centeringHeightMachine  -- bore centering height in machine coords
    local calibrationOffsets = {}  -- single-tap calibration offsets
    local doubleResults = {}
    local singleResults = {["+X"] = {}, ["-X"] = {}, ["+Y"] = {}, ["-Y"] = {}, ["-Z"] = {}}
    local TEST_KEYS = nil
    local keyHalfName = nil
    local traverseHeight  -- calculated after Z probing
    local probeZ  -- uniform probe depth for X and -Y

    -- Files - set after key section is determined
    local pianoFolder = nil
    local pianoName = nil
    local csvPath = nil
    local reportFile = nil

    -- Helper function to write to report
    local function writeReport(message)
        if reportFile then
            local timestamp = os.date("%Y-%m-%d %H:%M:%S")
            reportFile:write(string.format("[%s] %s\n", timestamp, message))
            reportFile:flush()
        end
    end

    -- Helper to write to CSV
    local function writeBatchToCSV(csvFile, dataPoints)
        for _, point in ipairs(dataPoints) do
            csvFile:write(string.format("%d,%d,%d,%.6f,%.6f,%.6f,%s\n",
                point.enumKey, point.pianoKey, point.direction, point.x, point.y, point.z, point.timestamp))
        end
        csvFile:flush()
    end

    -- Calculate linearity of 3 points
    local function calculateLinearity(points)
        local n = #points
        if n ~= 3 then return 0 end

        local p1 = points[1]
        local p2 = points[2]
        local p3 = points[3]

        local dx = p3.x - p1.x
        local dy = p3.y - p1.y

        if math.abs(dy) < 0.0001 then
            return math.abs(p2.x - p1.x)
        elseif math.abs(dx) < 0.000001 then
            return 0
        end

        local a = dy
        local b = -dx
        local c = dx * p1.y - dy * p1.x

        local distance = math.abs(a * p2.x + b * p2.y + c) / math.sqrt(a * a + b * b)
        return distance
    end

    -- Helper for bore center probing
    local function probeBoreCenter()
        local xEdge1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
        local xEdge2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
        local centerX = (xEdge1 + xEdge2) / 2

        local yEdge1 = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
        local yEdge2 = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
        local centerY = (yEdge1 + yEdge2) / 2

        return centerX, centerY
    end

    -- Helper to probe key side (X edges)
    local function probeKeySide(keyIndex, direction, xPosition)
        local keyInfo = TEST_KEYS[keyIndex]
        local pianoKey = keyInfo[1]
        local enumKey = keyInfo[2]
        local results = {}

        local XTolerance = 0.005
        local currentX = mc.mcAxisGetPos(inst, mc.X_AXIS)

        if math.abs(currentX - xPosition) > XTolerance then
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))
            if not ProbeScripts.ProtectedMove(inst, "work", xPosition, Y_POSITIONS[1], traverseHeight, 300) then return false end
            if not ProbeScripts.ProtectedMove(inst, "work", nil, nil, probeZ) then return false end
        else
            if not ProbeScripts.ProtectedMove(inst, "work", nil, Y_POSITIONS[1], nil, 200) then return false end
        end

        local xMeasurements = {}
        for i, yPos in ipairs(Y_POSITIONS) do
            if i > 1 then
                if not ProbeScripts.ProtectedMove(inst, "work", xPosition, yPos, nil) then return false end
            end

            local xEdge = ProbeScripts.Probe(inst, direction, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
            local offsetKey = direction == 1 and "+X" or "-X"
            xEdge = xEdge - calibrationOffsets[offsetKey]
            xMeasurements[i] = xEdge

            table.insert(results, {
                enumKey = enumKey,
                pianoKey = pianoKey,
                direction = direction,
                x = xEdge,
                y = yPos,
                z = probeZ,
                timestamp = os.date("%Y-%m-%d %H:%M:%S")
            })
        end

        -- Check linearity of front points (indices 1-3)
        local frontPoints = {}
        for i = 1, 3 do
            table.insert(frontPoints, {y = Y_POSITIONS[i], x = xMeasurements[i]})
        end

        local frontDistance = calculateLinearity(frontPoints)

        if frontDistance > LINEARITY_THRESHOLD then
            for _, yPos in ipairs(Y_POSITIONS_EXTRA_FRONT) do
                if not ProbeScripts.ProtectedMove(inst, "work", xPosition, yPos, nil) then return false end

                local xEdge = ProbeScripts.Probe(inst, direction, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
                local offsetKey = direction == 1 and "+X" or "-X"
                xEdge = xEdge - calibrationOffsets[offsetKey]

                table.insert(results, {
                    enumKey = enumKey,
                    pianoKey = pianoKey,
                    direction = direction,
                    x = xEdge,
                    y = yPos,
                    z = probeZ,
                    timestamp = os.date("%Y-%m-%d %H:%M:%S")
                })

                table.insert(xMeasurements, xEdge)
            end
        end

        -- Check linearity of back points (indices 4-6)
        local backPoints = {}
        for i = 4, 6 do
            table.insert(backPoints, {y = Y_POSITIONS[i], x = xMeasurements[i]})
        end

        local backDistance = calculateLinearity(backPoints)

        if backDistance > LINEARITY_THRESHOLD then
            for _, yPos in ipairs(Y_POSITIONS_EXTRA_BACK) do
                if not ProbeScripts.ProtectedMove(inst, "work", xPosition, yPos, nil) then return false end

                local xEdge = ProbeScripts.Probe(inst, direction, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
                local offsetKey = direction == 1 and "+X" or "-X"
                xEdge = xEdge - calibrationOffsets[offsetKey]

                table.insert(results, {
                    enumKey = enumKey,
                    pianoKey = pianoKey,
                    direction = direction,
                    x = xEdge,
                    y = yPos,
                    z = probeZ,
                    timestamp = os.date("%Y-%m-%d %H:%M:%S")
                })

                table.insert(xMeasurements, xEdge)
            end
        end

        -- Analyze shoulder accessibility
        local shoulderInfo = nil
        local probeDiamPlusX = mc.mcCntlGetPoundVar(inst, 511)
        local probeDiamMinusX = mc.mcCntlGetPoundVar(inst, 512)
        local probeDiamPlusY = mc.mcCntlGetPoundVar(inst, 513)
        local probeDiamMinusY = mc.mcCntlGetPoundVar(inst, 514)
        local probeDiameter = math.max(probeDiamPlusX, probeDiamMinusX, probeDiamPlusY, probeDiamMinusY)
        local minClearance = 1.75 * probeDiameter
        local minDiff = math.huge
        local closestFrontIdx = 0
        local closestBackIdx = 0

        for frontIdx = 1, 3 do
            for backIdx = 4, 6 do
                local diff = math.abs(xMeasurements[frontIdx] - xMeasurements[backIdx])
                if diff < minDiff then
                    minDiff = diff
                    closestFrontIdx = frontIdx
                    closestBackIdx = backIdx
                end
            end
        end

        if minDiff > minClearance then
            local xMidpoint = (xMeasurements[closestFrontIdx] + xMeasurements[closestBackIdx]) / 2
            shoulderInfo = {
                accessible = true,
                xPosition = xMidpoint,
                yPosition = Y_POSITIONS[4],
                enumKey = enumKey,
                pianoKey = pianoKey,
                clearance = minDiff
            }
        end

        local csvFile = io.open(csvPath, "a")
        writeBatchToCSV(csvFile, results)
        csvFile:close()

        if shoulderInfo and shoulderInfo.accessible then
            local sideName = direction == 1 and "left" or "right"
            writeReport(string.format("Key %d: %s side shoulder accessible (clearance: %.4f)", pianoKey, sideName, shoulderInfo.clearance))
        end

        return results, shoulderInfo
    end

    -- ========== MAIN SCRIPT START ==========

    -- Get bore location from settings
    local boreMachineX = mc.mcCntlGetPoundVar(inst, 540)
    local boreMachineY = mc.mcCntlGetPoundVar(inst, 541)

    if boreMachineX == 0 and boreMachineY == 0 then
        wx.wxMessageBox("Bore location not configured.\n\nPlease set the bore machine coordinates in System Settings > Keytop Replacement.",
            "Configuration Required", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    -- Get T90 tool table offsets
    local toolXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90) or 0
    local toolYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90) or 0

    -- Calculate spindle position to put probe tip at bore center
    local spindleTargetX = boreMachineX + toolXOffset
    local spindleTargetY = boreMachineY + toolYOffset

    -- Move to safe Z height first
    mc.mcCntlSetLastError(inst, "Moving to bore location...")
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z-0.05")

    -- Move spindle to calculated position
    if not ProbeScripts.ProtectedMove(inst, "mach", spindleTargetX, spindleTargetY, nil, 300) then return false end

    -- ========== LEFT BORE CALIBRATION ==========

    -- Probe down to find bore bottom
    doubleResults["-Z"] = ProbeScripts.Probe(inst, 5, false, false, nil, nil, false, nil)
    local boreBottomZ = doubleResults["-Z"]

    -- Move up 0.25" and note position
    mc.mcCntlGcodeExecuteWait(inst, "G91 G0 Z0.25")
    centeringHeightMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Double tap all four sides
    doubleResults["+X"] = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    doubleResults["-X"] = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    doubleResults["+Y"] = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    doubleResults["-Y"] = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)

    -- Calculate and move to center
    local leftBoreCenterX = (doubleResults["+X"] + doubleResults["-X"]) / 2
    local leftBoreCenterY = (doubleResults["+Y"] + doubleResults["-Y"]) / 2
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F200", leftBoreCenterX, leftBoreCenterY))

    -- Single tap calibration for +X, -X, +Y, -Y, -Z
    for cycle = 1, 3 do
        singleResults["+X"][cycle] = ProbeScripts.Probe(inst, 1, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        singleResults["-X"][cycle] = ProbeScripts.Probe(inst, 2, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        singleResults["+Y"][cycle] = ProbeScripts.Probe(inst, 3, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        singleResults["-Y"][cycle] = ProbeScripts.Probe(inst, 4, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        singleResults["-Z"][cycle] = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    end

    -- Calculate calibration offsets
    for direction, singles in pairs(singleResults) do
        local sum = 0
        for _, singleValue in ipairs(singles) do
            sum = sum + (singleValue - doubleResults[direction])
        end
        calibrationOffsets[direction] = sum / #singles
    end

    -- Set XY datum at bore center
    mc.mcAxisSetPos(inst, mc.X_AXIS, 0)
    mc.mcAxisSetPos(inst, mc.Y_AXIS, 0)

    -- Move out of bore and probe surface for Z datum
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", boreBottomZ + 1))
    if not ProbeScripts.ProtectedMove(inst, "inc", 0.6, nil, nil, 200) then return false end
    local surfaceZ = ProbeScripts.Probe(inst, 5, true, true, nil, nil, false, nil)

    -- Move back to bore center
    if not ProbeScripts.ProtectedMove(inst, "work", 0, 0, nil, 200) then return false end

    -- ========== FIXTURE ID PROBING ==========

    local fixtureIDBits = {}

    for i = 1, 10 do
        local yPos = 1.0 + (i - 1) * 0.5
        if not ProbeScripts.ProtectedMove(inst, "work", 0, yPos, nil, 200) then return false end
        local holeZ = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        holeZ = holeZ - calibrationOffsets["-Z"]

        local bitValue = (holeZ < ID_HOLE_DEPTH_THRESHOLD) and 1 or 0
        fixtureIDBits[i] = bitValue
    end

    -- Verify check bits
    if fixtureIDBits[9] ~= 0 or fixtureIDBits[10] ~= 1 then
        wx.wxMessageBox(string.format("Fixture ID check bits invalid!\n\nBit 9 = %d (expected 0)\nBit 10 = %d (expected 1)\n\nCheck fixture orientation.",
            fixtureIDBits[9], fixtureIDBits[10]),
            "Fixture ID Error", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    -- Calculate fixture ID from first 8 bits
    local fixtureID = 0
    for i = 1, 8 do
        fixtureID = fixtureID + fixtureIDBits[i] * (2 ^ (i - 1))
    end

    mc.mcCntlSetLastError(inst, string.format("Fixture ID: %d", fixtureID))

    -- ========== RIGHT BORE PROBING ==========

    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))
    if not ProbeScripts.ProtectedMove(inst, "work", BORE_SEPARATION, 0, nil, 300) then return false end

    -- Drop down to centering height
    if not ProbeScripts.ProtectedMove(inst, "mach", nil, nil, centeringHeightMachine) then return false end
    local rightBoreCenterX, rightBoreCenterY = probeBoreCenter()

    -- Calculate and apply G68 rotation
    local yDifference = rightBoreCenterY
    local xDifference = rightBoreCenterX
    local angleDegrees = 0
    if math.abs(xDifference) > 0.001 then
        local angleRadians = math.atan(yDifference / xDifference)
        angleDegrees = angleRadians * 180 / math.pi
    end

    mc.mcCntlGcodeExecuteWait(inst, string.format("G68 X0 Y0 R%.4f", angleDegrees))
    mc.mcCntlSetLastError(inst, string.format("G68 rotation: %.4f degrees", angleDegrees))

    -- ========== AUTO-DETECT KEY SECTION ==========

    local KEY_26_X = FIRST_KEY_X + 25 * KEY_SPACING
    local FRONT_Y = Y_POSITIONS[2]
    local TAIL_Y = Y_POSITIONS[4]
    local SHOULDER_WIDTH_THRESHOLD = 0.1

    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))
    if not ProbeScripts.ProtectedMove(inst, "work", KEY_26_X, 0, nil, 300) then return false end

    -- Probe key surface
    local keyZ = ProbeScripts.Probe(inst, 5, false, false, nil, SINGLE_TAP_FEEDRATE, true, 0.5)
    keyZ = keyZ - calibrationOffsets["-Z"]

    -- Move to left of key and front Y position
    local probeStartX = KEY_26_X - (KEY_SPACING / 2)
    if not ProbeScripts.ProtectedMove(inst, "work", probeStartX, FRONT_Y, nil, 200) then return false end

    -- Drop to probe height
    local detectProbeZ = keyZ - PROBE_DROP_DEPTH
    if not ProbeScripts.ProtectedMove(inst, "work", nil, nil, detectProbeZ) then return false end

    -- Probe +X to find left edge at front
    local frontEdgeX = ProbeScripts.Probe(inst, 1, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    frontEdgeX = frontEdgeX - calibrationOffsets["+X"]

    -- Move to tail Y position
    if not ProbeScripts.ProtectedMove(inst, "work", nil, TAIL_Y, nil) then return false end

    -- Probe +X to find left edge at tail
    local tailEdgeX = ProbeScripts.Probe(inst, 1, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    tailEdgeX = tailEdgeX - calibrationOffsets["+X"]

    -- Calculate shoulder width
    local shoulderWidth = tailEdgeX - frontEdgeX

    if shoulderWidth > SHOULDER_WIDTH_THRESHOLD then
        TEST_KEYS = LOWER_KEYS
        keyHalfName = "Lower"
    else
        TEST_KEYS = UPPER_KEYS
        keyHalfName = "Upper"
    end

    mc.mcCntlSetLastError(inst, string.format("Auto-detect: %s keys (shoulder width: %.4f)", keyHalfName, shoulderWidth))

    -- ========== CREATE OUTPUT FILES ==========

    pianoName = string.format("%s_%s_%s", params.make, params.serial, keyHalfName)
    pianoFolder = string.format("C:\\Mach4Hobby\\Profiles\\BLP\\Logs\\%s", pianoName)
    -- Delete existing folder if it exists, then create fresh
    os.execute('rmdir /s /q "' .. pianoFolder .. '" 2>nul')
    os.execute('mkdir "' .. pianoFolder .. '"')

    csvPath = string.format("%s\\%s.csv", pianoFolder, pianoName)
    local reportPath = string.format("%s\\%s_Report.txt", pianoFolder, pianoName)
    reportFile = io.open(reportPath, "w")

    writeReport(string.format("===== ProbeKeys %s - %s S/N %s =====", keyHalfName, params.make, params.serial))
    writeReport(string.format("Fixture ID: %d", fixtureID))
    writeReport(string.format("Bore alignment angle: %.4f degrees", angleDegrees))
    writeReport(string.format("Probe Drop Depth: %.4f", PROBE_DROP_DEPTH))
    writeReport(string.format("Linearity Threshold: %.4f", LINEARITY_THRESHOLD))
    writeReport(string.format("Single Tap Feedrate: %.1f IPM", SINGLE_TAP_FEEDRATE))
    writeReport(string.format("CSV output file: %s", csvPath))

    -- Report calibration offsets
    writeReport("Single-tap calibration offsets:")
    for direction, offset in pairs(calibrationOffsets) do
        writeReport(string.format("  %s: %.6f", direction, offset))
    end

    -- ========== SAMPLE Z HEIGHT PROBING ==========

    mc.mcCntlSetLastError(inst, "Probing sample key heights...")
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))

    local zProbeData = {}
    local sampleZHeights = {}

    -- Move to first key
    if not ProbeScripts.ProtectedMove(inst, "work", FIRST_KEY_X, 0, nil, 300) then
        reportFile:close()
        return false
    end

    -- Probe sample keys (1, 7, 13, 19, 25)
    local sampleCount = 0
    for keyIndex = 1, NUM_KEYS, SAMPLE_KEY_INTERVAL do
        local keyX = FIRST_KEY_X + (keyIndex - 1) * KEY_SPACING

        if keyIndex > 1 then
            if not ProbeScripts.ProtectedMove(inst, "work", keyX, 0, nil, 300) then
                reportFile:close()
                return false
            end
        end

        local zHeight = ProbeScripts.Probe(inst, 5, false, false, nil, SINGLE_TAP_FEEDRATE, true, 0.5)
        zHeight = zHeight - calibrationOffsets["-Z"]

        table.insert(sampleZHeights, zHeight)
        sampleCount = sampleCount + 1

        -- Find which TEST_KEY entry corresponds to this keyIndex
        local keyInfo = TEST_KEYS[keyIndex]
        local pianoKey = keyInfo[1]
        local enumKey = keyInfo[2]

        table.insert(zProbeData, {
            enumKey = enumKey,
            pianoKey = pianoKey,
            direction = 5,
            x = keyX,
            y = 0,
            z = zHeight,
            timestamp = os.date("%Y-%m-%d %H:%M:%S")
        })

        writeReport(string.format("Sample key %d (piano key %d): Z=%.4f", keyIndex, pianoKey, zHeight))
    end

    -- Write Z probe data to CSV
    local csvFile = io.open(csvPath, "w")
    csvFile:write("EnumKey#,PianoKey#,Direction,X,Y,Z,Timestamp\n")
    writeBatchToCSV(csvFile, zProbeData)
    csvFile:close()

    -- Calculate average Z height
    local avgZ = 0
    for _, z in ipairs(sampleZHeights) do
        avgZ = avgZ + z
    end
    avgZ = avgZ / #sampleZHeights

    -- Set uniform traverse and probe heights
    traverseHeight = avgZ + 0.5
    probeZ = avgZ - PROBE_DROP_DEPTH

    writeReport(string.format("Average Z height: %.4f", avgZ))
    writeReport(string.format("Traverse height: %.4f", traverseHeight))
    writeReport(string.format("Probe Z depth: %.4f", probeZ))

    -- ========== Y FRONT EDGE PROBING (sample keys only) ==========

    mc.mcCntlSetLastError(inst, "Probing Y front edges...")

    local yFrontData = {}
    local FRONT_PROBE_Y = -1.75  -- Y position in front of keys for +Y probing

    -- Move up to traverse height first
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))

    -- Move to first sample key XY position
    if not ProbeScripts.ProtectedMove(inst, "work", FIRST_KEY_X, FRONT_PROBE_Y, nil, 300) then
        reportFile:close()
        return false
    end

    -- Drop to probe depth (stay here for all sample keys)
    if not ProbeScripts.ProtectedMove(inst, "work", nil, nil, probeZ) then
        reportFile:close()
        return false
    end

    -- Probe same sample keys as Z height probing (1, 7, 13, 19, 25)
    for keyIndex = 1, NUM_KEYS, SAMPLE_KEY_INTERVAL do
        local keyX = FIRST_KEY_X + (keyIndex - 1) * KEY_SPACING

        -- Move directly in X to next key (no Z retract needed)
        if keyIndex > 1 then
            if not ProbeScripts.ProtectedMove(inst, "work", keyX, nil, nil, 300) then
                reportFile:close()
                return false
            end
        end

        -- Probe +Y direction with single tap calibration
        local yFront = ProbeScripts.Probe(inst, 3, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        yFront = yFront - calibrationOffsets["+Y"]

        -- Find which TEST_KEY entry corresponds to this keyIndex
        local keyInfo = TEST_KEYS[keyIndex]
        local pianoKey = keyInfo[1]
        local enumKey = keyInfo[2]

        table.insert(yFrontData, {
            enumKey = enumKey,
            pianoKey = pianoKey,
            direction = 3,
            x = keyX,
            y = yFront,
            z = probeZ,
            timestamp = os.date("%Y-%m-%d %H:%M:%S")
        })

        writeReport(string.format("Sample key %d Y front: %.4f", keyIndex, yFront))
    end

    -- Retract after all +Y probing complete
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))

    -- Append Y front data to CSV
    local csvFile = io.open(csvPath, "a")
    writeBatchToCSV(csvFile, yFrontData)
    csvFile:close()
    writeReport(string.format("Probed %d Y front edges", #yFrontData))

    -- ========== X EDGE PROBING ==========

    mc.mcCntlSetLastError(inst, "Probing X edges...")
    local accessibleShoulders = {}

    for keyIdx = 1, #TEST_KEYS do
        local pianoKey = TEST_KEYS[keyIdx][1]

        local leftX = FIRST_KEY_X - (KEY_SPACING / 2) + (keyIdx - 1) * KEY_SPACING
        local rightX = leftX + KEY_SPACING

        -- Probe left side (+X direction)
        local leftData, leftShoulder = probeKeySide(keyIdx, 1, leftX)
        if leftData == false then
            reportFile:close()
            return false
        end
        if leftShoulder then
            table.insert(accessibleShoulders, leftShoulder)
        end

        -- Probe right side (-X direction)
        local rightData, rightShoulder = probeKeySide(keyIdx, 2, rightX)
        if rightData == false then
            reportFile:close()
            return false
        end
        if rightShoulder then
            table.insert(accessibleShoulders, rightShoulder)
        end

        mc.mcCntlSetLastError(inst, string.format("Probing key %d of %d...", keyIdx, #TEST_KEYS))
    end

    -- ========== SHOULDER -Y PROBING ==========

    if #accessibleShoulders > 0 then
        mc.mcCntlSetLastError(inst, "Probing shoulders...")
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))

        local shoulderData = {}

        for _, shoulder in ipairs(accessibleShoulders) do
            -- Move to shoulder probe position (uniform probeZ for all)
            if not ProbeScripts.ProtectedMove(inst, "work", shoulder.xPosition, shoulder.yPosition, traverseHeight, 300) then
                reportFile:close()
                return false
            end
            if not ProbeScripts.ProtectedMove(inst, "work", nil, nil, probeZ) then
                reportFile:close()
                return false
            end

            -- Single tap -Y with calibration
            local yBack = ProbeScripts.Probe(inst, 4, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
            yBack = yBack - calibrationOffsets["-Y"]

            table.insert(shoulderData, {
                enumKey = shoulder.enumKey,
                pianoKey = shoulder.pianoKey,
                direction = 4,
                x = shoulder.xPosition,
                y = yBack,
                z = probeZ,
                timestamp = os.date("%Y-%m-%d %H:%M:%S")
            })

            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))
        end

        if #shoulderData > 0 then
            local csvFile = io.open(csvPath, "a")
            writeBatchToCSV(csvFile, shoulderData)
            csvFile:close()
        end

        writeReport(string.format("Probed %d accessible shoulders", #shoulderData))
    else
        writeReport("No accessible shoulders found for -Y probing")
    end

    -- ========== RETURN HOME ==========

    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))
    mc.mcCntlGcodeExecuteWait(inst, "G90 G0 X0 Y0")

    -- Clear G68 rotation
    mc.mcCntlGcodeExecuteWait(inst, "G69")
    writeReport("G68 rotation cleared")

    mc.mcCntlSetLastError(inst, string.format("ProbeKeys %s half completed successfully", keyHalfName))
    writeReport(string.format("===== ProbeKeys %s Half Completed Successfully =====", keyHalfName))
    reportFile:close()

    -- ========== TRIGGER FUSION ADD-IN ==========

    local triggerPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Logs\\PROBE_COMPLETE_" .. pianoName .. ".txt"
    local csvPathNetwork = csvPath:gsub("C:\\Mach4Hobby", "\\\\BLPCNC\\Mach4Hobby")
    local triggerData = string.format('{"csv_path": "%s", "piano_id": "%s", "avg_z": %.6f}',
        csvPathNetwork:gsub("\\", "\\\\"),
        pianoName,
        avgZ)

    local triggerFile = io.open(triggerPath, "w")
    if triggerFile then
        triggerFile:write(triggerData)
        triggerFile:close()
        mc.mcCntlSetLastError(inst, string.format("ProbeKeys complete - trigger sent to Fusion"))
    else
        wx.wxMessageBox("Warning: Could not create trigger file for Fusion 360.\n\nManually trigger the add-in or re-run ProbeKeys.",
            "Trigger Warning", wx.wxOK + wx.wxICON_WARNING)
    end

    return true
end







function ProbeScripts.InitialKeytopTrim(inst)
    -- Check probe deployment first
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Check that user is on GCode tab (not MDI)
    local tabCheckOk, tabResult = pcall(function()
        local tab1 = scr.GetProperty("nbGCodeMDI1", "Current Tab")
        local tab2 = scr.GetProperty("nbGCodeMDI2", "Current Tab")
        return (tab1 == "0" or tab1 == 0) or (tab2 == "0" or tab2 == 0)
    end)

    if tabCheckOk and not tabResult then
        wx.wxMessageBox("Please switch to the GCode tab before running Initial Trim.\n\nThe MDI tab is currently active.",
            "Wrong Tab", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check front vacuum is on (OUTPUT6)
    local vacFrontHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6)
    local vacFrontState = mc.mcSignalGetState(vacFrontHandle)
    if vacFrontState ~= 1 then
        wx.wxMessageBox("Front vacuum must be ON before running Initial Trim.\n\nPlease turn on the front vacuum and try again.",
            "Vacuum Required", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check dust collection automation is enabled (OUTPUT50 = dustAuto, OUTPUT52 = bootAuto)
    local dustAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT50)
    local dustAutoState = mc.mcSignalGetState(dustAutoHandle)
    local bootAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT52)
    local bootAutoState = mc.mcSignalGetState(bootAutoHandle)

    if dustAutoState ~= 1 or bootAutoState ~= 1 then
        local missing = {}
        if dustAutoState ~= 1 then table.insert(missing, "Dust Collect Auto") end
        if bootAutoState ~= 1 then table.insert(missing, "Dust Boot Auto") end

        local result = wx.wxMessageBox(
            "The following automation settings are not enabled:\n\nâ¢ " .. table.concat(missing, "\nâ¢ ") ..
            "\n\nIt is recommended to enable these before running the trim operation.\n\nContinue anyway?",
            "Automation Warning", wx.wxYES_NO + wx.wxICON_WARNING)

        if result ~= wx.wxYES then
            return
        end
    end

    mc.mcCntlGcodeExecuteWait(inst, "G55")

    -- Show dialog to get trim parameters
    local fields = {
        {type = "instructions",
         text = "Initial keytop trim operation.\nEnter the plastic thickness to remove."},
        {type = "number", key = "removalDepth", label = "Removal Depth (inches)",
         default = 0.08, persist = false, min = 0.001, max = 0.25,
         validateMsg = "Must be between 0.001-0.5"},
        {type = "separator"},
        {type = "radio", key = "trimOperation", label = "Trim Operation",
         options = {"Top and Front", "Top Only"},
         columns = 2, default = 0}
    }

    local params = ProbeScripts.ShowDialog(inst, "Initial Trim", fields, "InitialTrim", {width = 300})
    if not params then return end

    -- Cancel any existing G68 rotation
    mc.mcCntlGcodeExecuteWait(inst, "G69")

    -- Config
    local SINGLE_TAP_FEEDRATE = 40  -- IPM for single tap probes
    local BORE_SEPARATION = 46.0  -- inches between calibration bores
    local KEY_SPACING = 1.7  -- inches between white keys
    local FIRST_KEY_X = 1.75  -- X position of first key center
    local SAMPLE_KEY_INTERVAL = 6  -- Probe every 6th key (keys 1, 7, 13, 19, 25)
    local NUM_KEYS = 26  -- Total white keys per section
    local safeTraverseZ = 2.0  -- Safe Z height for traversing (work coords, relative to surface)

    -- Storage
    local centeringHeightMachine  -- bore centering height in machine coords
    local calibrationOffsets = {}  -- single-tap calibration offsets

    -- ========== LEFT BORE POSITIONING ==========

    -- Get bore location from settings (pv 540 and 541)
    local boreMachineX = mc.mcCntlGetPoundVar(inst, 540)
    local boreMachineY = mc.mcCntlGetPoundVar(inst, 541)

    if boreMachineX == 0 and boreMachineY == 0 then
        wx.wxMessageBox("Bore location not configured.\n\nPlease set the bore machine coordinates in System Settings > Keytop Replacement.",
            "Configuration Required", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    -- Get T90 tool table offsets
    local toolXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90) or 0
    local toolYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90) or 0

    -- Calculate spindle position needed to put probe tip at bore center
    local spindleTargetX = boreMachineX + toolXOffset
    local spindleTargetY = boreMachineY + toolYOffset

    -- Move to safe Z height first
    mc.mcCntlSetLastError(inst, "Moving to bore location...")
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z-0.05")

    -- Move spindle to calculated position
    if not ProbeScripts.ProtectedMove(inst, "mach", spindleTargetX, spindleTargetY, nil, 300) then
        return false
    end

    -- ========== LEFT BORE CALIBRATION ==========

    -- Probe down to find bore bottom
    local doubleResults = {}
    doubleResults["-Z"] = ProbeScripts.Probe(inst, 5, false, false, nil, nil, false, nil)
    local boreBottomZ = doubleResults["-Z"]

    -- Move up 0.25" and note position for centering
    mc.mcCntlGcodeExecuteWait(inst, "G91 G0 Z0.25")
    centeringHeightMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Double tap all four sides for centering
    doubleResults["+X"] = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    doubleResults["-X"] = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    doubleResults["+Y"] = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    doubleResults["-Y"] = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)

    -- Calculate and move to center
    local leftBoreCenterX = (doubleResults["+X"] + doubleResults["-X"]) / 2
    local leftBoreCenterY = (doubleResults["+Y"] + doubleResults["-Y"]) / 2
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F200", leftBoreCenterX, leftBoreCenterY))

    -- Single tap calibration for -Z (only direction we need for key probing)
    local singleZResult = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    calibrationOffsets["-Z"] = singleZResult - doubleResults["-Z"]

    -- Set XY datum at bore center
    mc.mcAxisSetPos(inst, mc.X_AXIS, 0)
    mc.mcAxisSetPos(inst, mc.Y_AXIS, 0)

    -- Move out of bore and probe surface to set temporary Z datum
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", boreBottomZ + 1))
    if not ProbeScripts.ProtectedMove(inst, "inc", 0.6, nil, nil, 200) then
        return false
    end
    local surfaceZ = ProbeScripts.Probe(inst, 5, true, true, nil, nil, false, nil)

    -- ========== RIGHT BORE PROBING (skip fixture ID) ==========

    -- Move to safe traverse height then to right bore
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))
    if not ProbeScripts.ProtectedMove(inst, "work", BORE_SEPARATION, 0, nil, 300) then
        return false
    end

    -- Drop down to centering height in bore
    if not ProbeScripts.ProtectedMove(inst, "mach", nil, nil, centeringHeightMachine) then
        return false
    end

    -- Probe bore center
    local xEdge1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    local xEdge2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    local rightBoreCenterX = (xEdge1 + xEdge2) / 2

    local yEdge1 = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    local yEdge2 = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
    local rightBoreCenterY = (yEdge1 + yEdge2) / 2

    -- Calculate and apply G68 rotation
    local yDifference = rightBoreCenterY
    local xDifference = rightBoreCenterX
    local angleDegrees = 0
    if math.abs(xDifference) > 0.001 then
        local angleRadians = math.atan(yDifference / xDifference)
        angleDegrees = angleRadians * 180 / math.pi
    end

    mc.mcCntlGcodeExecuteWait(inst, string.format("G68 X0 Y0 R%.4f", angleDegrees))
    mc.mcCntlSetLastError(inst, string.format("G68 rotation: %.4f degrees", angleDegrees))

    -- ========== SAMPLE KEY Z HEIGHT PROBING ==========

    mc.mcCntlSetLastError(inst, "Probing sample key heights...")

    -- Move to safe height
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))

    local sampleZHeights = {}
    local sampleCount = 0

    -- Probe every 6th key: keys 1, 7, 13, 19, 25 (indices 1, 7, 13, 19, 25)
    for keyIndex = 1, NUM_KEYS, SAMPLE_KEY_INTERVAL do
        local keyX = FIRST_KEY_X + (keyIndex - 1) * KEY_SPACING

        if not ProbeScripts.ProtectedMove(inst, "work", keyX, 0, nil, 300) then
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end

        -- Single tap probe with calibration
        local zHeight = ProbeScripts.Probe(inst, 5, false, false, nil, SINGLE_TAP_FEEDRATE, true, 0.5)
        zHeight = zHeight - calibrationOffsets["-Z"]

        table.insert(sampleZHeights, zHeight)
        sampleCount = sampleCount + 1

        mc.mcCntlSetLastError(inst, string.format("Sample %d: Z=%.4f", sampleCount, zHeight))
    end

    -- Find maximum Z height (highest key)
    local maxZ = sampleZHeights[1]
    for _, z in ipairs(sampleZHeights) do
        if z > maxZ then
            maxZ = z
        end
    end

    -- Calculate machining height (max minus removal depth)
    local machiningHeight = maxZ - params.removalDepth

    mc.mcCntlSetLastError(inst, string.format("Max Z: %.4f, Machining height: %.4f", maxZ, machiningHeight))

    -- Validate machining height is within safe range
    if machiningHeight < 0.1 or machiningHeight > 2.0 then
        wx.wxMessageBox(string.format("Calculated machining height is unsafe: %.4f inches\n\nRemoval depth: %.4f\nMax Z: %.4f\n\nResult must be between 0.1 and 2.0 inches.",
            machiningHeight, params.removalDepth, maxZ),
            "Unsafe Machining Height", wx.wxOK + wx.wxICON_ERROR)
        mc.mcCntlGcodeExecuteWait(inst, "G69")
        return false
    end

    -- ========== SET FINAL Z DATUM ==========

    -- Get current Z position (still at last probed key location)
    local currentZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)

    -- Set Z datum so Z=0 is at machining height
    -- Current position is at currentZ in work coords (surface is Z=0)
    -- We want new Z=0 to be at machiningHeight above the original surface
    -- So new Z at current position = currentZ - machiningHeight
    local newZPosition = currentZ - machiningHeight
    mc.mcAxisSetPos(inst, mc.Z_AXIS, newZPosition)

    mc.mcCntlSetLastError(inst, string.format("Z datum set: machining height = %.4f", machiningHeight))

    -- ========== PREPARE G-CODE EXECUTION ==========

    -- Retract to machine Z0
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z0")

    -- Close any currently loaded G-code file
    mc.mcCntlCloseGCodeFile(inst)

    -- Determine which G-code file(s) to load
    local gcodeDir = "C:\\Mach4Hobby\\Profiles\\BLP\\Scripts\\GCode"
    local topTrimFile = gcodeDir .. "\\Initial Trim Top.tap"
    local frontTrimFile = gcodeDir .. "\\Initial Trim Front.tap"

    local gcodeFilePath
    local trimOps = {"Top and Front", "Top Only"}

    if params.trimOperation == 0 then
        -- Top and Front: need to combine files
        -- Read front trim, strip M30/M2, append top trim
        local frontFile = io.open(frontTrimFile, "r")
        if not frontFile then
            wx.wxMessageBox("Failed to open front trim file:\n" .. frontTrimFile, "Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        local frontContent = frontFile:read("*a")
        frontFile:close()

        local topFile = io.open(topTrimFile, "r")
        if not topFile then
            wx.wxMessageBox("Failed to open top trim file:\n" .. topTrimFile, "Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        local topContent = topFile:read("*a")
        topFile:close()

        -- Strip M30/M2 from front content
        frontContent = frontContent:gsub("[Mm]30[^\n]*\n?", "\n")
        frontContent = frontContent:gsub("[Mm]2[^\n]*\n?", "\n")
        frontContent = frontContent .. "\n(End of front trim, continuing to top trim)\n\n"

        -- Combine and write to temp file
        local tempDir = "C:\\Mach4Hobby\\Profiles\\BLP\\Temp"
        gcodeFilePath = tempDir .. "\\InitialTrimCombined.tap"

        local tempFile = io.open(gcodeFilePath, "w")
        if not tempFile then
            wx.wxMessageBox("Failed to create combined G-code file.", "Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        tempFile:write(frontContent)
        tempFile:write(topContent)
        tempFile:close()

    else
        -- Top Only: use top trim file directly
        gcodeFilePath = topTrimFile
    end

    -- Verify file exists
    local testFile = io.open(gcodeFilePath, "r")
    if not testFile then
        wx.wxMessageBox("G-code file not found:\n" .. gcodeFilePath, "Error", wx.wxOK + wx.wxICON_ERROR)
        return false
    end
    testFile:close()

    -- ========== DEFERRED FILE LOAD ==========
    -- Can't load G-code from within a macro (machine state is MRUN, error -18).
    -- Write the file path to a marker file. PLC checks for this file when idle,
    -- loads the G-code, and deletes the marker.

    local markerPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Temp\\DeferredGCode.txt"
    local markerFile = io.open(markerPath, "w")
    if markerFile then
        markerFile:write(gcodeFilePath)
        markerFile:close()
    else
        wx.wxMessageBox("Failed to queue G-code file for execution.", "Error", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    mc.mcCntlSetLastError(inst, string.format("Trim ready - %s (removal: %.3f, height: %.3f)",
        trimOps[params.trimOperation + 1], params.removalDepth, machiningHeight))
    return true
end








function ProbeScripts.FinalKeytopShaping(inst)
    -- Check probe deployment first
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Check that user is on GCode tab (not MDI)
    local tabCheckOk, tabResult = pcall(function()
        local tab1 = scr.GetProperty("nbGCodeMDI1", "Current Tab")
        local tab2 = scr.GetProperty("nbGCodeMDI2", "Current Tab")
        return (tab1 == "0" or tab1 == 0) or (tab2 == "0" or tab2 == 0)
    end)

    if tabCheckOk and not tabResult then
        wx.wxMessageBox("Please switch to the GCode tab before running Final Keytop Shaping.\n\nThe MDI tab is currently active.",
            "Wrong Tab", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check front vacuum is on (OUTPUT6)
    local vacFrontHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6)
    local vacFrontState = mc.mcSignalGetState(vacFrontHandle)
    if vacFrontState ~= 1 then
        wx.wxMessageBox("Front vacuum must be ON before running Final Keytop Shaping.\n\nPlease turn on the front vacuum and try again.",
            "Vacuum Required", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check dust collection automation is enabled (OUTPUT50 = dustAuto, OUTPUT52 = bootAuto)
    local dustAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT50)
    local dustAutoState = mc.mcSignalGetState(dustAutoHandle)
    local bootAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT52)
    local bootAutoState = mc.mcSignalGetState(bootAutoHandle)

    if dustAutoState ~= 1 or bootAutoState ~= 1 then
        local missing = {}
        if dustAutoState ~= 1 then table.insert(missing, "Dust Collect Auto") end
        if bootAutoState ~= 1 then table.insert(missing, "Dust Boot Auto") end

        local result = wx.wxMessageBox(
            "The following automation settings are not enabled:\n\nâ¢ " .. table.concat(missing, "\nâ¢ ") ..
            "\n\nIt is recommended to enable these before running Final Shaping.\n\nContinue anyway?",
            "Automation Warning", wx.wxYES_NO + wx.wxICON_WARNING)

        if result ~= wx.wxYES then
            return
        end
    end

    mc.mcCntlGcodeExecuteWait(inst, "G55")

    -- Scan for available shaping files to populate dropdown
    local logsDir = "C:\\Mach4Hobby\\Profiles\\BLP\\Logs"
    local availableFiles = {}
    local fileOptions = {"Auto-detect from fixture"}

    -- Search through piano folders for shaping files
    local handle = io.popen('dir "' .. logsDir .. '" /b /ad /o-d 2>nul')
    local folders = handle:read("*a")
    handle:close()

    for folderName in folders:gmatch("[^\r\n]+") do
        local folderPath = logsDir .. "\\" .. folderName
        -- Look for shaping .tap files (named {piano_id}.tap where piano_id ends in _Upper or _Lower)
        local fileHandle = io.popen('dir "' .. folderPath .. '\\*.tap" /b /o-d 2>nul')
        local files = fileHandle:read("*a")
        fileHandle:close()

        for fileName in files:gmatch("[^\r\n]+") do
            -- Only include files that end in _Upper.tap or _Lower.tap (shaping files)
            if fileName:match("_Upper%.tap$") or fileName:match("_Lower%.tap$") then
                local displayName = fileName:gsub("%.tap$", "")
                table.insert(fileOptions, displayName)
                table.insert(availableFiles, {
                    folder = folderName,
                    file = fileName,
                    path = folderPath .. "\\" .. fileName
                })
            end
        end
    end

    -- Show dialog with dropdown of available files
    local fields = {
        {type = "instructions",
         text = "Select shaping G-code file to run.\nAuto-detect will probe the fixture ID and find the matching file."},
        {type = "choice", key = "fileSelection", label = "Shaping File",
         options = fileOptions,
         default = 0,
         tooltip = "Select Auto-detect or choose a specific file"}
    }

    local params = ProbeScripts.ShowDialog(inst, "Final Keytop Shaping", fields, "FinalKeytopShaping", {width = 450})
    if not params then return end

    -- Cancel any existing G68 rotation
    mc.mcCntlGcodeExecuteWait(inst, "G69")

    -- Config
    local SINGLE_TAP_FEEDRATE = 40  -- IPM for single tap probes
    local BORE_SEPARATION = 46.0  -- inches between calibration bores
    local ID_HOLE_DEPTH_THRESHOLD = -0.05  -- Threshold for fixture ID hole detection
    local safeTraverseZ = 2.0  -- Safe Z height for traversing

    -- Storage
    local centeringHeightMachine  -- bore centering height in machine coords
    local calibrationOffsets = {}  -- single-tap calibration offsets
    local fixtureID = nil  -- detected fixture ID
    local reportFile = nil
    local reportMessages = {}

    -- Helper function to write to report (buffers until file is opened)
    local function writeReport(message)
        local timestamp = os.date("%Y-%m-%d %H:%M:%S")
        local formattedMsg = string.format("[%s] %s\n", timestamp, message)
        table.insert(reportMessages, formattedMsg)
        if reportFile then
            reportFile:write(formattedMsg)
            reportFile:flush()
        end
    end

    writeReport("===== Final Keytop Shaping Started =====")

    -- Helper function for bore center probing
    local function probeBoreCenter(boreName)
        local xEdge1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
        local xEdge2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
        local centerX = (xEdge1 + xEdge2) / 2

        local yEdge1 = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
        local yEdge2 = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
        local centerY = (yEdge1 + yEdge2) / 2

        return centerX, centerY
    end

    -- ========== LEFT BORE POSITIONING ==========

    -- Get bore location from settings (pv 540 and 541)
    local boreMachineX = mc.mcCntlGetPoundVar(inst, 540)
    local boreMachineY = mc.mcCntlGetPoundVar(inst, 541)

    if boreMachineX == 0 and boreMachineY == 0 then
        wx.wxMessageBox("Bore location not configured.\n\nPlease set the bore machine coordinates in System Settings > Keytop Replacement.",
            "Configuration Required", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    -- Get T90 tool table offsets
    local toolXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90) or 0
    local toolYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90) or 0

    -- Calculate spindle position needed to put probe tip at bore center
    local spindleTargetX = boreMachineX + toolXOffset
    local spindleTargetY = boreMachineY + toolYOffset

    -- Move to safe Z height first
    mc.mcCntlSetLastError(inst, "Moving to bore location...")
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z0")

    -- Move spindle to calculated position
    if not ProbeScripts.ProtectedMove(inst, "mach", spindleTargetX, spindleTargetY, nil, 300) then
        return false
    end

    -- ========== LEFT BORE CALIBRATION ==========

    -- Probe down to find bore bottom
    local doubleResults = {}
    doubleResults["-Z"] = ProbeScripts.Probe(inst, 5, false, false, nil, nil, false, nil)
    local boreBottomZ = doubleResults["-Z"]

    -- Move up 0.25" and note position
    mc.mcCntlGcodeExecuteWait(inst, "G91 G0 Z0.25")
    centeringHeightMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Double tap all four sides for centering
    doubleResults["+X"] = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    doubleResults["-X"] = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    doubleResults["+Y"] = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    doubleResults["-Y"] = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)

    -- Calculate and move to center
    local leftBoreCenterX = (doubleResults["+X"] + doubleResults["-X"]) / 2
    local leftBoreCenterY = (doubleResults["+Y"] + doubleResults["-Y"]) / 2
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F200", leftBoreCenterX, leftBoreCenterY))

    -- Single tap calibration for -Z only
    local singleZResult = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    calibrationOffsets["-Z"] = singleZResult - doubleResults["-Z"]

    writeReport("Single-tap calibration offset:")
    writeReport(string.format("  -Z: %.6f", calibrationOffsets["-Z"]))

    -- Log left bore center and set datum
    writeReport(string.format("Left bore center: X%.4f Y%.4f", leftBoreCenterX, leftBoreCenterY))
    mc.mcAxisSetPos(inst, mc.X_AXIS, 0)
    mc.mcAxisSetPos(inst, mc.Y_AXIS, 0)

    -- Move out of bore and probe surface
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", boreBottomZ + 1))
    if not ProbeScripts.ProtectedMove(inst, "inc", 0.6, nil, nil, 200) then
        return false
    end
    local surfaceZ = ProbeScripts.Probe(inst, 5, true, true, nil, nil, false, nil)
    writeReport(string.format("Surface Z datum set at: %.4f", surfaceZ))

    -- Move back to bore center (0,0)
    if not ProbeScripts.ProtectedMove(inst, "work", 0, 0, nil, 200) then
        return false
    end

    -- ========== FIXTURE ID PROBING ==========

    local fixtureIDBits = {}

    -- Probe each of the 10 ID holes
    for i = 1, 10 do
        local yPos = 1.0 + (i - 1) * 0.5
        if not ProbeScripts.ProtectedMove(inst, "work", 0, yPos, nil, 200) then
            return false
        end
        local holeZ = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        holeZ = holeZ - calibrationOffsets["-Z"]

        local bitValue = (holeZ < ID_HOLE_DEPTH_THRESHOLD) and 1 or 0
        fixtureIDBits[i] = bitValue

        writeReport(string.format("ID hole %d: Z=%.4f (calibrated), bit=%d", i, holeZ, bitValue))
    end

    -- Verify check bits (9th should be 0, 10th should be 1)
    if fixtureIDBits[9] ~= 0 or fixtureIDBits[10] ~= 1 then
        writeReport(string.format("WARNING: Check bits invalid! Bit 9=%d (expected 0), Bit 10=%d (expected 1)",
            fixtureIDBits[9], fixtureIDBits[10]))
    end

    -- Calculate fixture ID from first 8 bits
    fixtureID = 0
    for i = 1, 8 do
        fixtureID = fixtureID + fixtureIDBits[i] * (2 ^ (i - 1))
    end

    writeReport(string.format("Fixture ID detected: %d (binary: %s%s%s%s%s%s%s%s)",
        fixtureID,
        tostring(fixtureIDBits[8]), tostring(fixtureIDBits[7]),
        tostring(fixtureIDBits[6]), tostring(fixtureIDBits[5]),
        tostring(fixtureIDBits[4]), tostring(fixtureIDBits[3]),
        tostring(fixtureIDBits[2]), tostring(fixtureIDBits[1])))

    -- ========== RIGHT BORE PROBING ==========

    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))
    if not ProbeScripts.ProtectedMove(inst, "work", BORE_SEPARATION, 0, nil, 300) then
        return false
    end

    if not ProbeScripts.ProtectedMove(inst, "mach", nil, nil, centeringHeightMachine) then
        return false
    end
    local rightBoreCenterX, rightBoreCenterY = probeBoreCenter("right")
    writeReport(string.format("Right bore center (in datum coords): X%.4f Y%.4f", rightBoreCenterX, rightBoreCenterY))

    -- Calculate and apply G68 rotation
    local yDifference = rightBoreCenterY
    local xDifference = rightBoreCenterX
    local angleDegrees = 0
    if math.abs(xDifference) > 0.001 then
        local angleRadians = math.atan(yDifference / xDifference)
        angleDegrees = angleRadians * 180 / math.pi
    end

    writeReport(string.format("Right bore position relative to left: X%.4f Y%.4f", xDifference, yDifference))
    writeReport(string.format("Bore alignment angle: %.4f degrees", angleDegrees))

    mc.mcCntlGcodeExecuteWait(inst, string.format("G68 X0 Y0 R%.4f", angleDegrees))
    writeReport(string.format("G68 rotation applied: %.4f degrees centered at 0,0", angleDegrees))

    -- ========== FIND SHAPING FILE ==========

    local shapingFilePath = nil
    local pianoMake = nil
    local pianoSerial = nil
    local pianoFolder = nil
    local keySection = nil  -- "Upper" or "Lower"

    if params.fileSelection == 0 then
        -- Auto-detect: search log files for matching fixture ID
        mc.mcCntlSetLastError(inst, "Searching for fixture ID in logs...")

        local function findFixtureInLogs(searchFixtureID)
            local foundMake = nil
            local foundSerial = nil
            local foundFolder = nil
            local foundSection = nil

            for folderName in folders:gmatch("[^\r\n]+") do
                local reportPath = logsDir .. "\\" .. folderName .. "\\" .. folderName .. "_Report.txt"
                local file = io.open(reportPath, "r")
                if file then
                    local content = file:read("*a")
                    file:close()

                    local foundID = content:match("Fixture ID: (%d+)")
                    if foundID and tonumber(foundID) == searchFixtureID then
                        -- Folder name is now {Make}_{Serial}_{Section}
                        -- Extract section from folder name (last part)
                        if folderName:match("_Upper$") then
                            foundSection = "Upper"
                            foundMake, foundSerial = folderName:match("(.+)_(.+)_Upper$")
                        elseif folderName:match("_Lower$") then
                            foundSection = "Lower"
                            foundMake, foundSerial = folderName:match("(.+)_(.+)_Lower$")
                        end
                        foundFolder = folderName

                        writeReport(string.format("Found matching fixture ID %d in folder: %s", searchFixtureID, folderName))
                        writeReport(string.format("Piano: %s S/N %s, Section: %s", foundMake or "Unknown", foundSerial or "Unknown", foundSection or "Unknown"))
                        break
                    end
                end
            end

            return foundMake, foundSerial, foundFolder, foundSection
        end

        pianoMake, pianoSerial, pianoFolder, keySection = findFixtureInLogs(fixtureID)

        if not pianoFolder then
            wx.wxMessageBox(string.format("Could not find previous probing data for fixture ID %d.\n\nPlease run ProbeKeys first.", fixtureID),
                "Log Data Not Found", wx.wxOK + wx.wxICON_ERROR)
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end

        if not keySection then
            wx.wxMessageBox(string.format("Could not determine Upper/Lower section from logs for fixture ID %d.", fixtureID),
                "Section Unknown", wx.wxOK + wx.wxICON_ERROR)
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end

        -- Look for shaping file matching the section (named {piano_id}.tap ending in _Upper.tap or _Lower.tap)
        local pianoFolderPath = logsDir .. "\\" .. pianoFolder

        local fileHandle = io.popen('dir "' .. pianoFolderPath .. '\\*_' .. keySection .. '.tap" /b /o-d 2>nul')
        local files = fileHandle:read("*a")
        fileHandle:close()

        local firstFile = files:match("[^\r\n]+")
        if firstFile then
            shapingFilePath = pianoFolderPath .. "\\" .. firstFile
            writeReport(string.format("Found shaping file: %s", shapingFilePath))
        else
            wx.wxMessageBox(string.format("No %s shaping file found for %s.\n\nPlease ensure Fusion360 has exported the shaping G-code.", keySection, pianoFolder),
                "Shaping File Not Found", wx.wxOK + wx.wxICON_ERROR)
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end

    else
        -- User selected a specific file
        local selectedIdx = params.fileSelection  -- 0 = auto-detect, 1+ = file index
        local fileInfo = availableFiles[selectedIdx]
        if fileInfo then
            shapingFilePath = fileInfo.path
            pianoFolder = fileInfo.folder

            -- Determine section from filename
            if fileInfo.file:lower():match("upper") then
                keySection = "Upper"
            elseif fileInfo.file:lower():match("lower") then
                keySection = "Lower"
            end

            writeReport(string.format("User selected file: %s", shapingFilePath))
        else
            wx.wxMessageBox("Invalid file selection.", "Error", wx.wxOK + wx.wxICON_ERROR)
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end
    end

    -- Verify file exists
    local testFile = io.open(shapingFilePath, "r")
    if not testFile then
        wx.wxMessageBox(string.format("Shaping file not found:\n%s", shapingFilePath),
            "File Not Found", wx.wxOK + wx.wxICON_ERROR)
        mc.mcCntlGcodeExecuteWait(inst, "G69")
        return false
    end
    testFile:close()

    -- ========== OPEN REPORT FILE ==========

    local pianoFolderPath = logsDir .. "\\" .. pianoFolder
    local pianoName = pianoFolder
    local reportPath = pianoFolderPath .. "\\" .. pianoName .. "_Report.txt"
    reportFile = io.open(reportPath, "a")
    if reportFile then
        for _, msg in ipairs(reportMessages) do
            reportFile:write(msg)
        end
        reportFile:flush()
    end

    -- ========== CLEANUP AND QUEUE FILE ==========

    -- Retract to machine Z0 (G68 rotation remains active for G-code execution)
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z0")

    -- Close any currently loaded G-code file
    mc.mcCntlCloseGCodeFile(inst)

    -- ========== DEFERRED FILE LOAD ==========

    local markerPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Temp\\DeferredGCode.txt"
    local markerFile = io.open(markerPath, "w")
    if markerFile then
        markerFile:write(shapingFilePath)
        markerFile:close()
    else
        wx.wxMessageBox("Failed to queue G-code file for execution.", "Error", wx.wxOK + wx.wxICON_ERROR)
        if reportFile then reportFile:close() end
        return false
    end

    -- Update the piano's log file (after marker created so we can log success)
    writeReport(string.format("===== Final Shaping Started ====="))
    writeReport(string.format("Fixture ID: %d", fixtureID))
    writeReport(string.format("Section: %s", keySection or "Unknown"))
    writeReport(string.format("G-code file: %s", shapingFilePath))
    writeReport("Deferred load marker created: " .. markerPath)

    if reportFile then
        reportFile:close()
    end

    mc.mcCntlSetLastError(inst, string.format("Shaping file ready - %s %s", pianoFolder, keySection or ""))
    return true
end







-- Main surface grid probing function
-- Probes a list of XY points (work coords) and records Z in machine coords
-- Uses single-tap calibration at first point, then fast single-tap probes at 40 IPM
-- ABORTS on any failure (movement collision or no probe contact)
-- params:
--   points          - array of {x=, y=} positions in work coordinates
--   outputFile      - optional path to save .dat file for mcSurfaceMap (wizard format)
--   gridParams      - {startX, endX, xCount, startY, endY, yCount} for wizard format
--   progressCallback - optional function(current, total, x, y, z) for UI updates
--
-- Returns: {
--   points = {{x=, y=, z=, success=}, ...},  -- machine coords (only successful points)
--   stats = {total=, success=, zMin=, zMax=},
--   aborted = bool,      -- true if probing was aborted due to failure
--   abortReason = string -- reason for abort (nil if not aborted)
-- }
function ProbeScripts.ProbeSurfaceGrid(inst, params)
    local points = params.points
    local outputFile = params.outputFile
    local progressCallback = params.progressCallback
    -- Grid parameters for wizard-format output
    local gridParams = params.gridParams  -- {startX, startY, endX, endY, xCount, yCount}

    local SINGLE_TAP_FEEDRATE = 40  -- IPM for single tap probes
    local zSoftLimitMax = mc.mcAxisGetSoftlimitMax(inst, mc.Z_AXIS)

    if not points or #points == 0 then
        error("ProbeSurfaceGrid: No points provided")
    end

    -- Results storage
    local results = {
        points = {},
        stats = {
            total = #points,
            success = 0,
            zMin = nil,
            zMax = nil
        },
        aborted = false,
        abortReason = nil
    }

    -- ========== FIRST POINT: CALIBRATION + RECORD ==========
    -- Move to first point (with retry logic - move up by traverse distance if collision)
    mc.mcCntlSetLastError(inst, string.format("Probing point 1 of %d (calibration)", #points))
    if not ProbeScripts.ProtectedMove(inst, "work", points[1].x, points[1].y, nil) then
        -- Calculate actual XY distance to target for retry height
        local currX = mc.mcAxisGetPos(inst, mc.X_AXIS)
        local currY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
        local moveDistance = math.sqrt((points[1].x - currX)^2 + (points[1].y - currY)^2)
        local retryZ = math.min(mc.mcAxisGetMachinePos(inst, mc.Z_AXIS) + moveDistance, zSoftLimitMax)
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", retryZ))
        if not ProbeScripts.ProtectedMove(inst, "work", points[1].x, points[1].y, nil) then
            results.aborted = true
            results.abortReason = "Movement collision at first point (after retry)"
            return results
        end
    end

    -- Two-tap probe for accurate Z (this is the recorded value for point 1)
    local doubleZ, doubleSuccess = ProbeScripts.Probe(inst, 5, false, false, nil, nil, false, 0.25)
    if not doubleSuccess then
        results.aborted = true
        results.abortReason = "Two-tap probe failed at first point"
        return results
    end
    local doubleMachZ = mc.mcCntlGetPoundVar(inst, 391)

    -- Single tap probe - this is the recorded value, double-tap was just for offset calculation
    local singleZ, singleSuccess = ProbeScripts.Probe(inst, 5, false, false, nil, SINGLE_TAP_FEEDRATE, true, 0.25)
    if not singleSuccess then
        results.aborted = true
        results.abortReason = "Single-tap probe failed at first point"
        return results
    end
    local singleMachZ = mc.mcCntlGetPoundVar(inst, 391)
    local calibrationOffset = singleMachZ - doubleMachZ

    -- Record first point using single-tap with offset applied
    local machineX = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local machineY = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
    local firstPointZ = singleMachZ - calibrationOffset  -- Same as doubleMachZ
    table.insert(results.points, {
        x = machineX,
        y = machineY,
        z = firstPointZ,
        success = true
    })
    results.stats.success = 1
    results.stats.zMin = firstPointZ
    results.stats.zMax = firstPointZ

    if progressCallback then
        progressCallback(1, #points, machineX, machineY, firstPointZ)
    end

    -- ========== REMAINING POINTS: SINGLE TAP WITH OFFSET ==========
    for i = 2, #points do
        local point = points[i]
        mc.mcCntlSetLastError(inst, string.format("Probing point %d of %d (X%.3f Y%.3f)",
            i, #points, point.x, point.y))

        -- Move to XY position using ProtectedMove (with retry logic - move up by traverse distance if collision)
        if not ProbeScripts.ProtectedMove(inst, "work", point.x, point.y, nil) then
            -- Calculate actual XY distance to target for retry height
            local currX = mc.mcAxisGetPos(inst, mc.X_AXIS)
            local currY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
            local moveDistance = math.sqrt((point.x - currX)^2 + (point.y - currY)^2)
            local retryZ = math.min(mc.mcAxisGetMachinePos(inst, mc.Z_AXIS) + moveDistance, zSoftLimitMax)
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", retryZ))
            if not ProbeScripts.ProtectedMove(inst, "work", point.x, point.y, nil) then
                results.aborted = true
                results.abortReason = "Movement collision detected (after retry)"
                mc.mcCntlSetLastError(inst, "Surface probe ABORTED: Movement collision")
                break
            end
        end

        -- Single tap probe at 40 IPM
        local workZ, probeSuccess = ProbeScripts.Probe(inst, 5, false, false, nil, SINGLE_TAP_FEEDRATE, true, 0.25)
        local rawMachineZ = probeSuccess and mc.mcCntlGetPoundVar(inst, 391) or nil

        if probeSuccess and rawMachineZ then
            -- Apply calibration offset
            local machineZ = rawMachineZ - calibrationOffset
            machineX = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
            machineY = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)

            table.insert(results.points, {
                x = machineX,
                y = machineY,
                z = machineZ,
                success = true
            })
            results.stats.success = results.stats.success + 1

            -- Update min/max
            if machineZ < results.stats.zMin then
                results.stats.zMin = machineZ
            end
            if machineZ > results.stats.zMax then
                results.stats.zMax = machineZ
            end

            if progressCallback then
                progressCallback(i, #points, machineX, machineY, machineZ)
            end
        else
            results.aborted = true
            results.abortReason = "No probe contact at point " .. i
            mc.mcCntlSetLastError(inst, "Surface probe ABORTED: No probe contact")
            break
        end
    end

    -- Only save file if probing completed successfully (no aborts) and all points collected
    local expectedPoints = gridParams and (gridParams.xCount * gridParams.yCount) or 0
    if not results.aborted and outputFile and results.stats.success == expectedPoints and gridParams then
        local file = io.open(outputFile, "w")
        if file then
            -- Convert serpentine probe order to row-major 2D grid
            local grid = {}
            local idx = 1
            for row = 0, gridParams.yCount - 1 do
                grid[row] = {}
                if row % 2 == 0 then
                    -- Even rows: left to right
                    for col = 0, gridParams.xCount - 1 do
                        if results.points[idx] then
                            grid[row][col] = results.points[idx].z
                        else
                            grid[row][col] = 0  -- Fallback, shouldn't happen
                        end
                        idx = idx + 1
                    end
                else
                    -- Odd rows: right to left (reverse to get row-major order)
                    for col = gridParams.xCount - 1, 0, -1 do
                        if results.points[idx] then
                            grid[row][col] = results.points[idx].z
                        else
                            grid[row][col] = 0  -- Fallback, shouldn't happen
                        end
                        idx = idx + 1
                    end
                end
            end

            -- Save original grid for heatmap (before margin expansion)
            local originalGrid = grid

            -- Apply margin if specified (extend edge Z values)
            local addMargin = gridParams.addMargin or false
            local finalStartX = gridParams.startX
            local finalEndX = gridParams.endX
            local finalStartY = gridParams.startY
            local finalEndY = gridParams.endY
            local finalXCount = gridParams.xCount
            local finalYCount = gridParams.yCount

            if addMargin then
                -- Add extra steps on all sides (extends edge Z values to prevent boundary issues)
                local xStepSize = gridParams.xStepSize or ((gridParams.endX - gridParams.startX) / (gridParams.xCount - 1))
                local yStepSize = gridParams.yStepSize or ((gridParams.endY - gridParams.startY) / (gridParams.yCount - 1))
                local marginSteps = 10

                finalStartX = gridParams.startX - marginSteps * xStepSize
                finalEndX = gridParams.endX + marginSteps * xStepSize
                finalStartY = gridParams.startY - marginSteps * yStepSize
                finalEndY = gridParams.endY + marginSteps * yStepSize
                finalXCount = gridParams.xCount + 2 * marginSteps  -- +4 columns total
                finalYCount = gridParams.yCount + 2 * marginSteps  -- +4 rows total

                -- Create expanded grid with margin (edge values extended)
                local expandedGrid = {}
                for row = 0, finalYCount - 1 do
                    expandedGrid[row] = {}
                    for col = 0, finalXCount - 1 do
                        -- Map to original grid, clamping to edges
                        local srcRow = math.max(0, math.min(gridParams.yCount - 1, row - marginSteps))
                        local srcCol = math.max(0, math.min(gridParams.xCount - 1, col - marginSteps))
                        expandedGrid[row][col] = grid[srcRow][srcCol]
                    end
                end
                grid = expandedGrid
            end

            -- Build new format: readable header + Z values on single line
            local zParts = {}
            for row = 0, finalYCount - 1 do
                for col = 0, finalXCount - 1 do
                    zParts[#zParts + 1] = string.format("%.4f", grid[row][col])
                end
            end

            file:write(string.format("# Surface Map - %s\n", os.date("%Y-%m-%d %H:%M:%S")))
            file:write(string.format("# Grid: %dx%d, Bounds: X[%.2f,%.2f] Y[%.2f,%.2f]\n",
                finalXCount, finalYCount, finalStartX, finalEndX, finalStartY, finalEndY))
            file:write(string.format("XMIN=%.5f\n", finalStartX))
            file:write(string.format("XMAX=%.5f\n", finalEndX))
            file:write(string.format("XCOUNT=%d\n", finalXCount))
            file:write(string.format("YMIN=%.5f\n", finalStartY))
            file:write(string.format("YMAX=%.5f\n", finalEndY))
            file:write(string.format("YCOUNT=%d\n", finalYCount))
            file:write("Z=" .. table.concat(zParts, ",") .. "\n")
            file:close()
            mc.mcCntlSetLastError(inst, string.format("Surface map saved: %s (%d points%s)",
                outputFile, finalXCount * finalYCount,
                addMargin and ", +2 step margin" or ""))

            -- Store original grid data for visualization (before margin expansion)
            results.grid = originalGrid
            results.gridXCount = gridParams.xCount
            results.gridYCount = gridParams.yCount
            results.gridWidth = gridParams.endX - gridParams.startX
            results.gridHeight = gridParams.endY - gridParams.startY
        else
            mc.mcCntlSetLastError(inst, "Failed to save surface map file: " .. outputFile)
        end
    end

    return results
end


-- UI dialog for surface grid probing
-- Requires T90 (probe) to be active
function ProbeScripts.ProbeSurfaceGridDialog(inst)
    if not RequestMaintenance() then return end
    -- Check probe deployment first (same as other probe scripts)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Show configuration dialog
    local fields = {
        {type = "instructions",
         text = "Probe a grid of points to create a surface height map.\nThe grid will be probed in a serpentine pattern for efficiency."},
        {type = "radio", key = "startMode", label = "Grid Origin",
         options = {"Center of grid", "Bottom-left corner"},
         default = 0,
         tooltip = "Where to position the grid relative to current position"},
        {type = "number", key = "width", label = "Grid Width (X)",
         default = 10.0, min = 0.1,
         tooltip = "Total width of the probe grid"},
        {type = "number", key = "height", label = "Grid Height (Y)",
         default = 10.0, min = 0.1,
         tooltip = "Total height of the probe grid"},
        {type = "number", key = "xPoints", label = "X Points",
         default = 5, min = 2,
         tooltip = "Number of probe points in X direction"},
        {type = "number", key = "yPoints", label = "Y Points",
         default = 5, min = 2,
         tooltip = "Number of probe points in Y direction"},
        {type = "checkbox", key = "addMargin", label = "Add Margin",
         default = true,
         tooltip = "Add 2 extra grid steps on all sides (extends edge Z values to avoid jumps)"},
        {type = "text", key = "filename", label = "Map Name",
         default = "SurfaceMap", persist = false,
         tooltip = "Name for the surface map (saved in SurfaceMaps folder)"}
    }

    local params = ProbeScripts.ShowDialog(inst, "Probe Surface Grid", fields, "ProbeSurfaceGrid", {width = 400})
    if not params then return end

    -- Convert startMode radio index to string
    local startMode = (params.startMode == 0) and "center" or "bottomleft"

    -- Ensure integer point counts (min 2 points per axis)
    local xPoints = math.max(2, math.floor(params.xPoints + 0.5))
    local yPoints = math.max(2, math.floor(params.yPoints + 0.5))

    -- Calculate step sizes (divisions = points - 1)
    local totalPoints = xPoints * yPoints
    local xStepSize = params.width / (xPoints - 1)
    local yStepSize = params.height / (yPoints - 1)

    local addMargin = params.addMargin or false

    -- Store original position for return after probing
    local origWorkX = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local origWorkY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    local origMachZ = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Get probe XY offset from tool 90 (needed for spindle-center grid boundaries)
    local probeXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90)
    local probeYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90)

    -- Generate grid points in serpentine pattern
    local points = {}

    -- Calculate starting corner based on mode, relative to current position
    local startX = origWorkX + ((startMode == "center") and (-params.width / 2) or 0)
    local startY = origWorkY + ((startMode == "center") and (-params.height / 2) or 0)

    -- Generate points (bottom to top, alternating X direction)
    for row = 0, yPoints - 1 do
        local y = startY + row * yStepSize
        if row % 2 == 0 then
            for col = 0, xPoints - 1 do
                table.insert(points, {x = startX + col * xStepSize, y = y})
            end
        else
            for col = xPoints - 1, 0, -1 do
                table.insert(points, {x = startX + col * xStepSize, y = y})
            end
        end
    end

    -- Build output file paths
    local profilePath = mc.mcProfileGetName(inst)
    local profileDir = mc.mcCntlGetMachDir(inst) .. "\\Profiles\\" .. profilePath
    local surfaceMapsDir = profileDir .. "\\SurfaceMaps"
    local filename = params.filename:gsub("%.[^.]*$", "")  -- Strip any extension
    local mapFile = surfaceMapsDir .. "\\" .. filename .. ".txt"

    -- Ensure SurfaceMaps folder exists
    os.execute('mkdir "' .. surfaceMapsDir .. '" 2>nul')

    -- Calculate grid bounds
    local endX = startX + params.width
    local endY = startY + params.height

    -- Run the probing sequence
    -- Grid boundaries use spindle-center positions (probe position - probe offset)
    local results = ProbeScripts.ProbeSurfaceGrid(inst, {
        points = points,
        outputFile = mapFile,
        gridParams = {
            startX = startX - probeXOffset,
            endX = endX - probeXOffset,
            xCount = xPoints,
            startY = startY - probeYOffset,
            endY = endY - probeYOffset,
            yCount = yPoints,
            addMargin = addMargin,
            xStepSize = xStepSize,
            yStepSize = yStepSize
        },
        progressCallback = function(current, total, x, y, z)
            mc.mcCntlSetLastError(inst, string.format("Probed %d/%d - Z=%.4f", current, total, z or 0))
        end
    })

    -- Return sequence: lift to max Z + 0.5", return to original XY, then original Z
    local safeZ = (results.stats.zMax or origMachZ) + 0.5
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", safeZ))

    -- Return to original XY using ProtectedMove (work coords)
    ProbeScripts.ProtectedMove(inst, "work", origWorkX, origWorkY, nil, 300)

    -- Return to original Z using ProtectedMove (machine coords)
    ProbeScripts.ProtectedMove(inst, "mach", nil, nil, origMachZ, 300)

    -- If probing was aborted due to failure, show error and exit (no map saved or enabled)
    if results.aborted then
        wx.wxMessageBox(
            string.format("Surface probing ABORTED!\n\n" ..
                "Failure at point %d of %d\n" ..
                "Error: %s\n\n" ..
                "Surface map NOT saved.\nNo surface map enabled.",
                results.stats.success + 1, results.stats.total,
                results.abortReason or "Unknown error"),
            "Surface Probe Failed",
            wx.wxOK + wx.wxICON_ERROR)
        return results
    end

    -- Show heatmap visualization dialog (returns true if user clicks Apply)
    local applyMap = ProbeScripts.ShowHeatmap(inst, {
        xCount = results.gridXCount,
        yCount = results.gridYCount,
        zMin = results.stats.zMin,
        zMax = results.stats.zMax,
        gridWidth = params.width,
        gridHeight = params.height,
        grid = results.grid
    })

    -- Copy to default SurfaceMap.txt if user clicked Apply in heatmap dialog
    if applyMap then
        local activeMapPath = surfaceMapsDir .. "\\SurfaceMap.txt"
        local srcFile = io.open(mapFile, "r")
        if srcFile then
            local content = srcFile:read("*a")
            srcFile:close()
            local dstFile = io.open(activeMapPath, "w")
            if dstFile then
                dstFile:write(content)
                dstFile:close()
                mc.mcCntlSetLastError(inst, "Surface map saved and activated")
            end
        end
    else
        mc.mcCntlSetLastError(inst, string.format("Surface map saved: %s", mapFile))
    end

    return results
end




function ProbeScripts.Debug(inst)
    mc.mcCntlSetLastError(inst, "DEBUG: Started")

    local outPath = "C:\\Users\\BLPCN\\Downloads\\debug_test.txt"
    local f = io.open(outPath, "w")
    if not f then
        mc.mcCntlSetLastError(inst, "DEBUG: Cannot create file")
        return
    end
    f:write("=== SurfaceMap Disable/Enable Test ===\n\n")
    f:close()

    -- Get the command register
    local reg = mc.mcRegGetHandle(inst, "mcSurfaceMap0/smCommand")
    f = io.open(outPath, "a")
    f:write("Register handle: " .. tostring(reg) .. "\n\n")
    f:close()

    if reg == 0 then
        f = io.open(outPath, "a")
        f:write("ERROR: Plugin register not found\n")
        f:close()
        mc.mcCntlSetLastError(inst, "DEBUG: No plugin")
        return
    end

    -- Step 1: Get current map list
    mc.mcCntlSetLastError(inst, "DEBUG: GET MAP LIST")
    local resp, rc = mc.mcRegSendCommand(reg, "GET MAP LIST")
    f = io.open(outPath, "a")
    f:write("GET MAP LIST response:\n")
    f:write("  rc = " .. tostring(rc) .. "\n")
    f:write("  resp = [" .. tostring(resp) .. "]\n\n")
    f:close()

    -- Step 1.5: DISABLE all maps first
    mc.mcCntlSetLastError(inst, "DEBUG: Disabling all maps")
    local disableIdx = 0
    for line in tostring(resp):gmatch("([^\n]+)") do
        disableIdx = disableIdx + 1
        local disableCmd = "SET MAP " .. tostring(disableIdx) .. " DISABLED"
        local dresp, drc = mc.mcRegSendCommand(reg, disableCmd)
        f = io.open(outPath, "a")
        f:write("Disabled map " .. tostring(disableIdx) .. ": rc=" .. tostring(drc) .. "\n")
        f:close()
    end

    f = io.open(outPath, "a")
    f:write("\n")
    f:close()

    -- Refresh map list after disable
    mc.mcCntlSetLastError(inst, "DEBUG: Refresh list")
    resp, rc = mc.mcRegSendCommand(reg, "GET MAP LIST")
    f = io.open(outPath, "a")
    f:write("After disable - GET MAP LIST:\n")
    f:write("  resp = [" .. tostring(resp) .. "]\n\n")
    f:close()

    if not resp or resp == "" then
        f = io.open(outPath, "a")
        f:write("No maps registered. Check Machine.ini [SurfaceMap/MapN] sections.\n")
        f:close()
        mc.mcCntlSetLastError(inst, "DEBUG: No maps found")
        wx.wxMessageBox("No maps registered.\nSee: " .. outPath, "Debug", wx.wxOK)
        return
    end

    -- Step 2: Parse the map list
    local machDir = mc.mcCntlGetMachDir(inst)
    local profile = mc.mcProfileGetName(inst)
    local targetPath = tostring(machDir) .. "\\Profiles\\" .. tostring(profile) .. "\\test.dat"
    local targetLower = string.lower(targetPath)

    f = io.open(outPath, "a")
    f:write("Target file: " .. targetPath .. "\n\n")
    f:write("Parsing map list:\n")
    f:close()

    local idx = 0
    local enableIdx = nil
    for line in tostring(resp):gmatch("([^\n]+)") do
        idx = idx + 1
        local linePath = line:gsub(",[01]$", "")
        local linePathLower = string.lower(linePath):gsub("/", "\\")
        local status = line:match(",([01])$") or "?"

        f = io.open(outPath, "a")
        f:write("  Index " .. tostring(idx) .. ": " .. linePath .. " (status=" .. status .. ")\n")
        f:close()

        if linePathLower == targetLower then
            enableIdx = idx
            f = io.open(outPath, "a")
            f:write("    ^ MATCH FOUND (status=" .. status .. ")\n")
            f:close()

            -- Check if already enabled
            if status == "1" then
                f = io.open(outPath, "a")
                f:write("\nMap is ALREADY ENABLED. No action needed.\n")
                f:write("\n=== Debug complete ===\n")
                f:close()
                mc.mcCntlSetLastError(inst, "DEBUG: Map already enabled")
                wx.wxMessageBox("Map already enabled!\nSee: " .. outPath, "Debug", wx.wxOK)
                return
            end
        end
    end

    f = io.open(outPath, "a")
    f:write("\n")
    f:close()

    if not enableIdx then
        f = io.open(outPath, "a")
        f:write("Target file not found in map list.\n")
        f:close()
        mc.mcCntlSetLastError(inst, "DEBUG: Map not in list")
        wx.wxMessageBox("Map not found in list.\nSee: " .. outPath, "Debug", wx.wxOK)
        return
    end

    -- Step 3: Enable the map (only if status was 0)
    local enableCmd = "SET MAP " .. tostring(enableIdx) .. " ENABLED"
    mc.mcCntlSetLastError(inst, "DEBUG: " .. enableCmd)
    resp, rc = mc.mcRegSendCommand(reg, enableCmd)
    f = io.open(outPath, "a")
    f:write("Enabling map:\n")
    f:write("  Command: " .. enableCmd .. "\n")
    f:write("  rc = " .. tostring(rc) .. "\n")
    f:write("  resp = [" .. tostring(resp) .. "]\n\n")
    f:close()

    -- Step 4: Verify
    mc.mcCntlSetLastError(inst, "DEBUG: Verify")
    resp, rc = mc.mcRegSendCommand(reg, "GET MAP LIST")
    f = io.open(outPath, "a")
    f:write("Verification GET MAP LIST:\n")
    f:write("  resp = [" .. tostring(resp) .. "]\n\n")
    f:write("=== Debug complete ===\n")
    f:close()

    mc.mcCntlSetLastError(inst, "DEBUG: Complete - map enabled")
    wx.wxMessageBox("Debug complete!\nSee: " .. outPath, "Debug", wx.wxOK)
end


function probescripts()
end