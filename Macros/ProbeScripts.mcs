ProbeScripts = {}
local wx = wx or require("wx")

-- Performs a protected move that will retry if it doesn't reach target
-- Uses probe signal to detect collisions - if probe triggers, we hit something
function ProbeScripts.ProtectedMove(inst, moveType, X, Y, Z, feedrate)
    local RETRY_FEEDRATE_FACTOR = 0.5  -- retry at half speed
    local MIN_RETRY_FEEDRATE = 10  -- minimum feedrate for retry

    -- Default feedrate if not provided
    feedrate = feedrate or 100

    -- Store starting machine positions for return-to-start
    local startXMachine = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local startYMachine = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
    local startZMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Get work positions for building move commands
    local startXWork = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local startYWork = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    local startZWork = mc.mcAxisGetPos(inst, mc.Z_AXIS)
    
    -- Calculate target positions based on move type
    local targetX, targetY, targetZ
    if moveType == "mach" then
        targetX = X or startXMachine
        targetY = Y or startYMachine
        targetZ = Z or startZMachine
    elseif moveType == "work" then
        targetX = X or startXWork
        targetY = Y or startYWork
        targetZ = Z or startZWork
    elseif moveType == "inc" then
        targetX = startXWork + (X or 0)
        targetY = startYWork + (Y or 0)
        targetZ = startZWork + (Z or 0)
    else
        error(string.format("Invalid move type '%s'. Must be 'work', 'mach', or 'inc'", tostring(moveType)))
    end
    
    -- Attempt protected move - success = probe NOT triggered (no collision)
    local function attemptMove(feed)
        local MOVE_THRESHOLD = 0.0001  -- Minimum distance to include an axis
        local gcode = ""
        local hasMove = false

        if moveType == "mach" then
            gcode = "G90 G53 G31.1"
            if math.abs(targetX - startXMachine) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" X%.4f", targetX)
                hasMove = true
            end
            if math.abs(targetY - startYMachine) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Y%.4f", targetY)
                hasMove = true
            end
            if math.abs(targetZ - startZMachine) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Z%.4f", targetZ)
                hasMove = true
            end
        elseif moveType == "inc" then
            gcode = "G91 G31.1"
            if X and math.abs(X) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" X%.4f", X)
                hasMove = true
            end
            if Y and math.abs(Y) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Y%.4f", Y)
                hasMove = true
            end
            if Z and math.abs(Z) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Z%.4f", Z)
                hasMove = true
            end
        else  -- work
            gcode = "G90 G31.1"
            if math.abs(targetX - startXWork) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" X%.4f", targetX)
                hasMove = true
            end
            if math.abs(targetY - startYWork) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Y%.4f", targetY)
                hasMove = true
            end
            if math.abs(targetZ - startZWork) > MOVE_THRESHOLD then
                gcode = gcode .. string.format(" Z%.4f", targetZ)
                hasMove = true
            end
        end

        -- Don't execute if no axes are moving
        if not hasMove then
            return true  -- No movement needed, consider it successful
        end

        gcode = gcode .. string.format(" F%.1f", feed)
        mc.mcCntlGcodeExecuteWait(inst, gcode)

        -- Check if probe triggered (collision detection)
        local probeHandle = mc.mcSignalGetHandle(inst, mc.ISIG_PROBE1)
        local probeTriggered = mc.mcSignalGetState(probeHandle) == 1

        -- Success = probe NOT triggered (no collision)
        -- Failure = probe triggered (hit something)
        if probeTriggered then
            -- Log collision for debugging
            local logPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Logs\\ProtectedMove_Failures.txt"
            local logFile = io.open(logPath, "a")
            if logFile then
                local endXWork = mc.mcAxisGetPos(inst, mc.X_AXIS)
                local endYWork = mc.mcAxisGetPos(inst, mc.Y_AXIS)
                local endZWork = mc.mcAxisGetPos(inst, mc.Z_AXIS)
                local endXMach = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
                local endYMach = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
                local endZMach = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

                logFile:write(string.format("[%s] ProtectedMove Collision:\n", os.date("%Y-%m-%d %H:%M:%S")))
                logFile:write(string.format("  Type: %s, Feed: %.1f\n", moveType, feed))
                logFile:write(string.format("  Start Work: (%.4f, %.4f, %.4f)\n", startXWork, startYWork, startZWork))
                logFile:write(string.format("  Start Mach: (%.4f, %.4f, %.4f)\n", startXMachine, startYMachine, startZMachine))
                logFile:write(string.format("  End Work:   (%.4f, %.4f, %.4f)\n", endXWork, endYWork, endZWork))
                logFile:write(string.format("  End Mach:   (%.4f, %.4f, %.4f)\n", endXMach, endYMach, endZMach))
                logFile:write("  PROBE TRIGGERED - Collision detected\n")
                logFile:write("\n")
                logFile:close()
            end
            return false
        end

        return true  -- Success - no collision
    end
    
    -- First attempt at requested feedrate
    if attemptMove(feedrate) then
        return true
    end

    -- Move failed. Return to start and try again at reduced speed
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f Z%.4f", startXMachine, startYMachine, startZMachine))
    local retryFeedrate = math.max(feedrate * RETRY_FEEDRATE_FACTOR, MIN_RETRY_FEEDRATE)
    if attemptMove(retryFeedrate) then
        return true
    end

    -- Both attempts failed - return to start position
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F200", startXMachine, startYMachine))

    mc.mcCntlSetLastError(inst, string.format("ProtectedMove failed: collision detected after retry. Target(%.4f,%.4f,%.4f)", targetX, targetY, targetZ))
    return false
end


-- Move to work zero for specified axes, handling G68 rotation
-- moveX: boolean to move X axis to 0
-- moveY: boolean to move Y axis to 0
function ProbeScripts.MoveToCenter(inst, moveX, moveY)
    if not moveX and not moveY then
        return true  -- Nothing to do
    end

    -- Check for active G68 rotation
    local g68Active = false
    local savedRotation, savedCenterX, savedCenterY

    if mc.mcCntlGetPoundVar(inst, 4016) == 68 then
        g68Active = true
        -- Save G68 parameters
        savedRotation = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION)
        savedCenterX = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION_X)
        savedCenterY = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION_Y)

        -- Temporarily cancel G68
        mc.mcCntlGcodeExecuteWait(inst, "G69")
    end

    -- Build move command
    local moveCmd = "G90 G1"
    if moveX then
        moveCmd = moveCmd .. " X0"
    end
    if moveY then
        moveCmd = moveCmd .. " Y0"
    end
    moveCmd = moveCmd .. " F200"

    -- Execute the move
    local rc = mc.mcCntlGcodeExecuteWait(inst, moveCmd)

    -- Restore G68 if it was active
    if g68Active then
        mc.mcCntlGcodeExecuteWait(inst, string.format("G68 X%.4f Y%.4f R%.4f",
                                                      savedCenterX, savedCenterY, savedRotation))
    end

    return rc == mc.MERROR_NOERROR
end


-- Returns calibration offset values for each direction
function ProbeScripts.SingleTapCalibrate(inst, feedrate, probeZ)    
    -- Results storage
    local doubleResults = {}
    local singleResults = {
        ["+X"] = {},
        ["-X"] = {},
        ["+Y"] = {},
        ["-Y"] = {}
    }
    
    if probeZ then
        singleResults["-Z"] = {}
    end

    -- Double tap all four sides
    doubleResults["+X"] = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    doubleResults["-X"] = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    doubleResults["+Y"] = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    doubleResults["-Y"] = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
    
    -- Calculate and move to center
    local centerX = (doubleResults["+X"] + doubleResults["-X"]) / 2
    local centerY = (doubleResults["+Y"] + doubleResults["-Y"]) / 2
    
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F100", centerX, centerY))

    if probeZ then
        doubleResults["-Z"] = ProbeScripts.Probe(inst, 5, false, true, nil, nil, false, nil)
    end

    -- Single tap probe calibration moves
    for cycle = 1, 3 do
        singleResults["+X"][cycle] = ProbeScripts.Probe(inst, 1, false, true, nil, feedrate, true, nil)
        singleResults["-X"][cycle] = ProbeScripts.Probe(inst, 2, false, true, nil, feedrate, true, nil)
        singleResults["+Y"][cycle] = ProbeScripts.Probe(inst, 3, false, true, nil, feedrate, true, nil)
        singleResults["-Y"][cycle] = ProbeScripts.Probe(inst, 4, false, true, nil, feedrate, true, nil)
        if probeZ then
            singleResults["-Z"][cycle] = ProbeScripts.Probe(inst, 5, false, true, nil, feedrate, true, nil)
        end
    end

    local calibrationOffsets = {}
    
    for direction, singles in pairs(singleResults) do
        local sum = 0
        for _, singleValue in ipairs(singles) do
            sum = sum + (singleValue - doubleResults[direction])
        end
        calibrationOffsets[direction] = sum / #singles
    end

    return calibrationOffsets
end


-- Core probe function wrapper to .ProbeXYZ (depricated M311)
function ProbeScripts.Probe(inst, direction, setDatum, returnToStart, maxTravel, fastFeed, singleTap, finalRetract)
    -- Abort immediately if machine was stopped (cycle stop, e-stop, etc.)
    local state = mc.mcCntlGetState(inst)
    if state == 0 or state == 1 then  -- IDLE or HOLD
        -- Clean up machine state BEFORE throwing error
        -- This prevents UI lockup even if error propagates uncaught
        pcall(function()
            mc.mcCntlGcodeExecuteWait(inst, "G69")  -- Cancel any G68 rotation
            mc.mcCntlMachineStateClear(inst)
        end)
        error("MACHINE_STOPPED", 0)
    end

    -- Map parameters to ProbeXYZ signature
    local mappedFastFeed = fastFeed or mc.mcCntlGetPoundVar(inst, 516)
    local mappedBackoff = mc.mcCntlGetPoundVar(inst, 519)
    local mappedSlowFeed = singleTap and 0 or mc.mcCntlGetPoundVar(inst, 517)
    local mappedMaxTravel = maxTravel or mc.mcCntlGetPoundVar(inst, 518)
    
    -- Handle finalRetract parameter
    local mappedFinalRetract
    if returnToStart then
        mappedFinalRetract = -1  -- Return to start position
    elseif finalRetract ~= nil then
        mappedFinalRetract = finalRetract
    else
        mappedFinalRetract = mc.mcCntlGetPoundVar(inst, 520)
    end
    
    -- Call ProbeXYZ with mapped parameters
    local machineEdge, workEdge, probeSuccess = ProbeScripts.ProbeXYZ(inst, 
        direction,
        mappedFastFeed,
        mappedBackoff,
        mappedSlowFeed,
        mappedMaxTravel,
        mappedFinalRetract,
        setDatum and 1 or 0
    )

    local edgeValue
    if setDatum then
        edgeValue = 0  -- Always return 0 when setting datum
    else
        edgeValue = workEdge or 0  -- Return workEdge on success, 0 on failure (safer than nil)
    end
    
    return edgeValue, probeSuccess == 1
end


-- Complete ShowDialog wrapper with all functionality preserved
function ProbeScripts.ShowDialog(inst, title, fields, profileSection, options)
    options = options or {}
    local tempPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Temp\\"
    
    -- Get unique sequence number
    local hSequence = mc.mcRegGetHandle(inst, "iRegs0/DialogSequence")
    local sequence = mc.mcRegGetValue(hSequence) + 1
    mc.mcRegSetValue(hSequence, sequence)
    
    -- Create temp directory if needed (silent, no cmd window)
    if not wx.wxDirExists(tempPath) then
        wx.wxMkdir(tempPath)
    end
    
    -- Process fields for serialization
    local function processFields(fields, profileSection)
        local processed = {}
        
        for i, field in ipairs(fields) do
            local pf = {}
            
            -- Copy basic properties
            for k, v in pairs(field) do
                if type(v) ~= "function" then
                    pf[k] = v
                end
            end
            
            -- Load defaults from profile (unless persist == false)
            if field.key and field.persist ~= false then
                if field.type == "number" then
                    pf.default = mc.mcProfileGetDouble(inst, profileSection, field.key, field.default or 0)
                elseif field.type == "checkbox" then
                    pf.default = mc.mcProfileGetInt(inst, profileSection, field.key, field.default or 0)
                elseif field.type == "radio" or field.type == "direction" or field.type == "choice" then
                    pf.default = mc.mcProfileGetInt(inst, profileSection, field.key, field.default or 0)
                elseif field.type == "text" then
                    pf.default = mc.mcProfileGetString(inst, profileSection, field.key, field.default or "")
                end
            end
            
            -- Handle explicit min/max first (most reliable)
            if field.min ~= nil or field.max ~= nil then
                pf.validate = true
                pf.validateMin = field.min or -999999
                pf.validateMax = field.max or 999999
                pf.validateMsg = field.validateMsg or "Value out of range"
            -- Handle validation functions
            elseif field.validate and type(field.validate) == "function" then
                -- For safety, just set wide bounds and let the validate function handle it
                -- The validate function will be called when OK is pressed
                pf.validate = true
                pf.validateMin = -999999
                pf.validateMax = 999999
                pf.validateFunc = field.validate  -- Store the function for later validation
                pf.validateMsg = "Invalid value"
            end
            
            -- Handle onChange flag
            if field.onChange then
                pf.onChange = true
            end
            
            -- Handle constraintHandler for direction fields
            if field.constraintHandler then
                pf.constraintHandler = true
                -- Add flags based on the constraint type
                -- This is simplified - in practice would need to analyze the function
            end
            
            -- Process children recursively
            if field.children then
                pf.children = processFields(field.children, profileSection)
            end
            
            processed[i] = pf
        end
        
        return processed
    end
    
    local processedFields = processFields(fields, profileSection or "Dialog")
    
    -- Serialize fields to file
    local function serializeTable(t, indent)
        indent = indent or ""
        local result = "{\n"
        
        for k, v in pairs(t) do
            result = result .. indent .. "  "
            
            -- Key
            if type(k) == "string" then
                result = result .. k .. " = "
            else
                result = result .. "[" .. k .. "] = "
            end
            
            -- Value
            if type(v) == "string" then
                result = result .. string.format("%q", v)
            elseif type(v) == "number" or type(v) == "boolean" then
                result = result .. tostring(v)
            elseif type(v) == "table" then
                result = result .. serializeTable(v, indent .. "  ")
            else
                result = result .. "nil"
            end
            
            result = result .. ",\n"
        end
        
        return result .. indent .. "}"
    end
    
    -- Write fields to Lua file
    local fieldsFile = io.open(tempPath .. string.format("dialog_fields_%d.lua", sequence), "w")
    if fieldsFile then
        fieldsFile:write("return " .. serializeTable(processedFields))
        fieldsFile:close()
    end
    
    -- Write request parameters
    local requestFile = io.open(tempPath .. string.format("dialog_request_%d.txt", sequence), "w")
    if requestFile then
        requestFile:write(string.format("title=%s\n", title or "Dialog"))
        requestFile:write(string.format("profileSection=%s\n", profileSection or "Dialog"))

        if options.width then
            requestFile:write(string.format("width=%d\n", options.width))
        end

        if options.buttonLabels then
            requestFile:write(string.format("okLabel=%s\n", options.buttonLabels.ok or "OK"))
            requestFile:write(string.format("cancelLabel=%s\n", options.buttonLabels.cancel or "Cancel"))
        end

        requestFile:close()
    end
    
    -- Signal the screen
    local hType = mc.mcRegGetHandle(inst, "iRegs0/DialogType")
    local hRequest = mc.mcRegGetHandle(inst, "iRegs0/DialogRequest")
    local hResponse = mc.mcRegGetHandle(inst, "iRegs0/DialogResponse")
    
    mc.mcRegSetValue(hResponse, 0)
    mc.mcRegSetValueString(hType, "SHOW_DIALOG")
    mc.mcRegSetValue(hRequest, 1)
    
    -- Wait for response
    while mc.mcRegGetValue(hResponse) == 0 do
        wx.wxMilliSleep(50)
        wx.wxSafeYield()
    end
    
    -- Read response
    local responseFile = tempPath .. string.format("dialog_response_%d.txt", sequence)
    local respFile = io.open(responseFile, "r")
    
    local result = {}
    local success = false
    
    for line in respFile:lines() do
        local key, value = line:match("^([^=]+)=(.*)$")
        if key == "success" then
            success = (value == "true")
        elseif key then
            if value == "true" then value = true
            elseif value == "false" then value = false
            elseif tonumber(value) then value = tonumber(value)
            end
            result[key] = value
        end
    end
    
    respFile:close()
    os.remove(responseFile)
    
    -- Clear response flag
    mc.mcRegSetValue(hResponse, 0)
    
    -- Save to profile if successful
    if success then
        for key, value in pairs(result) do
            -- Find field type and persist setting
            local fieldType = nil
            local shouldPersist = true
            for _, field in ipairs(fields) do
                if field.key == key then
                    fieldType = field.type
                    shouldPersist = field.persist ~= false
                    break
                end
                -- Check children
                if field.children then
                    for _, child in ipairs(field.children) do
                        if child.key == key then
                            fieldType = child.type
                            shouldPersist = child.persist ~= false
                            break
                        end
                    end
                end
            end

            -- Save based on type (skip if persist == false)
            if shouldPersist then
                if fieldType == "number" then
                    mc.mcProfileWriteDouble(inst, profileSection, key, value)
                elseif fieldType == "checkbox" then
                    mc.mcProfileWriteInt(inst, profileSection, key, value and 1 or 0)
                elseif fieldType == "radio" or fieldType == "direction" or fieldType == "choice" then
                    mc.mcProfileWriteInt(inst, profileSection, key, value)
                elseif fieldType == "text" then
                    mc.mcProfileWriteString(inst, profileSection, key, tostring(value))
                end
            end
        end

        mc.mcProfileFlush(inst)
        return result
    else
        return nil
    end
end


-- Generic results display with flexible formatting
function ProbeScripts.DisplayResults(inst, results, title, options)
    options = options or {}
    
    -- Format a value for display
    local function formatValue(value, decimals)
        decimals = decimals or 4
        if type(value) == "number" then
            return string.format("%." .. decimals .. "f", value)
        elseif type(value) == "boolean" then
            return value and "Yes" or "No"
        elseif value == nil then
            return "N/A"
        else
            return tostring(value)
        end
    end
    
    -- Build status message (single line for status bar)
    local statusMessage = ""
    if options.statusFormat then
        -- Use custom format string if provided
        statusMessage = options.statusFormat
        for key, value in pairs(results) do
            local placeholder = "{" .. key .. "}"
            if string.find(statusMessage, placeholder) then
                statusMessage = string.gsub(statusMessage, placeholder, formatValue(value))
            end
        end
    else
        -- Auto-build status from primary keys
        statusMessage = title .. ":"
        local primaryKeys = options.primaryKeys or {}
        if #primaryKeys == 0 then
            -- If no primary keys specified, use first 3 numeric values
            local count = 0
            for key, value in pairs(results) do
                if type(value) == "number" and count < 3 then
                    statusMessage = statusMessage .. string.format(" %s=%s", key, formatValue(value))
                    count = count + 1
                end
            end
        else
            -- Use specified primary keys
            for _, key in ipairs(primaryKeys) do
                if results[key] ~= nil then
                    statusMessage = statusMessage .. string.format(" %s=%s", key, formatValue(results[key]))
                end
            end
        end
    end
    
    -- Update status bar
    mc.mcCntlSetLastError(inst, statusMessage)
    
    -- Build detailed message if needed
    if options.showDetails then
        local detailMessage = title .. "\n"
        detailMessage = detailMessage .. string.rep("=", string.len(title)) .. "\n\n"
        
        -- Sort keys for consistent display
        local sortedKeys = {}
        for key, _ in pairs(results) do
            table.insert(sortedKeys, key)
        end
        table.sort(sortedKeys)
        
        -- Find longest key for alignment
        local maxKeyLen = 0
        for _, key in ipairs(sortedKeys) do
            if string.len(key) > maxKeyLen then
                maxKeyLen = string.len(key)
            end
        end
        
        -- Display each result
        for _, key in ipairs(sortedKeys) do
            local value = results[key]
            -- Skip internal/hidden keys if specified
            if not (options.hideKeys and options.hideKeys[key]) then
                local padding = string.rep(" ", maxKeyLen - string.len(key))
                detailMessage = detailMessage .. string.format("%s:%s  %s\n", 
                                                              key, padding, 
                                                              formatValue(value))
            end
        end
        
        -- Show dialog
        wx.wxMessageBox(detailMessage, title, wx.wxOK + wx.wxICON_INFORMATION)
    end
    
    -- Log to file if specified
    if options.logFile then
        local file = io.open(options.logFile, "a")
        if file then
            file:write(os.date("[%Y-%m-%d %H:%M:%S] "))
            file:write(statusMessage)
            file:write("\n")
            file:close()
        end
    end
    
    -- Store in profile if key provided
    if options.profileKey then
        mc.mcProfileWriteString(inst, "ProbeResults", options.profileKey, statusMessage)
        mc.mcProfileFlush(inst)
    end
    
    return statusMessage
end


-- Check if probe T90 is deployed
function ProbeScripts.CheckProbeDeployed(inst)
    local currentTool = mc.mcToolGetCurrent(inst)

    if currentTool == 90 then
        return true
    end

    local result = wx.wxMessageBox(
        "Touch probe (T90) is not active.\nCurrent tool: T" .. currentTool .. "\n\nWould you like to change to T90?",
        "Tool Change Required",
        wx.wxYES_NO + wx.wxICON_QUESTION
    )
    
    if result == wx.wxYES then
        mc.mcCntlGcodeExecuteWait(inst, "T90")
        ProbeScripts.M6_ToolChange(inst)
        mc.mcCntlSetLastError(inst, "Tool changed to T90 - Ready to probe")
    else
        return false
    end
end


-- Probe outside an edge by moving out first to avoid collisions
function ProbeScripts.ProbeOutside(inst, direction, outDistance, zDown, moveSpeed)
    -- moveSpeed: optional feed rate for XY traverse and retract moves (default 200)
    local xySpeed = moveSpeed or 200

    local dirMap = {
        [1] = {axis = mc.X_AXIS, letter = "X", sign = 1},   -- +X
        [2] = {axis = mc.X_AXIS, letter = "X", sign = -1},  -- -X
        [3] = {axis = mc.Y_AXIS, letter = "Y", sign = 1},   -- +Y
        [4] = {axis = mc.Y_AXIS, letter = "Y", sign = -1}   -- -Y
    }
    local info = dirMap[direction]

    -- Capture starting machine positions for all axes
    local startXMachine = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local startYMachine = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
    local startZMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Move out clamped just under the soft limit
    local cur   = mc.mcAxisGetMachinePos(inst, info.axis)
    local minL  = mc.mcAxisGetSoftlimitMin(inst, info.axis) + 0.05
    local maxL  = mc.mcAxisGetSoftlimitMax(inst, info.axis) - 0.05
    local span  = (info.sign > 0) and (maxL - cur) or (cur - minL)
    local inc   = info.sign * math.max(0, math.min(math.abs(outDistance or 0), span))
    local moveOutSuccess = ProbeScripts.ProtectedMove(inst, "inc", (info.letter=="X") and inc or nil, (info.letter=="Y") and inc or nil, nil, xySpeed)

    if not moveOutSuccess then
        -- Horizontal move failed, already returned to start by ProtectedMove
        mc.mcCntlSetLastError(inst, string.format("%s traverse move failed", info.letter))
        return nil
    end

    -- Protected drop down (incremental Z-)
    local dropSuccess = ProbeScripts.ProtectedMove(inst, "inc", nil, nil, -zDown, 100)

    if not dropSuccess then
        -- Z drop failed (hit something), ProtectedMove returned to position after X/Y move
        -- Need to return to original starting position
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F%.0f", startXMachine, startYMachine, xySpeed))
        mc.mcCntlSetLastError(inst, string.format("%s width too small - collision during Z drop", info.letter))
        return nil
    end
    
    -- Calculate probe direction
    local probeDirection
    if direction == 1 then probeDirection = 2      -- Moved +X, probe -X
    elseif direction == 2 then probeDirection = 1  -- Moved -X, probe +X
    elseif direction == 3 then probeDirection = 4  -- Moved +Y, probe -Y
    elseif direction == 4 then probeDirection = 3  -- Moved -Y, probe +Y
    end
    
    -- Perform the probe with 0.25in retract
    local edgeWork, success = ProbeScripts.Probe(inst, probeDirection, false, false, nil, nil, false, 0.25)
    if not success then
        mc.mcCntlSetLastError(inst, string.format("Probe failed in %s direction", info.letter))
            -- Return to start using machine coords
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F%.0f", startXMachine, startYMachine, xySpeed))
        return nil
    end

    -- Return to start using machine coords
    -- First move Z up
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))
    -- Then move X and Y back
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F%.0f", startXMachine, startYMachine, xySpeed))

    return edgeWork
end


-- Returns: "cancel_g68", "keep_g68", or nil (user cancelled)
function ProbeScripts.CheckG68Rotation(inst)
    -- Check if G68 rotation is currently active
    local modalGroup16 = mc.mcCntlGetPoundVar(inst, 4016)
    if modalGroup16 ~= 68 then
        return "no_rotation"
    end

    local currentRotation = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION)
    local rotationX = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION_X)
    local rotationY = mc.mcCntlGetPoundVar(inst, mc.SV_ROTATION_Y)
    
    local message = string.format("G68 rotation is currently active:\nAngle: %.4fÂ°\nCenter: X%.4f Y%.4f\n\nHow would you like to proceed?",
                                 currentRotation, rotationX, rotationY)

    local dialog = wx.wxMessageDialog(wx.NULL, message, "Active G68 Rotation Detected", 
                                      wx.wxYES_NO + wx.wxCANCEL + wx.wxICON_WARNING)
    
    dialog:SetYesNoCancelLabels("Cancel G68 and Run", "Keep G68 and Run", "Cancel")
    
    local result = dialog:ShowModal()
    dialog:Destroy()
    
    if result == wx.wxID_YES then
        mc.mcCntlGcodeExecuteWait(inst, "G69")
        mc.mcCntlSetLastError(inst, "G68 rotation cancelled")
        return "cancel_g68"
    elseif result == wx.wxID_NO then
        return "keep_g68"
    else
        return nil
    end
end

-- Performs touch probe operation in specified direction
function ProbeScripts.ProbeXYZ(inst, direction, fastFeed, backoff, slowFeed, maxTravel, finalRetract, setDatum)
    local probeSuccess = 0

    -- Direction mapping: axis, direction multiplier, axis letter
    local dirMap = {
        [1] = {mc.X_AXIS,  1, "X"},
        [2] = {mc.X_AXIS, -1, "X"},
        [3] = {mc.Y_AXIS,  1, "Y"},
        [4] = {mc.Y_AXIS, -1, "Y"},
        [5] = {mc.Z_AXIS, -1, "Z"}
    }
    
    local axis, dir, axisLetter = table.unpack(dirMap[direction])
    
    -- Store starting position in machine coordinates for all axes
    local startXMachine = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local startYMachine = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
    local startZMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Get the starting position for the probed axis
    local axisStartPos
    if axis == mc.X_AXIS then
        axisStartPos = startXMachine
    elseif axis == mc.Y_AXIS then
        axisStartPos = startYMachine
    else  -- mc.Z_AXIS
        axisStartPos = startZMachine
    end

    -- Helper function to attempt unsticking probe
    local function attemptUnstickProbe(probeSig, contactPos, feedRate)
        local maxAttempts = 3
        local pushDistances = {0.01, 0.05, 0.1}  -- Progressive push distances

        for attempt = 1, maxAttempts do
            if mc.mcSignalGetState(probeSig) ~= 1 then
                -- Probe is clear
                if attempt > 1 then
                    mc.mcCntlSetLastError(inst, string.format("Probe unstuck after %d attempt(s)", attempt - 1))
                end
                return true
            end

            local pushInDistance = pushDistances[attempt]
            mc.mcCntlSetLastError(inst, string.format("Probe stuck - unstick attempt %d of %d (push %.3f\")",
                                                      attempt, maxAttempts, pushInDistance))

            -- Move to contact position plus extra distance into surface
            local targetPos = contactPos + (dir * pushInDistance)
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 %s%.4f F%.1f", axisLetter, targetPos, feedRate))

            -- Retract ALL THE WAY BACK to original starting position with rapid move
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 %s%.4f", axisLetter, axisStartPos))
        end

        -- Check one final time
        if mc.mcSignalGetState(probeSig) == 1 then
            mc.mcCntlSetLastError(inst, string.format("Probe stuck after %d unstick attempts - manual intervention required", maxAttempts))
            return false
        end

        mc.mcCntlSetLastError(inst, string.format("Probe unstuck after %d attempt(s)", maxAttempts))
        return true
    end

    -- Check probe signal isn't already triggered
    local probeHandle = mc.mcSignalGetHandle(inst, mc.ISIG_PROBE1)
    local probeState = mc.mcSignalGetState(probeHandle)
    if probeState == 1 then  -- Probe already triggered
        mc.mcCntlSetLastError(inst, "Probe error: Probe already triggered")
        error("Probe already triggered - check clearance")
    end

    -- Get per-direction probe diameters from PVs 511-515
    -- PV 511: +X, PV 512: -X, PV 513: +Y, PV 514: -Y, PV 515: Z offset
    local probeDiameters = {
        [1] = mc.mcCntlGetPoundVar(inst, 511),  -- +X
        [2] = mc.mcCntlGetPoundVar(inst, 512),  -- -X
        [3] = mc.mcCntlGetPoundVar(inst, 513),  -- +Y
        [4] = mc.mcCntlGetPoundVar(inst, 514),  -- -Y
        [5] = mc.mcCntlGetPoundVar(inst, 515)   -- Z axis, effective Z probe diameter
    }

    -- Get the appropriate probe radius for this direction
    local probeRadius = probeDiameters[direction] / 2

    -- Clamp maxTravel to soft limit
    local currentPos = mc.mcAxisGetMachinePos(inst, axis)
    if dir > 0 then
        maxTravel = math.min(maxTravel or 10, mc.mcAxisGetSoftlimitMax(inst, axis) - currentPos - 0.05)
    else
        maxTravel = math.min(maxTravel or 10, currentPos - mc.mcAxisGetSoftlimitMin(inst, axis) - 0.05)
    end

    -- Fast probe
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G31.1 %s%.4f F%.1f", axisLetter, dir * (maxTravel or 10), fastFeed))

    -- Check if probe triggered
    local probeSig = mc.mcSignalGetHandle(inst, mc.ISIG_PROBE1)
    probeSuccess = mc.mcSignalGetState(probeSig)

    -- Two-tap probe if slow feed provided
    if slowFeed and slowFeed > 0 and backoff > 0 then
        local firstStrike = mc.mcAxisGetProbePos(inst, axis, 1)  -- Get machine position
        local firstStrikeWork = mc.mcAxisGetProbePos(inst, axis, 0)  -- Get work position
        -- Incremental retract from probe strike
        mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 %s%.4f F50", axisLetter, -dir * backoff))

        -- Check if probe is still triggered after retract and attempt unstick if needed
        if mc.mcSignalGetState(probeSig) == 1 then
            if not attemptUnstickProbe(probeSig, firstStrike, fastFeed) then
                mc.mcCntlSetPoundVar(inst, 393, 0)
                return nil, nil, 0
            end
        end
        
        -- Slow probe
        mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G31.1 %s%.4f F%.1f", axisLetter, dir * (backoff * 2), slowFeed))
        -- Update success flag
        probeSuccess = mc.mcSignalGetState(probeSig)
    end
    
    -- Final retract handling
    if finalRetract then
        if finalRetract == -1 then
            -- Return to starting position using machine coordinates for all axes
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G1 X%.4f Y%.4f F200", startXMachine, startYMachine))

            -- Check if probe is still triggered after retract and attempt unstick if needed
            if mc.mcSignalGetState(probeSig) == 1 then
                local contactPos = mc.mcAxisGetProbePos(inst, axis, 1)  -- Get last probe contact in machine coords

                if not attemptUnstickProbe(probeSig, contactPos, fastFeed) then
                    mc.mcCntlSetPoundVar(inst, 393, 0)
                    return nil, nil, 0
                end
            end
        elseif finalRetract > 0 then
            -- Incremental custom retract clamped to soft limit
            local pos = mc.mcAxisGetMachinePos(inst, axis)
            local tgt = math.min(mc.mcAxisGetSoftlimitMax(inst, axis) - 0.05,
                        math.max(mc.mcAxisGetSoftlimitMin(inst, axis) + 0.05, pos - dir * finalRetract))

            mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 %s%.4f F100", axisLetter, tgt - pos))

            -- Check if probe is still triggered after retract and attempt unstick if needed
            if mc.mcSignalGetState(probeSig) == 1 then
                local contactPos = mc.mcAxisGetProbePos(inst, axis, 1)  -- Get last probe contact in machine coords

                if not attemptUnstickProbe(probeSig, contactPos, fastFeed) then
                    mc.mcCntlSetPoundVar(inst, 393, 0)
                    return 0, 0, 0
                end
            end
        end
    end

    -- Return nil on miss
    if probeSuccess ~= 1 then
        mc.mcCntlSetPoundVar(inst, 393, 0)
        return nil, nil, 0
    end

    -- Get final strike positions
    local strikePosMachine = mc.mcAxisGetProbePos(inst, axis, 1)
    local strikePosWork = mc.mcAxisGetProbePos(inst, axis, 0)
    
    -- Calculate edge positions, compensate for probe ball
    local machineEdge, workEdge
    if axis == mc.Z_AXIS then
        -- Z axis, apply Z offset compensation (effective Z probe diameter)
        -- For Z, the offset acts like a probe radius compensation
        machineEdge = strikePosMachine + (dir * probeRadius)
        workEdge = strikePosWork + (dir * probeRadius)
    else
        machineEdge = strikePosMachine + (dir * probeRadius)
        workEdge = strikePosWork + (dir * probeRadius)
    end
    
    if setDatum == 1 then
        local currentPos = mc.mcAxisGetPos(inst, axis)
        -- Calculate what to set current position to so edge becomes 0
        local setValue = currentPos - workEdge
        -- Apply datum using mcAxisSetPos
        mc.mcAxisSetPos(inst, axis, setValue)
        local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
        local offsetNum = 54
        if modalOffset >= 54 and modalOffset <= 59 then
            offsetNum = math.floor(modalOffset + 0.5)
        end
        
        mc.mcCntlSetLastError(inst, string.format("G%d %s0 set (edge at %.4f zeroed)", 
                                                  offsetNum, axisLetter, workEdge))

        workEdge = 0.0
    end

    -- 391 = last probe machine position
    -- 392 = last probe work position  
    -- 393 = probe success flag (0 or 1)
    mc.mcCntlSetPoundVar(inst, 391, machineEdge)
    mc.mcCntlSetPoundVar(inst, 392, workEdge)
    mc.mcCntlSetPoundVar(inst, 393, probeSuccess and 1 or 0)

    return machineEdge, workEdge, probeSuccess
end



--===================== Begin Probe Scripts =====================--



-- M310 Tool Height Measurement
function ProbeScripts.M310_ProbeToolHeight(inst)
    -- Get current tool
    local tool = mc.mcToolGetCurrent(inst)
    
    -- Configuration from pound variables
    local SAFE_Z = mc.mcCntlGetPoundVar(inst, 523)
    local PROBE_STATION_X = mc.mcCntlGetPoundVar(inst, 526)
    local PROBE_STATION_Y = mc.mcCntlGetPoundVar(inst, 527)
    local SURFACE_Z = mc.mcCntlGetPoundVar(inst, 528)
    local PROBE_MAX_DEPTH = mc.mcCntlGetPoundVar(inst, 529)
    local HEIGHT_FAST_FEED = mc.mcCntlGetPoundVar(inst, 530)
    local HEIGHT_SLOW_FEED = mc.mcCntlGetPoundVar(inst, 531)
    local HEIGHT_RETRACT = mc.mcCntlGetPoundVar(inst, 532)
    
    -- Calculate position offsets based on tool type
    local stationX = PROBE_STATION_X
    local stationY = PROBE_STATION_Y

    -- T0 (spindle rim) needs spindle probe X offset from PV 533
    if tool == 0 then
        local spindleXOffset = mc.mcCntlGetPoundVar(inst, 533)
        stationX = stationX + spindleXOffset
    else
        -- All tools (physical and virtual) can have ProbeXOffset
        local probeXOffset = mc.mcToolGetDataExDbl(inst, tool, "ProbeXOffset")
        probeXOffset = probeXOffset or 0
        stationX = stationX + probeXOffset

        -- Virtual tools (T90-T99) additionally need tool table offset compensation
        if tool >= 90 and tool <= 99 then
            local toolXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, tool)
            local toolYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, tool)
            toolXOffset = toolXOffset or 0
            toolYOffset = toolYOffset or 0
            stationX = stationX + toolXOffset
            stationY = stationY + toolYOffset
        end
    end
    
    -- Move to probe station using helper functions
    mc.mcCntlGcodeExecuteWait(inst, "G49")
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z0")
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f", stationX, stationY))

    -- Save laser state before probing (ESS disables test mode during G31)
    local savedLaserEnable = 0
    local savedLaserActivate = 0
    if tool == 91 then
        local hregEnable = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Enable")
        local hregActivate = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Activate")
        if hregEnable ~= 0 then
            savedLaserEnable = mc.mcRegGetValue(hregEnable)
        end
        if hregActivate ~= 0 then
            savedLaserActivate = mc.mcRegGetValue(hregActivate)
        end
    end

    -- Perform measurement - all tools now use G31 method
    -- Calculate probe travel distance
    local travelDistance = -math.abs(PROBE_MAX_DEPTH)

    -- First probe (fast)
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G31 Z%.4f F%.1f", travelDistance, HEIGHT_FAST_FEED))
    local strike1 = mc.mcAxisGetProbePos(inst, mc.Z_AXIS, 1)  -- machine coords

    -- Retract
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", strike1 + HEIGHT_RETRACT))

    -- Turn on air blast to clean probe surface
    local hOutput8 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT8)
    mc.mcSignalSetState(hOutput8, 1)

    -- Second probe (slow)
    -- Probe slightly past the first strike position
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G31 Z%.4f F%.1f", -(HEIGHT_RETRACT + 0.1), HEIGHT_SLOW_FEED))
    local measuredZ = mc.mcAxisGetProbePos(inst, mc.Z_AXIS, 1)  -- machine coords

    -- Turn off air blast
    mc.mcSignalSetState(hOutput8, 0)
    
    -- For T0, save spindle rim position as the reference
    if tool == 0 then
        mc.mcCntlSetPoundVar(inst, 528, measuredZ)  -- Save spindle rim position
        SURFACE_Z = measuredZ  -- Update local variable
        toolHeight = 0  -- T0 height is 0 by definition (it IS the reference)
    else
        -- Calculate tool height relative to spindle rim (SURFACE_Z)
        toolHeight = measuredZ - SURFACE_Z
    end

    mc.mcToolSetData(inst, mc.MTOOL_MILL_HEIGHT, tool, toolHeight)

    -- Retract to Z0
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z0")

    -- Apply H offset (only for tools > 0)
    if tool > 0 then
        mc.mcCntlGcodeExecuteWait(inst, string.format("G43 H%d", tool))
    end

    -- Restore laser state after probing (if it was saved)
    if tool == 91 and (savedLaserEnable == 1 or savedLaserActivate == 1) then
        local hregEnable = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Enable")
        local hregActivate = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Activate")
        if savedLaserEnable == 1 and hregEnable ~= 0 then
            mc.mcRegSetValue(hregEnable, 1)
        end
        if savedLaserActivate == 1 and hregActivate ~= 0 then
            mc.mcRegSetValue(hregActivate, 1)
        end
    end

    mc.mcCntlSetLastError(inst, string.format("T%d measured: Height = %.4f", tool, toolHeight))
    return 0
end




-- M6 Tool Change Function
function ProbeScripts.M6_ToolChange(inst)
    local bootWasDown = false

    -- Set M6 in-progress flag (used by UI to disable override controls)
    mc.mcCntlSetPoundVar(inst, 499, 1)

    -- Capture current FRO and RRO values
    local savedFRO = mc.mcCntlGetFRO(inst)
    local savedRRO = mc.mcCntlGetRRO(inst)

    -- Set FRO and RRO to 100% for tool change
    mc.mcCntlSetFRO(inst, 100)
    mc.mcCntlSetRRO(inst, 100)

    -- Configuration from pound variables
    local Z_CLEARANCE = mc.mcCntlGetPoundVar(inst, 523)     -- Z clearance above tool pocket (relative)
    local PULLOUT_DIST = mc.mcCntlGetPoundVar(inst, 524)    -- Y pullout distance
    local APPROACH_FEED = mc.mcCntlGetPoundVar(inst, 525)   -- Approach feedrate

    -- Get current and requested tools
    local current = mc.mcToolGetCurrent(inst)
    local requested = mc.mcToolGetSelected(inst)

    -- Movement error handling
    local function GcodeExecuteWait(gcode)
        local rc = mc.mcCntlGcodeExecuteWait(inst, gcode)
        if rc ~= mc.MERROR_NOERROR then
            -- Restore FRO and RRO before error
            mc.mcCntlSetFRO(inst, savedFRO)
            mc.mcCntlSetRRO(inst, savedRRO)
            -- Clear M6 in-progress flag
            mc.mcCntlSetPoundVar(inst, 499, 0)
            error("Motion aborted")
        end
    end

    -- Save boot state and raise
    local hDustBoot = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3)
    if mc.mcSignalGetState(hDustBoot) == 1 then
        bootWasDown = true
        mc.mcSignalSetState(hDustBoot, 0)
    end

    -- Deploy or restore dust boot
    local function SetBootState()
        local bootAuto = mc.mcSignalGetState(mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT52)) == 1
        local machState = mc.mcCntlGetState(inst)
        local isFileRun = (machState >= 100 and machState < 200) -- only file runs

        if bootWasDown or (bootAuto and isFileRun and requested > 0 and requested < 90) then
            mc.mcSignalSetState(hDustBoot, 1)
        end
    end

    -- Same tool - just sync H offset, don't touch boot
    if current == requested then
        if requested > 0 and requested < 90 then
            GcodeExecuteWait("G49")
            GcodeExecuteWait(string.format("G43 H%d", requested))
            SetBootState()
        end
        -- Restore FRO and RRO to saved values
        mc.mcCntlSetFRO(inst, savedFRO)
        mc.mcCntlSetRRO(inst, savedRRO)
        -- Clear M6 in-progress flag
        mc.mcCntlSetPoundVar(inst, 499, 0)
        return 0
    end
    
    -- Helper function to drop current physical tool
    -- targetTool: the tool we're picking up next (for group-based retract height)
    local function dropTool(targetTool)
        local pocketX = mc.mcToolGetDataExDbl(inst, current, "XToolChange")
        local pocketY = mc.mcToolGetDataExDbl(inst, current, "YToolChange")
        local pocketZ = mc.mcToolGetDataExDbl(inst, current, "ZToolChange")

        -- Stop spindle if running
        local hInput13 = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT13)
        if mc.mcSignalGetState(hInput13) == 1 then
            mc.mcSpindleSetDirection(inst, 0)
        end

        -- Move to Z0
        GcodeExecuteWait("G90 G53 G0 Z0")

        -- Move to X and Y-pullout position (behind the pocket)
        GcodeExecuteWait(string.format("G90 G53 G0 X%.4f Y%.4f", pocketX, pocketY - PULLOUT_DIST))

        -- Descend to pocket Z
        GcodeExecuteWait(string.format("G90 G53 G0 Z%.4f", pocketZ))

        -- Move forward into pocket
        GcodeExecuteWait(string.format("G90 G53 G1 Y%.4f F%.1f", pocketY, APPROACH_FEED))

        -- Unlock clamp
        local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        mc.mcSignalSetState(hOutput2, 1)

        -- Wait in 100ms cycles until INPUT17 goes LOW and OUTPUT2 reads HIGH
        local hInput17 = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
        while true do
            local in17  = mc.mcSignalGetState(hInput17)
            local out2  = mc.mcSignalGetState(hOutput2)
            if in17 == 0 and out2 == 1 then
                break
            end
            wx.wxMilliSleep(100)
        end
        wx.wxMilliSleep(100)

        -- Retract height depends on whether target is in same group
        -- Group 1: tools 1-9, Group 2: tools 10-89
        local sameGroup = (current <= 9 and targetTool <= 9) or (current >= 10 and targetTool >= 10)

        if sameGroup and targetTool > 0 and targetTool < 90 then
            -- Same group: retract to target tool Z + clearance
            local targetZ = mc.mcToolGetDataExDbl(inst, targetTool, "ZToolChange")
            GcodeExecuteWait(string.format("G90 G53 G0 Z%.4f", targetZ + Z_CLEARANCE))
        else
            -- Different group or going to virtual/T0: retract to Z0
            GcodeExecuteWait("G90 G53 G0 Z0")
        end
    end
    
    -- Helper function to retract virtual tool
    local function retractVirtual()
        if current == 90 then
            -- Retract probe
            local hOutput7 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
            mc.mcSignalSetState(hOutput7, 0)
        elseif current == 91 then
            -- Retract laser and disable firing
            local hOutput1 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
            mc.mcSignalSetState(hOutput1, 0)
            -- Also disable laser firing for safety
            local hregActivate = mc.mcRegGetHandle(inst, "ESS/Laser/Test_Mode_Activate")
            mc.mcRegSetValue(hregActivate, 0)
            mc.mcSignalSetState(mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT9), 0)
        end
    end
    
    -- ===== Virtual Tool Handling (T90-T99) =====
    if requested >= 90 then
        -- Drop current physical tool if any
        if current > 0 and current < 90 then
            dropTool(requested)
        end

        -- Lock clamp
        local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        mc.mcSignalSetState(hOutput2, 0)

        -- Retract current virtual tool if any
        retractVirtual()

        -- Move to Z0 for virtual tool deployment
        GcodeExecuteWait("G90 G53 G0 Z0")
        
        -- Deploy requested virtual tool
        if requested == 90 then
            local hOutput7 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
            mc.mcSignalSetState(hOutput7, 1)
        elseif requested == 91 then
            local hOutput1 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
            mc.mcSignalSetState(hOutput1, 1)
        end
        
        -- Set tool and apply offsets (G43 automatically applies X/Y from tool table)
        mc.mcToolSetCurrent(inst, requested)
        GcodeExecuteWait(string.format("G43 H%d", requested))
        mc.mcCntlSetPoundVar(inst, 550, requested)

        -- Clear M6 in-progress flag
        mc.mcCntlSetPoundVar(inst, 499, 0)
        return 0
    end
    
    -- ===== T0 = Clear Tool =====
    if requested == 0 then
        -- Retract virtual tool
        retractVirtual()
        -- Drop physical tool
        if current > 0 and current < 90 then
            dropTool(requested)
        end

        -- Lock clamp
        local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        mc.mcSignalSetState(hOutput2, 0)

        mc.mcToolSetCurrent(inst, 0)
        GcodeExecuteWait("G49")
        mc.mcCntlSetPoundVar(inst, 550, 0)
        GcodeExecuteWait("G90 G53 G0 Z0")
        -- Clear M6 in-progress flag
        mc.mcCntlSetPoundVar(inst, 499, 0)
        return 0
    end
    
    -- ===== Physical Tool Change (T1-T89) =====

    -- Drop current physical tool or prepare for pickup
    if current > 0 and current < 90 and current ~= requested then
        dropTool(requested)
        -- dropTool leaves us at appropriate Z, ready for next pocket
    else
        retractVirtual()

        -- Clear virtual tool immediately so UI updates
        if current >= 90 then
            mc.mcToolSetCurrent(inst, 0)
        end

        -- Move to Z0 for both T0 and virtual tools
        GcodeExecuteWait("G90 G53 G0 Z0")

        -- Open clamp
        local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        mc.mcSignalSetState(hOutput2, 1)
    end
    
    -- Get tool pocket position
    local pocketX = mc.mcToolGetDataExDbl(inst, requested, "XToolChange")
    local pocketY = mc.mcToolGetDataExDbl(inst, requested, "YToolChange")
    local pocketZ = mc.mcToolGetDataExDbl(inst, requested, "ZToolChange")
    
    -- Move to pocket position
    GcodeExecuteWait(string.format("G90 G53 G0 X%.4f Y%.4f", pocketX, pocketY))
    GcodeExecuteWait(string.format("G90 G53 G1 Z%.4f F%.1f", pocketZ, APPROACH_FEED))
    
    -- Lock clamp
    local hOutput2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
    mc.mcSignalSetState(hOutput2, 0)

    -- Wait for tool present signal with debounce (500ms timeout, 100ms debounce)
    local h = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    local t, stable = 0, 0
    while t < 500 do
        if mc.mcSignalGetState(h) == 1 then
            stable = stable + 50
            if stable >= 100 then break end
        else
            stable = 0
        end
        wx.wxMilliSleep(50)
        t = t + 50
    end
    if stable < 100 then
        -- Tool pickup failed - clear tool state
        mc.mcToolSetCurrent(inst, 0)
        mc.mcCntlSetPoundVar(inst, 550, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        -- Restore FRO and RRO before error
        mc.mcCntlSetFRO(inst, savedFRO)
        mc.mcCntlSetRRO(inst, savedRRO)
        -- Clear M6 in-progress flag
        mc.mcCntlSetPoundVar(inst, 499, 0)
        error(string.format("Failed to pick up T%d - tool presence not detected", requested))
    end

    -- Pullout movement
    local pulloutY = pocketY - PULLOUT_DIST
    GcodeExecuteWait(string.format("G90 G53 G1 Y%.4f F%.1f", pulloutY, APPROACH_FEED))

    -- Retract to Z0
    GcodeExecuteWait("G90 G53 G0 Z0")
    
    -- Set current tool
    mc.mcToolSetCurrent(inst, requested)
    mc.mcCntlSetPoundVar(inst, 550, requested)
    
    -- ===== Height Measurement =====
    local autoProbe = mc.mcToolGetDataExInt(inst, requested, "AutoProbe")
    
    if autoProbe == 1 then
        -- Call M310 directly to measure tool height
        ProbeScripts.M310_ProbeToolHeight(inst)
    else
        -- Just apply existing H offset
        GcodeExecuteWait("G49")
        GcodeExecuteWait(string.format("G43 H%d", requested))
    end
    
    SetBootState()

    -- Restore FRO and RRO to saved values
    mc.mcCntlSetFRO(inst, savedFRO)
    mc.mcCntlSetRRO(inst, savedRRO)

    -- Clear M6 in-progress flag
    mc.mcCntlSetPoundVar(inst, 499, 0)

    return 0
end


function ProbeScripts.ProbeZ(inst)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Build dialog
    local fields = {
        {type = "instructions", text = "Probe downward (-Z) to find surface"},
        {type = "separator"},
        
        {type = "radio", key = "action", label = "Action:",
         options = {"Set Z Datum at Surface", "Display Probed Position"},
         default = 0},
    }

    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Z Probe", fields, "SimpleZProbe")
    
    if not params then return end

    -- Perform probe with return to start
    local setDatum = (params.action == 0)
    local edgeWork, success = ProbeScripts.Probe(inst, 5, setDatum, true, nil, nil, false, nil)

    if not success then
        mc.mcCntlSetLastError(inst, "Z Probe failed")
        return
    end
    
    -- Display results if not setting datum
    if params.action == 1 then
        local edgeMachine = mc.mcCntlGetPoundVar(inst, 391)
        local results = {
            MachineZ = edgeMachine,
            WorkZ = edgeWork
        }
        ProbeScripts.DisplayResults(inst, results, "Z Probe Results", {
            statusFormat = "Z Probe: Machine={MachineZ} Work={WorkZ}",
            showDetails = true
        })
    end
end


function ProbeScripts.ProbeXY(inst)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end
    
    -- Build dialog
    local fields = {
        {type = "instructions", text = "Select probe direction and action"},
        {type = "separator"},
        
        {type = "direction", key = "direction", 
         label = "Probe Direction:",
         tooltip = "Select the direction to probe from current position",
         default = 0},  -- Default to +X
        
        {type = "separator"},
        
        {type = "radio", key = "action", 
         label = "Action:",
         options = {"Set Datum", "Set/Center", "Show Position"},
         columns = 3,  -- Display all options on one line
         tooltip = "Set Datum: Zero at edge | Set/Center: Zero between two edges | Show Position: Display only",
         default = 0}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "XY Probe", fields, "SimpleXYProbe")
    
    if not params then return end

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end
    
    -- Map dialog direction (0=+X, 1=-X, 2=+Y, 3=-Y) to ProbeXYZ direction (1=+X, 2=-X, 3=+Y, 4=-Y)
    local ProbeXYZDirection = params.direction + 1
    
    -- Determine axis info
    local isXAxis = (ProbeXYZDirection <= 2)
    local axisLetter = isXAxis and "X" or "Y"
    local axisNum = isXAxis and 0 or 1  -- For GetPos: 0=X, 1=Y
    local directionSign = ((ProbeXYZDirection == 1) or (ProbeXYZDirection == 3)) and "+" or "-"
    
    -- Handle Set/Center datum option
    if params.action == 1 then  -- Set/Center
        -- Determine which PV to use (300 for X, 301 for Y)
        local pv = isXAxis and 300 or 301
        local storedPosMachine = mc.mcCntlGetPoundVar(inst, pv)

        -- Check if we have a stored position for this axis
        if storedPosMachine ~= 0 then
            -- Second call for this axis - calculate center and set datum

            -- Probe the edge
            local edgeWork, success = ProbeScripts.Probe(inst, ProbeXYZDirection, false, true, nil, nil, false, nil)

            if not success then
                mc.mcCntlSetLastError(inst, string.format("%s%s Probe failed - no contact detected", directionSign, axisLetter))
                return
            end

            -- Get the machine position of this probe
            local edgeMachine = mc.mcCntlGetPoundVar(inst, 391)

            -- Calculate center in machine coordinates
            local centerMachine = (storedPosMachine + edgeMachine) / 2
            local width = math.abs(storedPosMachine - edgeMachine)

            -- Get current machine position
            local currentMachine = mc.mcAxisGetMachinePos(inst, axisNum)

            -- Calculate the offset from current position to center (matching ScreenLoad logic)
            local workOffset = centerMachine - currentMachine

            -- Set datum at center (matching ScreenLoad SetCenter approach)
            mc.mcAxisSetPos(inst, axisNum, -workOffset)

            -- Clear the PV
            mc.mcCntlSetPoundVar(inst, pv, 0)

            -- Get current work offset
            local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
            local offsetNum = 54
            if modalOffset >= 54 and modalOffset <= 59 then
                offsetNum = math.floor(modalOffset + 0.5)
            end

            -- Display results
            local results = {
                Width = width,
                CenterMachine = centerMachine,
                Edge1Machine = storedPosMachine,
                Edge2Machine = edgeMachine
            }

            ProbeScripts.DisplayResults(inst, results, "Center Set Results", {
                statusFormat = string.format("G%d %s0 set at center (machine %.4f), Width=%.4f",
                                           offsetNum, axisLetter, centerMachine, width),
                showDetails = false
            })

        else
            -- First call for this axis - store position and end

            -- Probe the edge
            local edgeWork, success = ProbeScripts.Probe(inst, ProbeXYZDirection, false, true, nil, nil, false, nil)

            if not success then
                mc.mcCntlSetLastError(inst, string.format("%s%s Probe failed - no contact detected", directionSign, axisLetter))
                return
            end

            -- Store the machine position in the PV
            local edgeMachine = mc.mcCntlGetPoundVar(inst, 391)
            mc.mcCntlSetPoundVar(inst, pv, edgeMachine)

            -- Notify user
            mc.mcCntlSetLastError(inst, string.format("%s: First point set at machine %.4f - Move to opposite edge and run again",
                                                      axisLetter, edgeMachine))

            -- Display simple result
            local results = {
                ["Machine" .. axisLetter] = edgeMachine,
                ["Work" .. axisLetter] = edgeWork,
                Status = "First edge stored"
            }

            ProbeScripts.DisplayResults(inst, results, "Set/Center - First Edge", {
                statusFormat = string.format("%s first edge at machine %.4f - Ready for second edge",
                                           axisLetter, edgeMachine),
                showDetails = false
            })
        end

    else
        -- Original edge probe or display position
        local setDatum = (params.action == 0)
        local edgeWork, success = ProbeScripts.Probe(inst, ProbeXYZDirection, setDatum, true, nil, nil, false, nil)
        
        if not success then
            mc.mcCntlSetLastError(inst, string.format("%s%s Probe failed - no contact detected", directionSign, axisLetter))
            return
        end
        
        -- Display results if not setting datum
        if params.action == 2 then  -- Display position (action index shifted due to new option)
            local edgeMachine = mc.mcCntlGetPoundVar(inst, 391)
            local results = {
                ["Machine" .. axisLetter] = edgeMachine,
                ["Work" .. axisLetter] = edgeWork,
                Direction = directionSign .. axisLetter
            }
            
            ProbeScripts.DisplayResults(inst, results, "XY Probe Results", {
                statusFormat = string.format("%s Probe: Machine={Machine%s} Work={Work%s}", 
                                            directionSign .. axisLetter, axisLetter, axisLetter),
                showDetails = true
            })
        end
    end
end



function ProbeScripts.ProbeOutsideCenter(inst)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end
    
    -- Build dialog
    local fields = {
        {type = "instructions", text = "Position probe above center of stock.\nProbe will find top surface, then measure edges."},
        {type = "separator"},
        
        {type = "grid", columns = 2, spacing = 15, children = {
            {type = "number", key = "traverseHeight", label = "Traverse:",
             width = 60,
             default = 0.5,
             tooltip = "Height above surface for safe rapid moves",
             min = 0.001,
             max = 10,
             validateMsg = "Must be between 0-10"},

            {type = "number", key = "dropHeight", label = "Z Drop:",
             width = 60,
             default = 0.1,
             tooltip = "Distance to drop below surface for edge probing",
             min = 0.001,
             max = 2,
             validateMsg = "Must be between 0-2"}
        }},
        
        {type = "separator"},
        
        {type = "grid", columns = 2, spacing = 15, children = {
            {type = "number", key = "xWidth", label = "X Width:",
             width = 60,
             default = 0,
             tooltip = "Expected width in X direction (0 to skip)",
             min = 0,
             max = 100,
             validateMsg = "Must be between 0-100"},

            {type = "number", key = "yWidth", label = "Y Width:",
             width = 60,
             default = 0,
             tooltip = "Expected width in Y direction (0 to skip)",
             min = 0,
             max = 100,
             validateMsg = "Must be between 0-100"}
        }},
        
        {type = "separator"},
        
        {type = "checkbox", key = "setZDatum", label = "Set Z Datum at Surface", 
         default = 1,
         tooltip = "Zero the Z axis at the probed surface"},
         
        {type = "checkbox", key = "moveToCenter", 
         label = "Move to Center",
         default = 0,
         tooltip = "Move to the calculated center position after probing"}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Outside Center Probe", fields, "ProbeOutsideCenter")
    if not params then return end

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end
    
    -- Validate at least one axis has width
    if params.xWidth <= 0 and params.yWidth <= 0 then
        wx.wxMessageBox("At least one axis must have a width greater than 0", 
                       "Invalid Parameters", 
                       wx.wxOK + wx.wxICON_ERROR)
        return
    end
    
    -- First probe down to find surface
    local surfaceWork, zSuccess = ProbeScripts.Probe(inst, 5, params.setZDatum, false, nil, nil, false, params.traverseHeight)
    
    if not zSuccess then
        mc.mcCntlSetLastError(inst, "Z Probe failed - no surface detected")
        return
    end
    
    local results = {}
    
    -- Helper function to probe an axis (returns center and width, doesn't set datum)
    local function probeAxis(axisLetter, width, dir1, dir2)
        local edge1 = ProbeScripts.ProbeOutside(inst, dir1, width / 2, params.traverseHeight + params.dropHeight)
        if not edge1 then return nil, nil end

        local edge2 = ProbeScripts.ProbeOutside(inst, dir2, width / 2, params.traverseHeight + params.dropHeight)
        if not edge2 then return nil, nil end

        return (edge1 + edge2) / 2, math.abs(edge1 - edge2)
    end

    -- Probe and store results
    local xCenter, xWidth, yCenter, yWidth

    if params.xWidth > 0 then
        xCenter, xWidth = probeAxis("X", params.xWidth, 2, 1)  -- 2=-X, 1=+X
        if not xCenter then return end
    end

    if params.yWidth > 0 then
        yCenter, yWidth = probeAxis("Y", params.yWidth, 4, 3)  -- 4=-Y, 3=+Y
        if not yCenter then return end
    end
    
    -- All probing successful, set datums
    if xCenter then
        local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
        mc.mcAxisSetPos(inst, mc.X_AXIS, currentXPos - xCenter)
        results.X = "0 at center"
        results.XWidth = xWidth
    end
    
    if yCenter then
        local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
        mc.mcAxisSetPos(inst, mc.Y_AXIS, currentYPos - yCenter)
        results.Y = "0 at center"
        results.YWidth = yWidth
    end
    
    -- Display final results
    local statusMsg = "Center set:"
    
    if params.setZDatum then
        results.Z = "0 at surface"
        statusMsg = statusMsg .. " Z=0"
    end
    
    if results.XWidth then
        statusMsg = statusMsg .. string.format(" X=0 (W=%.4f)", results.XWidth)
    end
    
    if results.YWidth then
        statusMsg = statusMsg .. string.format(" Y=0 (W=%.4f)", results.YWidth)
    end
    
    ProbeScripts.DisplayResults(inst, results, "Outside Center Probe Complete", {
        statusFormat = statusMsg,
        showDetails = false
    })

    -- Move to center if requested (only for axes that were probed)
    if params.moveToCenter then
        local moveX = (params.xWidth > 0)  -- Move X if it was probed
        local moveY = (params.yWidth > 0)  -- Move Y if it was probed
        ProbeScripts.MoveToCenter(inst, moveX, moveY)

        local movedAxes = {}
        if moveX then table.insert(movedAxes, "X") end
        if moveY then table.insert(movedAxes, "Y") end
    end
end


function ProbeScripts.ProbeInsideCenter(inst)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end
    
    -- Build dialog
    local fields = {
        {type = "instructions", text = "Position probe at approximate center of pocket/bore.\nProbe will find edges and set datum at calculated center."},
        {type = "separator"},
        
        {type = "radio", key = "axes", 
         label = "Probe Axes:",
         options = {"X Only", "Y Only", "X and Y"},
         columns = 3,
         default = 2},  -- Default to both axes
         
        {type = "checkbox", key = "moveToCenter", 
         label = "Move to Center",
         default = 0,
         tooltip = "Move to the calculated center position after probing"}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Inside Center Probe", fields, "ProbeInsideCenter")
    
    if not params then return end

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end
    
    local probeX = (params.axes == 0 or params.axes == 2)
    local probeY = (params.axes == 1 or params.axes == 2)
    
    local results = {}
    local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
    local offsetNum = 54
    if modalOffset >= 54 and modalOffset <= 59 then
        offsetNum = math.floor(modalOffset + 0.5)
    end
    
    -- Probe X axis if selected
    if probeX then
        -- Probe +X direction (1), returns to start automatically
        local xEdge1Work, success1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)

        if not success1 then
            mc.mcCntlSetLastError(inst, "+X Probe failed - no contact detected")
            return
        end

        -- Probe -X direction (2), returns to start automatically
        local xEdge2Work, success2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)

        if not success2 then
            mc.mcCntlSetLastError(inst, "-X Probe failed - no contact detected")
            return
        end
        
        -- Calculate center and width
        local xCenter = (xEdge1Work + xEdge2Work) / 2
        local xWidth = math.abs(xEdge1Work - xEdge2Work)
        
        -- Set X datum at center (without moving)
        local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
        local newXPosition = currentXPos - xCenter
        mc.mcAxisSetPos(inst, mc.X_AXIS, newXPosition)
        
        results.XWidth = xWidth
        results.XCenter = 0  -- Now at center
    end
    
    -- Probe Y axis if selected
    if probeY then
        -- Probe +Y direction (3), returns to start automatically
        local yEdge1Work, success1 = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)

        if not success1 then
            mc.mcCntlSetLastError(inst, "+Y Probe failed - no contact detected")
            return
        end

        -- Probe -Y direction (4), returns to start automatically
        local yEdge2Work, success2 = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)

        if not success2 then
            mc.mcCntlSetLastError(inst, "-Y Probe failed - no contact detected")
            return
        end
        
        -- Calculate center and width
        local yCenter = (yEdge1Work + yEdge2Work) / 2
        local yWidth = math.abs(yEdge1Work - yEdge2Work)
        
        -- Set Y datum at center (without moving)
        local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
        local newYPosition = currentYPos - yCenter
        mc.mcAxisSetPos(inst, mc.Y_AXIS, newYPosition)
        
        results.YWidth = yWidth
        results.YCenter = 0  -- Now at center
    end
    
    -- Build status message
    local statusMsg = string.format("G%d set:", offsetNum)
    
    if results.XWidth then
        statusMsg = statusMsg .. string.format(" X=0 (Width=%.4f)", results.XWidth)
    end
    
    if results.YWidth then
        statusMsg = statusMsg .. string.format(" Y=0 (Width=%.4f)", results.YWidth)
    end
    
    -- Display results
    ProbeScripts.DisplayResults(inst, results, "Inside Center Probe Complete", {
        statusFormat = statusMsg,
        showDetails = false
    })

    -- Move to center if requested (only for axes that were probed)
    if params.moveToCenter then
        local moveX = probeX  -- Move X if it was probed
        local moveY = probeY  -- Move Y if it was probed
        ProbeScripts.MoveToCenter(inst, moveX, moveY)

        local movedAxes = {}
        if moveX then table.insert(movedAxes, "X") end
        if moveY then table.insert(movedAxes, "Y") end
    end
end


function ProbeScripts.FindAngle(inst)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    local lastTraverseDistance = mc.mcProfileGetDouble(inst, "ProbeFindAngle", "traverseDistance", 1.0)
    
    -- Build dialog
    local fields = {
        {type = "instructions", text = "Probe two points to find part angle.\nFirst probe, traverse, second probe, then calculate angle."},
        {type = "separator"},
        
        {type = "direction", key = "probeDirection", 
        label = "Probe Direction:",
        tooltip = "Direction to probe for both measurements",
        default = 0},  -- Default to +X
        
        {type = "direction", key = "traverseDirection", 
        label = "Traverse Direction:",
        tooltip = "Direction to move between probe points (must be perpendicular)",
        default = 2},  -- Default to +Y
        
        {type = "separator"},
        
        {type = "number", key = "traverseDistance",
         label = "Traverse Distance:",
         default = lastTraverseDistance,
         tooltip = "Distance to move in traverse direction between probes",
         min = 0.001,
         max = 50,
         validateMsg = "Must be between 0-50"}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Find Angle", fields, "ProbeFindAngle")
    
    if not params then return end

    -- Validate directions are perpendicular
    local probeIsX = (params.probeDirection <= 1)
    local traverseIsX = (params.traverseDirection <= 1)

    if probeIsX == traverseIsX then
        wx.wxMessageBox("Probe and traverse directions must be perpendicular!\n\nPlease select different axes.",
                    "Invalid Selection", wx.wxOK + wx.wxICON_ERROR)
        return ProbeScripts.FindAngle(inst)  -- Restart dialog
    end

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end

    mc.mcProfileWriteDouble(inst, "ProbeFindAngle", "traverseDistance", params.traverseDistance)
    mc.mcProfileFlush(inst)

    -- Map dialog directions to ProbeXYZ directions
    local ProbeXYZProbeDir = params.probeDirection + 1
    local ProbeXYZTraverseDir = params.traverseDirection + 1

    local axisInfo = {
        [1] = {axis = mc.X_AXIS, letter = "X", sign = 1},
        [2] = {axis = mc.X_AXIS, letter = "X", sign = -1},
        [3] = {axis = mc.Y_AXIS, letter = "Y", sign = 1},
        [4] = {axis = mc.Y_AXIS, letter = "Y", sign = -1}
    }
    
    local probeInfo = axisInfo[ProbeXYZProbeDir]
    local traverseInfo = axisInfo[ProbeXYZTraverseDir]
    
    -- Store original position in machine coordinates
    local startX = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local startY = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
    
    -- First probe
    local probe1Work, success1 = ProbeScripts.Probe(inst, ProbeXYZProbeDir, false, true, nil, nil, false, nil)
    
    if not success1 or probe1Work == nil then
        mc.mcCntlSetLastError(inst, string.format("First probe failed in %s%s direction", 
                                                  probeInfo.sign > 0 and "+" or "-", 
                                                  probeInfo.letter))
        return
    end
    
    -- Protected traverse to second position using ProtectedMove
    local traverseX = (traverseInfo.letter == "X") and (startX + traverseInfo.sign * params.traverseDistance) or startX
    local traverseY = (traverseInfo.letter == "Y") and (startY + traverseInfo.sign * params.traverseDistance) or startY

    if not ProbeScripts.ProtectedMove(inst, "mach", traverseX, traverseY, nil, 200) then
        -- Return to original start position
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f", startX, startY))
        mc.mcCntlSetLastError(inst, "Traverse collision detected - check clearance")
        return
    end

    -- Second probe
    local probe2Work, success2 = ProbeScripts.Probe(inst, ProbeXYZProbeDir, false, true, nil, nil, false, nil)
    
    if not success2 then
        -- Return to original start on failure
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f", startX, startY))
        mc.mcCntlSetLastError(inst, string.format("Second probe failed in %s%s direction", 
                                                  probeInfo.sign > 0 and "+" or "-", 
                                                  probeInfo.letter))
        return
    end

    -- Return to original starting position
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 X%.4f Y%.4f", startX, startY))

    -- Calculate the angle (account for traverse direction sign)
    local probeDifference = probe2Work - probe1Work
    local angleRadians = math.atan(probeDifference / (traverseInfo.sign * params.traverseDistance))
    local angleDegrees = angleRadians * (180 / math.pi)
    
    -- Normalize angle to (-180, 180)
    local function normalize180(angle)
        angle = angle % 360
        if angle > 180 then
            angle = angle - 360
        elseif angle <= -180 then
            angle = angle + 360
        end
        return angle
    end

    -- Determine which axis the edge is nearest to
    local function findNearestAxis(angle)
        angle = normalize180(angle)
        
        -- Calculate smallest signed difference to each reference
        local refs = {
            {0, "X"}, {180, "X"}, {-180, "X"},
            {90, "Y"}, {-90, "Y"}
        }
        
        local bestDiff, bestAxis, bestRef = 999, "", 0
        for _, ref in ipairs(refs) do
            local diff = normalize180(angle - ref[1])
            if math.abs(diff) < math.abs(bestDiff) then
                bestDiff = diff
                bestAxis = ref[2]
                bestRef = ref[1]
            end
        end
        
        -- Determine sign for axis label
        local axisLabel = bestAxis
        if bestAxis == "X" and math.abs(bestRef) > 90 then
            axisLabel = "-X"
        elseif bestAxis == "X" then
            axisLabel = "+X"
        elseif bestRef < 0 then
            axisLabel = "-Y"
        else
            axisLabel = "+Y"
        end
        
        return axisLabel, bestDiff
    end
    
    -- Account for which axes are being used for probe and traverse
    local machineAngle = angleDegrees
    
    -- Adjust for Y traverse (rotate 90Â°)
    if traverseInfo.letter == "Y" then
        machineAngle = angleDegrees + 90
    end
    
    machineAngle = normalize180(machineAngle)

    
    -- Find nearest axis and angle from it
    local nearestAxis, angleFromAxis = findNearestAxis(machineAngle)
    
    -- Format the angle display
    local angleDisplay = string.format("Edge is %.3fÂ° from %s axis", math.abs(angleFromAxis), nearestAxis)
    
    -- Build description
    local angleDescription = string.format("%s\n\nProbe difference: %.4f %s\nTraverse distance: %.4f %s",
                                          angleDisplay, math.abs(probeDifference), probeInfo.letter,
                                          params.traverseDistance, traverseInfo.letter)
    
    -- Show results dialog with apply option
    local axisCore = nearestAxis:match("[XY]")  -- "X" or "Y"
    local rAngle = (axisCore == "Y") and -angleFromAxis or angleFromAxis

    local resultFields = {
        {type = "instructions", text = angleDescription},
        {type = "separator"},
        {type = "description", key = "rotateInfo",
        text = string.format("Apply G68 rotation of %.4f degrees to align with %s?",
                            rAngle, nearestAxis)}
    }


    local resultParams = ProbeScripts.ShowDialog(inst, "Angle Found", resultFields,
                                                 "ProbeFindAngleResult",
                                                 {ok = "Apply Rotation", cancel = "Cancel"})

    if resultParams then
        -- Apply G68 rotation
        local rotateCmd = string.format("G68 X0 Y0 R%.4f", rAngle)
        mc.mcCntlGcodeExecuteWait(inst, rotateCmd)
        mc.mcCntlSetLastError(inst, string.format("Rotation applied: %.4fÂ° to align with %s", 
                                                  rAngle, nearestAxis))
    else
        mc.mcCntlSetLastError(inst, string.format("Found: %.3fÂ° from %s (rotation not applied)", 
                                                  math.abs(angleFromAxis), nearestAxis))
    end
end



function ProbeScripts.CalibrateProbeDiameter(inst)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Get last used reference diameters from profile
    local lastBossDiameter = mc.mcProfileGetDouble(inst, "ProbeCalibration", "bossDiameter", 2.0)
    local lastBoreDiameter = mc.mcProfileGetDouble(inst, "ProbeCalibration", "boreDiameter", 1.0)
    local lastLiftHeight = mc.mcProfileGetDouble(inst, "ProbeCalibration", "liftHeight", 0.5)

    -- Build dialog
    local fields = {
        {type = "instructions", text = "Position probe inside the bore at desired calibration height."},
        {type = "instructions", text = "The bore and boss must be concentric for accurate calibration."},
        {type = "separator"},

        {type = "number", key = "boreDiameter",
         label = "Bore Reference Diameter:",
         default = lastBoreDiameter,
         tooltip = "Known inner diameter of the calibration bore",
         min = 0.001,
         max = 10,
         validateMsg = "Must be between 0-10"},

        {type = "number", key = "bossDiameter",
         label = "Boss Reference Diameter:",
         default = lastBossDiameter,
         tooltip = "Known outer diameter of the calibration boss",
         min = 0.001,
         max = 10,
         validateMsg = "Must be between 0-10"},

        {type = "number", key = "liftHeight",
         label = "Z Lift Height:",
         default = lastLiftHeight,
         tooltip = "Height to lift Z before moving out for boss probing",
         min = 0.001,
         max = 2,
         validateMsg = "Must be between 0-2"}
    }

    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Calibrate Probe Diameter", fields, "ProbeCalibration")
    if not params then return end

    -- Validate that bore is smaller than boss
    if params.boreDiameter >= params.bossDiameter then
        mc.mcCntlSetLastError(inst, "Error: Bore diameter must be smaller than boss diameter")
        return
    end

    -- Save reference diameters to profile
    mc.mcProfileWriteDouble(inst, "ProbeCalibration", "bossDiameter", params.bossDiameter)
    mc.mcProfileWriteDouble(inst, "ProbeCalibration", "boreDiameter", params.boreDiameter)
    mc.mcProfileWriteDouble(inst, "ProbeCalibration", "liftHeight", params.liftHeight)
    mc.mcProfileFlush(inst)

    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end

    -- Set probe diameters to 0 for calibration
    mc.mcCntlSetPoundVar(inst, 511, 0)
    mc.mcCntlSetPoundVar(inst, 512, 0)
    mc.mcCntlSetPoundVar(inst, 513, 0)
    mc.mcCntlSetPoundVar(inst, 514, 0)

    -- Store starting Z position (machine coordinates)
    local startZMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    mc.mcCntlSetLastError(inst, "Starting BORE calibration...")

    -- First probe X to get centered for Y probing
    -- Using Probe wrapper: (direction, setDatum, returnToStart, maxTravel, fastFeed, singleTap, finalRetract)
    -- returnToStart=true with finalRetract=0 to properly return to starting position
    local boreXPlus1, xPlusSuccess1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, 0)
    if not xPlusSuccess1 then
        mc.mcCntlSetLastError(inst, "Bore +X probe failed")
        return
    end

    local boreXMinus1, xMinusSuccess1 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, 0)
    if not xMinusSuccess1 then
        mc.mcCntlSetLastError(inst, "Bore -X probe failed")
        return
    end

    -- Move to X center
    local xCenterBore = (boreXPlus1 + boreXMinus1) / 2
    local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local xOffset = xCenterBore - currentXPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 X%.4f F200", xOffset))

    -- Probe bore Y (now centered in X)
    local boreYPlus, yPlusSuccess = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, 0)
    if not yPlusSuccess then
        mc.mcCntlSetLastError(inst, "Bore +Y probe failed")
        return
    end

    local boreYMinus, yMinusSuccess = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, 0)
    if not yMinusSuccess then
        mc.mcCntlSetLastError(inst, "Bore -Y probe failed")
        return
    end

    -- Move to Y center
    local yCenterBore = (boreYPlus + boreYMinus) / 2
    local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    local yOffset = yCenterBore - currentYPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 Y%.4f F200", yOffset))

    -- Final bore X probing (now centered in Y)
    local boreXPlus2, xPlusSuccess2 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, 0)
    if not xPlusSuccess2 then
        mc.mcCntlSetLastError(inst, "Final bore +X probe failed")
        return
    end

    local boreXMinus2, xMinusSuccess2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, 0)
    if not xMinusSuccess2 then
        mc.mcCntlSetLastError(inst, "Final bore -X probe failed")
        return
    end

    -- Calculate bore widths
    local boreXWidth = math.abs(boreXPlus2 - boreXMinus2)
    local boreYWidth = math.abs(boreYPlus - boreYMinus)

    mc.mcCntlSetLastError(inst, "Starting BOSS calibration...")

    -- Lift Z by liftHeight
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G0 Z%.4f", params.liftHeight))

    -- Calculate traverse distance for boss
    local bossTraverseDistance = params.bossDiameter / 2 + 0.5

    -- BOSS PROBING SEQUENCE
    -- First probe boss X to get centered
    local bossXMinus1 = ProbeScripts.ProbeOutside(inst, 2, bossTraverseDistance, params.liftHeight)
    if not bossXMinus1 then
        mc.mcCntlSetLastError(inst, "Boss -X probe failed")
        return
    end

    local bossXPlus1 = ProbeScripts.ProbeOutside(inst, 1, bossTraverseDistance, params.liftHeight)
    if not bossXPlus1 then
        mc.mcCntlSetLastError(inst, "Boss +X probe failed")
        return
    end

    -- Move to X center
    local xCenterBoss = (bossXMinus1 + bossXPlus1) / 2
    local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local xOffset = xCenterBoss - currentXPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 X%.4f F200", xOffset))

    -- Probe boss Y (now centered in X)
    local bossYMinus = ProbeScripts.ProbeOutside(inst, 4, bossTraverseDistance, params.liftHeight)
    if not bossYMinus then
        mc.mcCntlSetLastError(inst, "Boss -Y probe failed")
        return
    end

    local bossYPlus = ProbeScripts.ProbeOutside(inst, 3, bossTraverseDistance, params.liftHeight)
    if not bossYPlus then
        mc.mcCntlSetLastError(inst, "Boss +Y probe failed")
        return
    end

    -- Move to Y center
    local yCenterBoss = (bossYMinus + bossYPlus) / 2
    local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    local yOffset = yCenterBoss - currentYPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 Y%.4f F200", yOffset))

    -- Final boss X probing (now centered in Y)
    local bossXMinus2 = ProbeScripts.ProbeOutside(inst, 2, bossTraverseDistance, params.liftHeight)
    if not bossXMinus2 then
        mc.mcCntlSetLastError(inst, "Final boss -X probe failed")
        return
    end

    local bossXPlus2 = ProbeScripts.ProbeOutside(inst, 1, bossTraverseDistance, params.liftHeight)
    if not bossXPlus2 then
        mc.mcCntlSetLastError(inst, "Final boss +X probe failed")
        return
    end

    -- Calculate boss widths
    local bossXWidth = math.abs(bossXPlus2 - bossXMinus2)
    local bossYWidth = math.abs(bossYPlus - bossYMinus)

    -- Return to original Z height
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G53 G0 Z%.4f", startZMachine))

    -- Calculate individual probe diameters for each direction
    -- Since bore and boss are concentric, the difference between corresponding measurements
    -- in each direction directly gives us the probe diameter for that direction

    -- For bore (inside probing):
    --   Measured position = True edge position - probe radius
    -- For boss (outside probing):
    --   Measured position = True edge position + probe radius

    -- Therefore, for each direction:
    --   boss_measured - bore_measured = (true_edge + probe_radius) - (true_edge - probe_radius)
    --                                  = 2 * probe_radius + (boss_radius - bore_radius)

    -- So: probe_diameter = (boss_measured - bore_measured) - (boss_radius - bore_radius)

    local bossRadius = params.bossDiameter / 2
    local boreRadius = params.boreDiameter / 2
    local radiusDifference = bossRadius - boreRadius

    -- Calculate probe diameter for each direction
    -- +X direction
    local probeDiamPlusX = (bossXPlus2 - boreXPlus2) - radiusDifference

    -- -X direction
    local probeDiamMinusX = (boreXMinus2 - bossXMinus2) - radiusDifference

    -- +Y direction
    local probeDiamPlusY = (bossYPlus - boreYPlus) - radiusDifference

    -- -Y direction
    local probeDiamMinusY = (boreYMinus - bossYMinus) - radiusDifference

    -- Store the calculated probe diameters in PVs 511-514
    mc.mcCntlSetPoundVar(inst, 511, probeDiamPlusX)   -- +X
    mc.mcCntlSetPoundVar(inst, 512, probeDiamMinusX)  -- -X
    mc.mcCntlSetPoundVar(inst, 513, probeDiamPlusY)   -- +Y
    mc.mcCntlSetPoundVar(inst, 514, probeDiamMinusY)  -- -Y

    -- Save to profile
    mc.mcProfileWriteDouble(inst, "SystemSettings", "PV511", probeDiamPlusX)
    mc.mcProfileWriteDouble(inst, "SystemSettings", "PV512", probeDiamMinusX)
    mc.mcProfileWriteDouble(inst, "SystemSettings", "PV513", probeDiamPlusY)
    mc.mcProfileWriteDouble(inst, "SystemSettings", "PV514", probeDiamMinusY)
    mc.mcProfileFlush(inst)

    -- Display results
    mc.mcCntlSetLastError(inst, string.format("Probe Calibration Complete:"))
    mc.mcCntlSetLastError(inst, string.format("  +X Diameter: %.4f\"", probeDiamPlusX))
    mc.mcCntlSetLastError(inst, string.format("  -X Diameter: %.4f\"", probeDiamMinusX))
    mc.mcCntlSetLastError(inst, string.format("  +Y Diameter: %.4f\"", probeDiamPlusY))
    mc.mcCntlSetLastError(inst, string.format("  -Y Diameter: %.4f\"", probeDiamMinusY))

    -- Also display the measured vs actual widths for verification
    mc.mcCntlSetLastError(inst, string.format("Bore X Width: Measured=%.4f\" Actual=%.4f\"", boreXWidth, params.boreDiameter))
    mc.mcCntlSetLastError(inst, string.format("Bore Y Width: Measured=%.4f\" Actual=%.4f\"", boreYWidth, params.boreDiameter))
    mc.mcCntlSetLastError(inst, string.format("Boss X Width: Measured=%.4f\" Actual=%.4f\"", bossXWidth, params.bossDiameter))
    mc.mcCntlSetLastError(inst, string.format("Boss Y Width: Measured=%.4f\" Actual=%.4f\"", bossYWidth, params.bossDiameter))

    return probeDiamPlusX, probeDiamMinusX, probeDiamPlusY, probeDiamMinusY
end

-- Probe Tool Position - Measures pull stud position and saves to tool table
function ProbeScripts.ProbeToolPosition(inst)
    -- Check probe is deployed
    if not ProbeScripts.CheckProbeDeployed(inst) then return end
    if not ProbeScripts.CheckG68Rotation(inst) then return end

    -- Hardcoded parameters for pull stud
    local pullStudWidth = 1.0
    local traverseHeight = 0.2
    local holderTaperHeight = 2.8
    local holderDropHeight = 0.1
    local traverseFeedrate = 50

    -- Build dialog to get tool number
    local fields = {
        {type = "instructions", text = "Position probe directly over the pull stud of the tool holder.\nThis will measure and save the tool's XYZ position in the tool table."},
        {type = "separator"},

        {type = "number", key = "toolNumber",
         label = "Tool Number:",
         width = 60,
         default = 1,
         isInteger = true,
         min = 1,
         max = 89,
         validateMsg = "Must be 1-89 (90+ are reserved for virtual tools)",
         tooltip = "Enter the tool number for this position (1-89)"}
    }

    local params = ProbeScripts.ShowDialog(inst, "Probe Tool Position", fields, "ProbeToolPosition")
    if not params then return end
    local toolNum = params.toolNumber

    mc.mcCntlSetLastError(inst, string.format("Probing tool T%d position...", toolNum))

    -- First probe down to find the top surface of the pull stud
    local surfaceWork, zSuccess = ProbeScripts.Probe(inst, 5, false, false, nil, nil, false, traverseHeight)
    if not zSuccess then
        mc.mcCntlSetLastError(inst, "Failed to find pull stud surface")
        return false
    end

    -- Get the latched probe Z position for accuracy
    local surfaceZMachine = mc.mcAxisGetProbePos(inst, mc.Z_AXIS, 1)  -- 1 = machine coords

    -- Probe pull stud XY position
    local dropHeight = traverseHeight + holderDropHeight

    local xPlusResult = ProbeScripts.ProbeOutside(inst, 1, pullStudWidth/2, dropHeight, traverseFeedrate)  -- 1 = +X
    if not xPlusResult then
        mc.mcCntlSetLastError(inst, "Failed to probe +X edge")
        return false
    end

    local xMinusResult = ProbeScripts.ProbeOutside(inst, 2, pullStudWidth/2, dropHeight, traverseFeedrate)  -- 2 = -X
    if not xMinusResult then
        mc.mcCntlSetLastError(inst, "Failed to probe -X edge")
        return false
    end

    local yPlusResult = ProbeScripts.ProbeOutside(inst, 3, pullStudWidth/2, dropHeight, traverseFeedrate)  -- 3 = +Y
    if not yPlusResult then
        mc.mcCntlSetLastError(inst, "Failed to probe +Y edge")
        return false
    end

    local yMinusResult = ProbeScripts.ProbeOutside(inst, 4, pullStudWidth/2, dropHeight, traverseFeedrate)  -- 4 = -Y
    if not yMinusResult then
        mc.mcCntlSetLastError(inst, "Failed to probe -Y edge")
        return false
    end

    -- Calculate center from probed edges
    local centerX = (xPlusResult + xMinusResult) / 2
    local centerY = (yPlusResult + yMinusResult) / 2

    -- Move probe to center of pull stud
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F100", centerX, centerY))

    -- Get the probe's position in machine coordinates at center
    local probeXMachine = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
    local probeYMachine = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)

    -- Calculate spindle position when probe is at center
    local probeXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90)
    local probeYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90)
    local centerXMachine = probeXMachine - probeXOffset
    local centerYMachine = probeYMachine - probeYOffset

    -- Calculate Z pickup height
    local probeHeight = mc.mcToolGetData(inst, mc.MTOOL_MILL_HEIGHT, 90)
    local zPickupHeight = surfaceZMachine - probeHeight - holderTaperHeight

    -- Save tool position to tool table
    mc.mcToolSetDataExDbl(inst, toolNum, "XToolChange", centerXMachine)
    mc.mcToolSetDataExDbl(inst, toolNum, "YToolChange", centerYMachine)
    mc.mcToolSetDataExDbl(inst, toolNum, "ZToolChange", zPickupHeight)

    -- Save tool table
    mc.mcToolSaveFile(inst)

    mc.mcCntlSetLastError(inst, string.format("T%d position saved: X%.4f Y%.4f Z%.4f",
        toolNum, centerXMachine, centerYMachine, zPickupHeight))

    return true
end

function ProbeScripts.CalibrateProbeOffset(inst)
    if not ProbeScripts.CheckProbeDeployed(inst) then return end
    
    -- Build dialog with a checkbox to ensure proper dialog behavior
    local fields = {
        {type = "instructions", text = "Spindle must be manually centered over bore with work 0,0 set.\nPosition probe inside bore before starting.\nThis will calibrate T90 XY offsets in tool table."},
        {type = "separator"},
        {type = "checkbox", key = "confirm", label = "Ready to calibrate", default = 0}
    }
    
    -- Show dialog and get user input
    local params = ProbeScripts.ShowDialog(inst, "Calibrate Probe Offset", fields, "ProbeOffsetCalibration")
    if not params or not params.confirm then return end
    
    -- Check and handle G68 rotation
    if not ProbeScripts.CheckG68Rotation(inst) then return end
    
    -- Zero the T90 tool table XY offsets
    mc.mcToolSetData(inst, mc.MTOOL_MILL_X, 90, 0)
    mc.mcToolSetData(inst, mc.MTOOL_MILL_Y, 90, 0)
    
    -- Reload tool to apply zero offsets
    mc.mcCntlGcodeExecuteWait(inst, "G49 G43 H90")
    
    -- First X probe sequence
    local xEdge1Work, success = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    if not success then return end
    
    local xEdge2Work, success = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    if not success then return end
    
    -- Calculate X center and move there using incremental
    local xCenter = (xEdge1Work + xEdge2Work) / 2
    local xWidth = math.abs(xEdge1Work - xEdge2Work)
    local currentXPos = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local xOffset = xCenter - currentXPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 X%.4f F200", xOffset))
    
    -- Y probe sequence
    local yEdge1Work, success = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    if not success then return end
    
    local yEdge2Work, success = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
    if not success then return end
    
    -- Calculate Y center and move there using incremental
    local yCenter = (yEdge1Work + yEdge2Work) / 2
    local yWidth = math.abs(yEdge1Work - yEdge2Work)
    local currentYPos = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    local yOffset = yCenter - currentYPos
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 Y%.4f F200", yOffset))
    
    -- Second X probe sequence for refinement
    local xEdge1Work_2, success = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    if not success then return end
    
    local xEdge2Work_2, success = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    if not success then return end
    
    -- Calculate refined X center and move to final center
    local xCenterFinal = (xEdge1Work_2 + xEdge2Work_2) / 2
    local xWidthFinal = math.abs(xEdge1Work_2 - xEdge2Work_2)
    
    -- Move to final center position using incremental
    local currentXPos2 = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local xOffset2 = xCenterFinal - currentXPos2
    mc.mcCntlGcodeExecuteWait(inst, string.format("G91 G1 X%.4f F200", xOffset2))
    
    -- Get current work coordinates - these are the probe offsets
    local probeOffsetX = mc.mcAxisGetPos(inst, mc.X_AXIS)
    local probeOffsetY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
    
    -- Apply offsets to T90 tool table as-is
    mc.mcToolSetData(inst, mc.MTOOL_MILL_X, 90, probeOffsetX)
    mc.mcToolSetData(inst, mc.MTOOL_MILL_Y, 90, probeOffsetY)
    
    -- Save tool table and reload offsets
    mc.mcToolSaveFile(inst)
    mc.mcCntlGcodeExecuteWait(inst, "G49 G43 H90")
    
    -- Display results
    local message = string.format(
        "T90 Offsets Calibrated:\nX: %.4f\"\nY: %.4f\"\n\nBore Width:\nX: %.4f\"\nY: %.4f\"",
        probeOffsetX, probeOffsetY, xWidthFinal, yWidth)

    mc.mcCntlSetLastError(inst, string.format("T90 offsets set: X%.4f Y%.4f", probeOffsetX, probeOffsetY))
    
    return probeOffsetX, probeOffsetY
end


function ProbeScripts.ProbeKeys(inst)
    -- ========== PRE-CHECKS ==========

    -- Heartbeat check helper (returns true if valid, false otherwise)
    local HEARTBEAT_FILE = "C:\\Mach4Hobby\\Profiles\\BLP\\Logs\\FUSION_HEARTBEAT.txt"
    local HEARTBEAT_MAX_AGE = 30  -- seconds - allow some slack for network latency

    local function checkHeartbeat()
        local heartbeatFile = io.open(HEARTBEAT_FILE, "r")
        if not heartbeatFile then return false end

        local heartbeatTimestamp = tonumber(heartbeatFile:read("*a"))
        heartbeatFile:close()

        if not heartbeatTimestamp then return false end

        local heartbeatAge = os.time() - heartbeatTimestamp
        return heartbeatAge <= HEARTBEAT_MAX_AGE
    end

    -- First heartbeat check (silent - don't show error yet)
    local firstHeartbeatOk = checkHeartbeat()

    -- Check probe deployment
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Check front vacuum is on (OUTPUT6)
    local vacFrontHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6)
    local vacFrontState = mc.mcSignalGetState(vacFrontHandle)
    if vacFrontState ~= 1 then
        wx.wxMessageBox("Front vacuum must be ON before running ProbeKeys.\n\nPlease turn on the front vacuum and try again.",
            "Vacuum Required", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check dust collection automation is enabled (OUTPUT50 = dustAuto, OUTPUT52 = bootAuto)
    local dustAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT50)
    local dustAutoState = mc.mcSignalGetState(dustAutoHandle)
    local bootAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT52)
    local bootAutoState = mc.mcSignalGetState(bootAutoHandle)

    if dustAutoState ~= 1 or bootAutoState ~= 1 then
        local missing = {}
        if dustAutoState ~= 1 then table.insert(missing, "Dust Collect Auto") end
        if bootAutoState ~= 1 then table.insert(missing, "Dust Boot Auto") end

        local result = wx.wxMessageBox(
            "The following automation settings are not enabled:\n\nâ¢ " .. table.concat(missing, "\nâ¢ ") ..
            "\n\nIt is recommended to enable these before running ProbeKeys.\n\nContinue anyway?",
            "Automation Warning", wx.wxYES_NO + wx.wxICON_WARNING)

        if result ~= wx.wxYES then
            return
        end
    end

    mc.mcCntlGcodeExecuteWait(inst, "G55")

    -- ========== DIALOG ==========

    local fields = {
        {type = "instructions",
         text = "Enter piano information for key probing.\nKey section will be auto-detected."},
        {type = "text", key = "make", label = "Piano Make",
         default = "Steinway",
         validate = function(value)
             if value:match("_") then
                 return false, "Piano Make cannot contain underscores (_)"
             end
             if value:match("^%s*$") then
                 return false, "Piano Make cannot be empty"
             end
             return true
         end},
        {type = "text", key = "serial", label = "Serial Number",
         default = "123456",
         validate = function(value)
             if value:match("_") then
                 return false, "Serial Number cannot contain underscores (_)"
             end
             if value:match("^%s*$") then
                 return false, "Serial Number cannot be empty"
             end
             return true
         end}
    }

    local params = ProbeScripts.ShowDialog(inst, "Piano Key Probing", fields, "ProbeKeys")
    if not params then return end

    -- Second heartbeat check - only show error if both checks failed
    local secondHeartbeatOk = checkHeartbeat()
    if not firstHeartbeatOk and not secondHeartbeatOk then
        wx.wxMessageBox("Fusion 360 add-in is not running.\n\nPlease start Fusion 360, open 'Parametrized Keytop Toolpath', and enable the Keytop Parametric Update add-in before probing.",
            "Fusion Not Running", wx.wxOK + wx.wxICON_ERROR)
        return
    end

    -- Cancel any existing G68 rotation
    mc.mcCntlGcodeExecuteWait(inst, "G69")

    -- ========== CONFIGURATION ==========

    local SINGLE_TAP_FEEDRATE = 40  -- IPM for single tap probes after calibration
    local KEY_SPACING = 1.7  -- inches between white keys
    local FIRST_KEY_X = 1.75  -- X position of first key center
    local BORE_SEPARATION = 46.0  -- inches between calibration bores
    local PROBE_DROP_DEPTH = 0.05  -- uniform drop depth for X and -Y probing
    local LINEARITY_THRESHOLD = 0.01  -- maximum deviation before adding extra probe points
    local safeTraverseZ = 2.0  -- safe Z height in work coords
    local ID_HOLE_DEPTH_THRESHOLD = -0.05  -- halfway between 0 and -0.1
    local SAMPLE_KEY_INTERVAL = 6  -- probe every 6th key (1, 7, 13, 19, 25)
    local NUM_KEYS = 26  -- total white keys per section

    -- Y positions for X edge probing
    local Y_POSITIONS = {-0.95, -0.35, 0.25, 1.10, 2.75, 4.25}
    local Y_POSITIONS_EXTRA_FRONT = {-1.05, -0.65, -0.05, 0.35}
    local Y_POSITIONS_EXTRA_BACK = {0.95, 1.95, 3.55, 4.35}

    -- Lower half key index table
    local LOWER_KEYS = {
        {1, 1}, {3, 2}, {4, 3}, {6, 4}, {8, 5}, {9, 6}, {11, 7}, {13, 8},
        {15, 9}, {16, 10}, {18, 11}, {20, 12}, {21, 13}, {23, 14}, {25, 15},
        {27, 16}, {28, 17}, {30, 18}, {32, 19}, {33, 20}, {35, 21}, {37, 22},
        {39, 23}, {40, 24}, {42, 25}, {44, 26}
    }

    -- Upper half key index table
    local UPPER_KEYS = {
        {45, 1}, {47, 2}, {49, 3}, {51, 4}, {52, 5}, {54, 6}, {56, 7}, {57, 8},
        {59, 9}, {61, 10}, {63, 11}, {64, 12}, {66, 13}, {68, 14}, {69, 15},
        {71, 16}, {73, 17}, {75, 18}, {76, 19}, {78, 20}, {80, 21}, {81, 22},
        {83, 23}, {85, 24}, {87, 25}, {88, 26}
    }

    -- Storage
    local centeringHeightMachine  -- bore centering height in machine coords
    local calibrationOffsets = {}  -- single-tap calibration offsets
    local doubleResults = {}
    local singleResults = {["+X"] = {}, ["-X"] = {}, ["-Y"] = {}, ["-Z"] = {}}
    local TEST_KEYS = nil
    local keyHalfName = nil
    local traverseHeight  -- calculated after Z probing
    local probeZ  -- uniform probe depth for X and -Y

    -- Files - set after key section is determined
    local pianoFolder = nil
    local pianoName = nil
    local csvPath = nil
    local reportFile = nil

    -- Helper function to write to report
    local function writeReport(message)
        if reportFile then
            local timestamp = os.date("%Y-%m-%d %H:%M:%S")
            reportFile:write(string.format("[%s] %s\n", timestamp, message))
            reportFile:flush()
        end
    end

    -- Helper to write to CSV
    local function writeBatchToCSV(csvFile, dataPoints)
        for _, point in ipairs(dataPoints) do
            csvFile:write(string.format("%d,%d,%d,%.6f,%.6f,%.6f,%s\n",
                point.enumKey, point.pianoKey, point.direction, point.x, point.y, point.z, point.timestamp))
        end
        csvFile:flush()
    end

    -- Calculate linearity of 3 points
    local function calculateLinearity(points)
        local n = #points
        if n ~= 3 then return 0 end

        local p1 = points[1]
        local p2 = points[2]
        local p3 = points[3]

        local dx = p3.x - p1.x
        local dy = p3.y - p1.y

        if math.abs(dy) < 0.0001 then
            return math.abs(p2.x - p1.x)
        elseif math.abs(dx) < 0.000001 then
            return 0
        end

        local a = dy
        local b = -dx
        local c = dx * p1.y - dy * p1.x

        local distance = math.abs(a * p2.x + b * p2.y + c) / math.sqrt(a * a + b * b)
        return distance
    end

    -- Helper for bore center probing
    local function probeBoreCenter()
        local xEdge1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
        local xEdge2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
        local centerX = (xEdge1 + xEdge2) / 2

        local yEdge1 = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
        local yEdge2 = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
        local centerY = (yEdge1 + yEdge2) / 2

        return centerX, centerY
    end

    -- Helper to probe key side (X edges)
    local function probeKeySide(keyIndex, direction, xPosition)
        local keyInfo = TEST_KEYS[keyIndex]
        local pianoKey = keyInfo[1]
        local enumKey = keyInfo[2]
        local results = {}

        local XTolerance = 0.005
        local currentX = mc.mcAxisGetPos(inst, mc.X_AXIS)

        if math.abs(currentX - xPosition) > XTolerance then
            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))
            if not ProbeScripts.ProtectedMove(inst, "work", xPosition, Y_POSITIONS[1], traverseHeight, 300) then return false end
            if not ProbeScripts.ProtectedMove(inst, "work", nil, nil, probeZ) then return false end
        else
            if not ProbeScripts.ProtectedMove(inst, "work", nil, Y_POSITIONS[1], nil, 200) then return false end
        end

        local xMeasurements = {}
        for i, yPos in ipairs(Y_POSITIONS) do
            if i > 1 then
                if not ProbeScripts.ProtectedMove(inst, "work", xPosition, yPos, nil) then return false end
            end

            local xEdge = ProbeScripts.Probe(inst, direction, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
            local offsetKey = direction == 1 and "+X" or "-X"
            xEdge = xEdge - calibrationOffsets[offsetKey]
            xMeasurements[i] = xEdge

            table.insert(results, {
                enumKey = enumKey,
                pianoKey = pianoKey,
                direction = direction,
                x = xEdge,
                y = yPos,
                z = probeZ,
                timestamp = os.date("%Y-%m-%d %H:%M:%S")
            })
        end

        -- Check linearity of front points (indices 1-3)
        local frontPoints = {}
        for i = 1, 3 do
            table.insert(frontPoints, {y = Y_POSITIONS[i], x = xMeasurements[i]})
        end

        local frontDistance = calculateLinearity(frontPoints)

        if frontDistance > LINEARITY_THRESHOLD then
            for _, yPos in ipairs(Y_POSITIONS_EXTRA_FRONT) do
                if not ProbeScripts.ProtectedMove(inst, "work", xPosition, yPos, nil) then return false end

                local xEdge = ProbeScripts.Probe(inst, direction, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
                local offsetKey = direction == 1 and "+X" or "-X"
                xEdge = xEdge - calibrationOffsets[offsetKey]

                table.insert(results, {
                    enumKey = enumKey,
                    pianoKey = pianoKey,
                    direction = direction,
                    x = xEdge,
                    y = yPos,
                    z = probeZ,
                    timestamp = os.date("%Y-%m-%d %H:%M:%S")
                })

                table.insert(xMeasurements, xEdge)
            end
        end

        -- Check linearity of back points (indices 4-6)
        local backPoints = {}
        for i = 4, 6 do
            table.insert(backPoints, {y = Y_POSITIONS[i], x = xMeasurements[i]})
        end

        local backDistance = calculateLinearity(backPoints)

        if backDistance > LINEARITY_THRESHOLD then
            for _, yPos in ipairs(Y_POSITIONS_EXTRA_BACK) do
                if not ProbeScripts.ProtectedMove(inst, "work", xPosition, yPos, nil) then return false end

                local xEdge = ProbeScripts.Probe(inst, direction, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
                local offsetKey = direction == 1 and "+X" or "-X"
                xEdge = xEdge - calibrationOffsets[offsetKey]

                table.insert(results, {
                    enumKey = enumKey,
                    pianoKey = pianoKey,
                    direction = direction,
                    x = xEdge,
                    y = yPos,
                    z = probeZ,
                    timestamp = os.date("%Y-%m-%d %H:%M:%S")
                })

                table.insert(xMeasurements, xEdge)
            end
        end

        -- Analyze shoulder accessibility
        local shoulderInfo = nil
        local probeDiamPlusX = mc.mcCntlGetPoundVar(inst, 511)
        local probeDiamMinusX = mc.mcCntlGetPoundVar(inst, 512)
        local probeDiamPlusY = mc.mcCntlGetPoundVar(inst, 513)
        local probeDiamMinusY = mc.mcCntlGetPoundVar(inst, 514)
        local probeDiameter = math.max(probeDiamPlusX, probeDiamMinusX, probeDiamPlusY, probeDiamMinusY)
        local minClearance = 1.75 * probeDiameter
        local minDiff = math.huge
        local closestFrontIdx = 0
        local closestBackIdx = 0

        for frontIdx = 1, 3 do
            for backIdx = 4, 6 do
                local diff = math.abs(xMeasurements[frontIdx] - xMeasurements[backIdx])
                if diff < minDiff then
                    minDiff = diff
                    closestFrontIdx = frontIdx
                    closestBackIdx = backIdx
                end
            end
        end

        if minDiff > minClearance then
            local xMidpoint = (xMeasurements[closestFrontIdx] + xMeasurements[closestBackIdx]) / 2
            shoulderInfo = {
                accessible = true,
                xPosition = xMidpoint,
                yPosition = Y_POSITIONS[4],
                enumKey = enumKey,
                pianoKey = pianoKey,
                clearance = minDiff
            }
        end

        local csvFile = io.open(csvPath, "a")
        writeBatchToCSV(csvFile, results)
        csvFile:close()

        if shoulderInfo and shoulderInfo.accessible then
            local sideName = direction == 1 and "left" or "right"
            writeReport(string.format("Key %d: %s side shoulder accessible (clearance: %.4f)", pianoKey, sideName, shoulderInfo.clearance))
        end

        return results, shoulderInfo
    end

    -- ========== MAIN SCRIPT START ==========

    -- Get bore location from settings
    local boreMachineX = mc.mcCntlGetPoundVar(inst, 540)
    local boreMachineY = mc.mcCntlGetPoundVar(inst, 541)

    if boreMachineX == 0 and boreMachineY == 0 then
        wx.wxMessageBox("Bore location not configured.\n\nPlease set the bore machine coordinates in System Settings > Keytop Replacement.",
            "Configuration Required", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    -- Get T90 tool table offsets
    local toolXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90) or 0
    local toolYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90) or 0

    -- Calculate spindle position to put probe tip at bore center
    local spindleTargetX = boreMachineX + toolXOffset
    local spindleTargetY = boreMachineY + toolYOffset

    -- Move to safe Z height first
    mc.mcCntlSetLastError(inst, "Moving to bore location...")
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z-0.05")

    -- Move spindle to calculated position
    if not ProbeScripts.ProtectedMove(inst, "mach", spindleTargetX, spindleTargetY, nil, 300) then return false end

    -- ========== LEFT BORE CALIBRATION ==========

    -- Probe down to find bore bottom
    doubleResults["-Z"] = ProbeScripts.Probe(inst, 5, false, false, nil, nil, false, nil)
    local boreBottomZ = doubleResults["-Z"]

    -- Move up 0.25" and note position
    mc.mcCntlGcodeExecuteWait(inst, "G91 G0 Z0.25")
    centeringHeightMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Double tap all four sides
    doubleResults["+X"] = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    doubleResults["-X"] = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    doubleResults["+Y"] = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    doubleResults["-Y"] = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)

    -- Calculate and move to center
    local leftBoreCenterX = (doubleResults["+X"] + doubleResults["-X"]) / 2
    local leftBoreCenterY = (doubleResults["+Y"] + doubleResults["-Y"]) / 2
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F200", leftBoreCenterX, leftBoreCenterY))

    -- Single tap calibration for +X, -X, -Y, -Z (skip +Y - no front probing)
    for cycle = 1, 3 do
        singleResults["+X"][cycle] = ProbeScripts.Probe(inst, 1, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        singleResults["-X"][cycle] = ProbeScripts.Probe(inst, 2, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        singleResults["-Y"][cycle] = ProbeScripts.Probe(inst, 4, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        singleResults["-Z"][cycle] = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    end

    -- Calculate calibration offsets
    for direction, singles in pairs(singleResults) do
        local sum = 0
        for _, singleValue in ipairs(singles) do
            sum = sum + (singleValue - doubleResults[direction])
        end
        calibrationOffsets[direction] = sum / #singles
    end

    -- Set XY datum at bore center
    mc.mcAxisSetPos(inst, mc.X_AXIS, 0)
    mc.mcAxisSetPos(inst, mc.Y_AXIS, 0)

    -- Move out of bore and probe surface for Z datum
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", boreBottomZ + 1))
    if not ProbeScripts.ProtectedMove(inst, "inc", 0.6, nil, nil, 200) then return false end
    local surfaceZ = ProbeScripts.Probe(inst, 5, true, true, nil, nil, false, nil)

    -- Move back to bore center
    if not ProbeScripts.ProtectedMove(inst, "work", 0, 0, nil, 200) then return false end

    -- ========== FIXTURE ID PROBING ==========

    local fixtureIDBits = {}

    for i = 1, 10 do
        local yPos = 1.0 + (i - 1) * 0.5
        if not ProbeScripts.ProtectedMove(inst, "work", 0, yPos, nil, 200) then return false end
        local holeZ = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        holeZ = holeZ - calibrationOffsets["-Z"]

        local bitValue = (holeZ < ID_HOLE_DEPTH_THRESHOLD) and 1 or 0
        fixtureIDBits[i] = bitValue
    end

    -- Verify check bits
    if fixtureIDBits[9] ~= 0 or fixtureIDBits[10] ~= 1 then
        wx.wxMessageBox(string.format("Fixture ID check bits invalid!\n\nBit 9 = %d (expected 0)\nBit 10 = %d (expected 1)\n\nCheck fixture orientation.",
            fixtureIDBits[9], fixtureIDBits[10]),
            "Fixture ID Error", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    -- Calculate fixture ID from first 8 bits
    local fixtureID = 0
    for i = 1, 8 do
        fixtureID = fixtureID + fixtureIDBits[i] * (2 ^ (i - 1))
    end

    mc.mcCntlSetLastError(inst, string.format("Fixture ID: %d", fixtureID))

    -- ========== RIGHT BORE PROBING ==========

    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))
    if not ProbeScripts.ProtectedMove(inst, "work", BORE_SEPARATION, 0, nil, 300) then return false end

    -- Drop down to centering height
    if not ProbeScripts.ProtectedMove(inst, "mach", nil, nil, centeringHeightMachine) then return false end
    local rightBoreCenterX, rightBoreCenterY = probeBoreCenter()

    -- Calculate and apply G68 rotation
    local yDifference = rightBoreCenterY
    local xDifference = rightBoreCenterX
    local angleDegrees = 0
    if math.abs(xDifference) > 0.001 then
        local angleRadians = math.atan(yDifference / xDifference)
        angleDegrees = angleRadians * 180 / math.pi
    end

    mc.mcCntlGcodeExecuteWait(inst, string.format("G68 X0 Y0 R%.4f", angleDegrees))
    mc.mcCntlSetLastError(inst, string.format("G68 rotation: %.4f degrees", angleDegrees))

    -- ========== AUTO-DETECT KEY SECTION ==========

    local KEY_26_X = FIRST_KEY_X + 25 * KEY_SPACING
    local FRONT_Y = Y_POSITIONS[2]
    local TAIL_Y = Y_POSITIONS[4]
    local SHOULDER_WIDTH_THRESHOLD = 0.1

    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))
    if not ProbeScripts.ProtectedMove(inst, "work", KEY_26_X, 0, nil, 300) then return false end

    -- Probe key surface
    local keyZ = ProbeScripts.Probe(inst, 5, false, false, nil, SINGLE_TAP_FEEDRATE, true, 0.5)
    keyZ = keyZ - calibrationOffsets["-Z"]

    -- Move to left of key and front Y position
    local probeStartX = KEY_26_X - (KEY_SPACING / 2)
    if not ProbeScripts.ProtectedMove(inst, "work", probeStartX, FRONT_Y, nil, 200) then return false end

    -- Drop to probe height
    local detectProbeZ = keyZ - PROBE_DROP_DEPTH
    if not ProbeScripts.ProtectedMove(inst, "work", nil, nil, detectProbeZ) then return false end

    -- Probe +X to find left edge at front
    local frontEdgeX = ProbeScripts.Probe(inst, 1, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    frontEdgeX = frontEdgeX - calibrationOffsets["+X"]

    -- Move to tail Y position
    if not ProbeScripts.ProtectedMove(inst, "work", nil, TAIL_Y, nil) then return false end

    -- Probe +X to find left edge at tail
    local tailEdgeX = ProbeScripts.Probe(inst, 1, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    tailEdgeX = tailEdgeX - calibrationOffsets["+X"]

    -- Calculate shoulder width
    local shoulderWidth = tailEdgeX - frontEdgeX

    if shoulderWidth > SHOULDER_WIDTH_THRESHOLD then
        TEST_KEYS = LOWER_KEYS
        keyHalfName = "Lower"
    else
        TEST_KEYS = UPPER_KEYS
        keyHalfName = "Upper"
    end

    mc.mcCntlSetLastError(inst, string.format("Auto-detect: %s keys (shoulder width: %.4f)", keyHalfName, shoulderWidth))

    -- ========== CREATE OUTPUT FILES ==========

    pianoName = string.format("%s_%s_%s", params.make, params.serial, keyHalfName)
    pianoFolder = string.format("C:\\Mach4Hobby\\Profiles\\BLP\\Logs\\%s", pianoName)
    os.execute('mkdir "' .. pianoFolder .. '" 2>nul')

    csvPath = string.format("%s\\%s.csv", pianoFolder, pianoName)
    local reportPath = string.format("%s\\%s_Report.txt", pianoFolder, pianoName)
    reportFile = io.open(reportPath, "w")

    writeReport(string.format("===== ProbeKeys %s - %s S/N %s =====", keyHalfName, params.make, params.serial))
    writeReport(string.format("Fixture ID: %d", fixtureID))
    writeReport(string.format("Bore alignment angle: %.4f degrees", angleDegrees))
    writeReport(string.format("Probe Drop Depth: %.4f", PROBE_DROP_DEPTH))
    writeReport(string.format("Linearity Threshold: %.4f", LINEARITY_THRESHOLD))
    writeReport(string.format("Single Tap Feedrate: %.1f IPM", SINGLE_TAP_FEEDRATE))
    writeReport(string.format("CSV output file: %s", csvPath))

    -- Report calibration offsets
    writeReport("Single-tap calibration offsets:")
    for direction, offset in pairs(calibrationOffsets) do
        writeReport(string.format("  %s: %.6f", direction, offset))
    end

    -- ========== SAMPLE Z HEIGHT PROBING ==========

    mc.mcCntlSetLastError(inst, "Probing sample key heights...")
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))

    local zProbeData = {}
    local sampleZHeights = {}

    -- Move to first key
    if not ProbeScripts.ProtectedMove(inst, "work", FIRST_KEY_X, 0, nil, 300) then
        reportFile:close()
        return false
    end

    -- Probe sample keys (1, 7, 13, 19, 25)
    local sampleCount = 0
    for keyIndex = 1, NUM_KEYS, SAMPLE_KEY_INTERVAL do
        local keyX = FIRST_KEY_X + (keyIndex - 1) * KEY_SPACING

        if keyIndex > 1 then
            if not ProbeScripts.ProtectedMove(inst, "work", keyX, 0, nil, 300) then
                reportFile:close()
                return false
            end
        end

        local zHeight = ProbeScripts.Probe(inst, 5, false, false, nil, SINGLE_TAP_FEEDRATE, true, 0.5)
        zHeight = zHeight - calibrationOffsets["-Z"]

        table.insert(sampleZHeights, zHeight)
        sampleCount = sampleCount + 1

        -- Find which TEST_KEY entry corresponds to this keyIndex
        local keyInfo = TEST_KEYS[keyIndex]
        local pianoKey = keyInfo[1]
        local enumKey = keyInfo[2]

        table.insert(zProbeData, {
            enumKey = enumKey,
            pianoKey = pianoKey,
            direction = 5,
            x = keyX,
            y = 0,
            z = zHeight,
            timestamp = os.date("%Y-%m-%d %H:%M:%S")
        })

        writeReport(string.format("Sample key %d (piano key %d): Z=%.4f", keyIndex, pianoKey, zHeight))
    end

    -- Write Z probe data to CSV
    local csvFile = io.open(csvPath, "w")
    csvFile:write("EnumKey#,PianoKey#,Direction,X,Y,Z,Timestamp\n")
    writeBatchToCSV(csvFile, zProbeData)
    csvFile:close()

    -- Calculate average Z height
    local avgZ = 0
    for _, z in ipairs(sampleZHeights) do
        avgZ = avgZ + z
    end
    avgZ = avgZ / #sampleZHeights

    -- Set uniform traverse and probe heights
    traverseHeight = avgZ + 0.5
    probeZ = avgZ - PROBE_DROP_DEPTH

    writeReport(string.format("Average Z height: %.4f", avgZ))
    writeReport(string.format("Traverse height: %.4f", traverseHeight))
    writeReport(string.format("Probe Z depth: %.4f", probeZ))

    -- ========== X EDGE PROBING ==========

    mc.mcCntlSetLastError(inst, "Probing X edges...")
    local accessibleShoulders = {}

    for keyIdx = 1, #TEST_KEYS do
        local pianoKey = TEST_KEYS[keyIdx][1]

        local leftX = FIRST_KEY_X - (KEY_SPACING / 2) + (keyIdx - 1) * KEY_SPACING
        local rightX = leftX + KEY_SPACING

        -- Probe left side (+X direction)
        local leftData, leftShoulder = probeKeySide(keyIdx, 1, leftX)
        if leftData == false then
            reportFile:close()
            return false
        end
        if leftShoulder then
            table.insert(accessibleShoulders, leftShoulder)
        end

        -- Probe right side (-X direction)
        local rightData, rightShoulder = probeKeySide(keyIdx, 2, rightX)
        if rightData == false then
            reportFile:close()
            return false
        end
        if rightShoulder then
            table.insert(accessibleShoulders, rightShoulder)
        end

        mc.mcCntlSetLastError(inst, string.format("Probing key %d of %d...", keyIdx, #TEST_KEYS))
    end

    -- ========== SHOULDER -Y PROBING ==========

    if #accessibleShoulders > 0 then
        mc.mcCntlSetLastError(inst, "Probing shoulders...")
        mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))

        local shoulderData = {}

        for _, shoulder in ipairs(accessibleShoulders) do
            -- Move to shoulder probe position (uniform probeZ for all)
            if not ProbeScripts.ProtectedMove(inst, "work", shoulder.xPosition, shoulder.yPosition, traverseHeight, 300) then
                reportFile:close()
                return false
            end
            if not ProbeScripts.ProtectedMove(inst, "work", nil, nil, probeZ) then
                reportFile:close()
                return false
            end

            -- Single tap -Y with calibration
            local yBack = ProbeScripts.Probe(inst, 4, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
            yBack = yBack - calibrationOffsets["-Y"]

            table.insert(shoulderData, {
                enumKey = shoulder.enumKey,
                pianoKey = shoulder.pianoKey,
                direction = 4,
                x = shoulder.xPosition,
                y = yBack,
                z = probeZ,
                timestamp = os.date("%Y-%m-%d %H:%M:%S")
            })

            mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))
        end

        if #shoulderData > 0 then
            local csvFile = io.open(csvPath, "a")
            writeBatchToCSV(csvFile, shoulderData)
            csvFile:close()
        end

        writeReport(string.format("Probed %d accessible shoulders", #shoulderData))
    else
        writeReport("No accessible shoulders found for -Y probing")
    end

    -- ========== RETURN HOME ==========

    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", traverseHeight))
    mc.mcCntlGcodeExecuteWait(inst, "G90 G0 X0 Y0")

    -- Clear G68 rotation
    mc.mcCntlGcodeExecuteWait(inst, "G69")
    writeReport("G68 rotation cleared")

    mc.mcCntlSetLastError(inst, string.format("ProbeKeys %s half completed successfully", keyHalfName))
    writeReport(string.format("===== ProbeKeys %s Half Completed Successfully =====", keyHalfName))
    reportFile:close()

    -- ========== TRIGGER FUSION ADD-IN ==========

    local triggerPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Logs\\PROBE_COMPLETE_" .. pianoName .. ".txt"
    local csvPathNetwork = csvPath:gsub("C:\\Mach4Hobby", "\\\\BLPCNC\\Mach4Hobby")
    local triggerData = string.format('{"csv_path": "%s", "piano_id": "%s", "avg_z": %.6f}',
        csvPathNetwork:gsub("\\", "\\\\"),
        pianoName,
        avgZ)

    local triggerFile = io.open(triggerPath, "w")
    if triggerFile then
        triggerFile:write(triggerData)
        triggerFile:close()
        mc.mcCntlSetLastError(inst, string.format("ProbeKeys complete - trigger sent to Fusion"))
    else
        wx.wxMessageBox("Warning: Could not create trigger file for Fusion 360.\n\nManually trigger the add-in or re-run ProbeKeys.",
            "Trigger Warning", wx.wxOK + wx.wxICON_WARNING)
    end

    return true
end







function ProbeScripts.InitialKeytopTrim(inst)
    -- Check probe deployment first
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Check that user is on GCode tab (not MDI)
    local tabCheckOk, tabResult = pcall(function()
        local tab1 = scr.GetProperty("nbGCodeMDI1", "Current Tab")
        local tab2 = scr.GetProperty("nbGCodeMDI2", "Current Tab")
        return (tab1 == "0" or tab1 == 0) or (tab2 == "0" or tab2 == 0)
    end)

    if tabCheckOk and not tabResult then
        wx.wxMessageBox("Please switch to the GCode tab before running Initial Trim.\n\nThe MDI tab is currently active.",
            "Wrong Tab", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check front vacuum is on (OUTPUT6)
    local vacFrontHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6)
    local vacFrontState = mc.mcSignalGetState(vacFrontHandle)
    if vacFrontState ~= 1 then
        wx.wxMessageBox("Front vacuum must be ON before running Initial Trim.\n\nPlease turn on the front vacuum and try again.",
            "Vacuum Required", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check dust collection automation is enabled (OUTPUT50 = dustAuto, OUTPUT52 = bootAuto)
    local dustAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT50)
    local dustAutoState = mc.mcSignalGetState(dustAutoHandle)
    local bootAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT52)
    local bootAutoState = mc.mcSignalGetState(bootAutoHandle)

    if dustAutoState ~= 1 or bootAutoState ~= 1 then
        local missing = {}
        if dustAutoState ~= 1 then table.insert(missing, "Dust Collect Auto") end
        if bootAutoState ~= 1 then table.insert(missing, "Dust Boot Auto") end

        local result = wx.wxMessageBox(
            "The following automation settings are not enabled:\n\nâ¢ " .. table.concat(missing, "\nâ¢ ") ..
            "\n\nIt is recommended to enable these before running the trim operation.\n\nContinue anyway?",
            "Automation Warning", wx.wxYES_NO + wx.wxICON_WARNING)

        if result ~= wx.wxYES then
            return
        end
    end

    mc.mcCntlGcodeExecuteWait(inst, "G55")

    -- Show dialog to get trim parameters
    local fields = {
        {type = "instructions",
         text = "Initial keytop trim operation.\nEnter the plastic thickness to remove."},
        {type = "number", key = "removalDepth", label = "Removal Depth (inches)",
         default = 0.08, persist = false, min = 0.001, max = 0.25,
         validateMsg = "Must be between 0.001-0.5"},
        {type = "separator"},
        {type = "radio", key = "trimOperation", label = "Trim Operation",
         options = {"Top and Front", "Top Only"},
         columns = 2, default = 0}
    }

    local params = ProbeScripts.ShowDialog(inst, "Initial Trim", fields, "InitialTrim", {width = 300})
    if not params then return end

    -- Cancel any existing G68 rotation
    mc.mcCntlGcodeExecuteWait(inst, "G69")

    -- Config
    local SINGLE_TAP_FEEDRATE = 40  -- IPM for single tap probes
    local BORE_SEPARATION = 46.0  -- inches between calibration bores
    local KEY_SPACING = 1.7  -- inches between white keys
    local FIRST_KEY_X = 1.75  -- X position of first key center
    local SAMPLE_KEY_INTERVAL = 6  -- Probe every 6th key (keys 1, 7, 13, 19, 25)
    local NUM_KEYS = 26  -- Total white keys per section
    local safeTraverseZ = 2.0  -- Safe Z height for traversing (work coords, relative to surface)

    -- Storage
    local centeringHeightMachine  -- bore centering height in machine coords
    local calibrationOffsets = {}  -- single-tap calibration offsets

    -- ========== LEFT BORE POSITIONING ==========

    -- Get bore location from settings (pv 540 and 541)
    local boreMachineX = mc.mcCntlGetPoundVar(inst, 540)
    local boreMachineY = mc.mcCntlGetPoundVar(inst, 541)

    if boreMachineX == 0 and boreMachineY == 0 then
        wx.wxMessageBox("Bore location not configured.\n\nPlease set the bore machine coordinates in System Settings > Keytop Replacement.",
            "Configuration Required", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    -- Get T90 tool table offsets
    local toolXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90) or 0
    local toolYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90) or 0

    -- Calculate spindle position needed to put probe tip at bore center
    local spindleTargetX = boreMachineX + toolXOffset
    local spindleTargetY = boreMachineY + toolYOffset

    -- Move to safe Z height first
    mc.mcCntlSetLastError(inst, "Moving to bore location...")
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z-0.05")

    -- Move spindle to calculated position
    if not ProbeScripts.ProtectedMove(inst, "mach", spindleTargetX, spindleTargetY, nil, 300) then
        return false
    end

    -- ========== LEFT BORE CALIBRATION ==========

    -- Probe down to find bore bottom
    local doubleResults = {}
    doubleResults["-Z"] = ProbeScripts.Probe(inst, 5, false, false, nil, nil, false, nil)
    local boreBottomZ = doubleResults["-Z"]

    -- Move up 0.25" and note position for centering
    mc.mcCntlGcodeExecuteWait(inst, "G91 G0 Z0.25")
    centeringHeightMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Double tap all four sides for centering
    doubleResults["+X"] = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    doubleResults["-X"] = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    doubleResults["+Y"] = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    doubleResults["-Y"] = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)

    -- Calculate and move to center
    local leftBoreCenterX = (doubleResults["+X"] + doubleResults["-X"]) / 2
    local leftBoreCenterY = (doubleResults["+Y"] + doubleResults["-Y"]) / 2
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F200", leftBoreCenterX, leftBoreCenterY))

    -- Single tap calibration for -Z (only direction we need for key probing)
    local singleZResult = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    calibrationOffsets["-Z"] = singleZResult - doubleResults["-Z"]

    -- Set XY datum at bore center
    mc.mcAxisSetPos(inst, mc.X_AXIS, 0)
    mc.mcAxisSetPos(inst, mc.Y_AXIS, 0)

    -- Move out of bore and probe surface to set temporary Z datum
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", boreBottomZ + 1))
    if not ProbeScripts.ProtectedMove(inst, "inc", 0.6, nil, nil, 200) then
        return false
    end
    local surfaceZ = ProbeScripts.Probe(inst, 5, true, true, nil, nil, false, nil)

    -- ========== RIGHT BORE PROBING (skip fixture ID) ==========

    -- Move to safe traverse height then to right bore
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))
    if not ProbeScripts.ProtectedMove(inst, "work", BORE_SEPARATION, 0, nil, 300) then
        return false
    end

    -- Drop down to centering height in bore
    if not ProbeScripts.ProtectedMove(inst, "mach", nil, nil, centeringHeightMachine) then
        return false
    end

    -- Probe bore center
    local xEdge1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    local xEdge2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    local rightBoreCenterX = (xEdge1 + xEdge2) / 2

    local yEdge1 = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    local yEdge2 = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
    local rightBoreCenterY = (yEdge1 + yEdge2) / 2

    -- Calculate and apply G68 rotation
    local yDifference = rightBoreCenterY
    local xDifference = rightBoreCenterX
    local angleDegrees = 0
    if math.abs(xDifference) > 0.001 then
        local angleRadians = math.atan(yDifference / xDifference)
        angleDegrees = angleRadians * 180 / math.pi
    end

    mc.mcCntlGcodeExecuteWait(inst, string.format("G68 X0 Y0 R%.4f", angleDegrees))
    mc.mcCntlSetLastError(inst, string.format("G68 rotation: %.4f degrees", angleDegrees))

    -- ========== SAMPLE KEY Z HEIGHT PROBING ==========

    mc.mcCntlSetLastError(inst, "Probing sample key heights...")

    -- Move to safe height
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))

    local sampleZHeights = {}
    local sampleCount = 0

    -- Probe every 6th key: keys 1, 7, 13, 19, 25 (indices 1, 7, 13, 19, 25)
    for keyIndex = 1, NUM_KEYS, SAMPLE_KEY_INTERVAL do
        local keyX = FIRST_KEY_X + (keyIndex - 1) * KEY_SPACING

        if not ProbeScripts.ProtectedMove(inst, "work", keyX, 0, nil, 300) then
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end

        -- Single tap probe with calibration
        local zHeight = ProbeScripts.Probe(inst, 5, false, false, nil, SINGLE_TAP_FEEDRATE, true, 0.5)
        zHeight = zHeight - calibrationOffsets["-Z"]

        table.insert(sampleZHeights, zHeight)
        sampleCount = sampleCount + 1

        mc.mcCntlSetLastError(inst, string.format("Sample %d: Z=%.4f", sampleCount, zHeight))
    end

    -- Find maximum Z height (highest key)
    local maxZ = sampleZHeights[1]
    for _, z in ipairs(sampleZHeights) do
        if z > maxZ then
            maxZ = z
        end
    end

    -- Calculate machining height (max minus removal depth)
    local machiningHeight = maxZ - params.removalDepth

    mc.mcCntlSetLastError(inst, string.format("Max Z: %.4f, Machining height: %.4f", maxZ, machiningHeight))

    -- Validate machining height is within safe range
    if machiningHeight < 0.1 or machiningHeight > 2.0 then
        wx.wxMessageBox(string.format("Calculated machining height is unsafe: %.4f inches\n\nRemoval depth: %.4f\nMax Z: %.4f\n\nResult must be between 0.1 and 2.0 inches.",
            machiningHeight, params.removalDepth, maxZ),
            "Unsafe Machining Height", wx.wxOK + wx.wxICON_ERROR)
        mc.mcCntlGcodeExecuteWait(inst, "G69")
        return false
    end

    -- ========== SET FINAL Z DATUM ==========

    -- Get current Z position (still at last probed key location)
    local currentZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)

    -- Set Z datum so Z=0 is at machining height
    -- Current position is at currentZ in work coords (surface is Z=0)
    -- We want new Z=0 to be at machiningHeight above the original surface
    -- So new Z at current position = currentZ - machiningHeight
    local newZPosition = currentZ - machiningHeight
    mc.mcAxisSetPos(inst, mc.Z_AXIS, newZPosition)

    mc.mcCntlSetLastError(inst, string.format("Z datum set: machining height = %.4f", machiningHeight))

    -- ========== PREPARE G-CODE EXECUTION ==========

    -- Retract to machine Z0
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z0")

    -- Close any currently loaded G-code file
    mc.mcCntlCloseGCodeFile(inst)

    -- Determine which G-code file(s) to load
    local gcodeDir = "C:\\Mach4Hobby\\Profiles\\BLP\\Scripts\\GCode"
    local topTrimFile = gcodeDir .. "\\Initial Trim Top.tap"
    local frontTrimFile = gcodeDir .. "\\Initial Trim Front.tap"

    local gcodeFilePath
    local trimOps = {"Top and Front", "Top Only"}

    if params.trimOperation == 0 then
        -- Top and Front: need to combine files
        -- Read front trim, strip M30/M2, append top trim
        local frontFile = io.open(frontTrimFile, "r")
        if not frontFile then
            wx.wxMessageBox("Failed to open front trim file:\n" .. frontTrimFile, "Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        local frontContent = frontFile:read("*a")
        frontFile:close()

        local topFile = io.open(topTrimFile, "r")
        if not topFile then
            wx.wxMessageBox("Failed to open top trim file:\n" .. topTrimFile, "Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        local topContent = topFile:read("*a")
        topFile:close()

        -- Strip M30/M2 from front content
        frontContent = frontContent:gsub("[Mm]30[^\n]*\n?", "\n")
        frontContent = frontContent:gsub("[Mm]2[^\n]*\n?", "\n")
        frontContent = frontContent .. "\n(End of front trim, continuing to top trim)\n\n"

        -- Combine and write to temp file
        local tempDir = "C:\\Mach4Hobby\\Profiles\\BLP\\Temp"
        gcodeFilePath = tempDir .. "\\InitialTrimCombined.tap"

        local tempFile = io.open(gcodeFilePath, "w")
        if not tempFile then
            wx.wxMessageBox("Failed to create combined G-code file.", "Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        tempFile:write(frontContent)
        tempFile:write(topContent)
        tempFile:close()

    else
        -- Top Only: use top trim file directly
        gcodeFilePath = topTrimFile
    end

    -- Verify file exists
    local testFile = io.open(gcodeFilePath, "r")
    if not testFile then
        wx.wxMessageBox("G-code file not found:\n" .. gcodeFilePath, "Error", wx.wxOK + wx.wxICON_ERROR)
        return false
    end
    testFile:close()

    -- ========== DEFERRED FILE LOAD ==========
    -- Can't load G-code from within a macro (machine state is MRUN, error -18).
    -- Write the file path to a marker file. PLC checks for this file when idle,
    -- loads the G-code, and deletes the marker.

    local markerPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Temp\\DeferredGCode.txt"
    local markerFile = io.open(markerPath, "w")
    if markerFile then
        markerFile:write(gcodeFilePath)
        markerFile:close()
    else
        wx.wxMessageBox("Failed to queue G-code file for execution.", "Error", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    mc.mcCntlSetLastError(inst, string.format("Trim ready - %s (removal: %.3f, height: %.3f)",
        trimOps[params.trimOperation + 1], params.removalDepth, machiningHeight))
    return true
end








function ProbeScripts.FinalKeytopShaping(inst)
    -- Check probe deployment first
    if not ProbeScripts.CheckProbeDeployed(inst) then return end

    -- Check that user is on GCode tab (not MDI)
    local tabCheckOk, tabResult = pcall(function()
        local tab1 = scr.GetProperty("nbGCodeMDI1", "Current Tab")
        local tab2 = scr.GetProperty("nbGCodeMDI2", "Current Tab")
        return (tab1 == "0" or tab1 == 0) or (tab2 == "0" or tab2 == 0)
    end)

    if tabCheckOk and not tabResult then
        wx.wxMessageBox("Please switch to the GCode tab before running Final Keytop Shaping.\n\nThe MDI tab is currently active.",
            "Wrong Tab", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check front vacuum is on (OUTPUT6)
    local vacFrontHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6)
    local vacFrontState = mc.mcSignalGetState(vacFrontHandle)
    if vacFrontState ~= 1 then
        wx.wxMessageBox("Front vacuum must be ON before running Final Keytop Shaping.\n\nPlease turn on the front vacuum and try again.",
            "Vacuum Required", wx.wxOK + wx.wxICON_WARNING)
        return
    end

    -- Check dust collection automation is enabled (OUTPUT50 = dustAuto, OUTPUT52 = bootAuto)
    local dustAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT50)
    local dustAutoState = mc.mcSignalGetState(dustAutoHandle)
    local bootAutoHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT52)
    local bootAutoState = mc.mcSignalGetState(bootAutoHandle)

    if dustAutoState ~= 1 or bootAutoState ~= 1 then
        local missing = {}
        if dustAutoState ~= 1 then table.insert(missing, "Dust Collect Auto") end
        if bootAutoState ~= 1 then table.insert(missing, "Dust Boot Auto") end

        local result = wx.wxMessageBox(
            "The following automation settings are not enabled:\n\nâ¢ " .. table.concat(missing, "\nâ¢ ") ..
            "\n\nIt is recommended to enable these before running Final Shaping.\n\nContinue anyway?",
            "Automation Warning", wx.wxYES_NO + wx.wxICON_WARNING)

        if result ~= wx.wxYES then
            return
        end
    end

    mc.mcCntlGcodeExecuteWait(inst, "G55")

    -- Scan for available shaping files to populate dropdown
    local logsDir = "C:\\Mach4Hobby\\Profiles\\BLP\\Logs"
    local availableFiles = {}
    local fileOptions = {"Auto-detect from fixture"}

    -- Search through piano folders for shaping files
    local handle = io.popen('dir "' .. logsDir .. '" /b /ad /o-d 2>nul')
    local folders = handle:read("*a")
    handle:close()

    for folderName in folders:gmatch("[^\r\n]+") do
        local folderPath = logsDir .. "\\" .. folderName
        -- Look for shaping .tap files in this folder
        local fileHandle = io.popen('dir "' .. folderPath .. '\\*Shaping*.tap" /b /o-d 2>nul')
        local files = fileHandle:read("*a")
        fileHandle:close()

        for fileName in files:gmatch("[^\r\n]+") do
            local displayName = folderName .. " - " .. fileName:gsub("%.tap$", "")
            table.insert(fileOptions, displayName)
            table.insert(availableFiles, {
                folder = folderName,
                file = fileName,
                path = folderPath .. "\\" .. fileName
            })
        end
    end

    -- Show dialog with dropdown of available files
    local fields = {
        {type = "instructions",
         text = "Select shaping G-code file to run.\nAuto-detect will probe the fixture ID and find the matching file."},
        {type = "choice", key = "fileSelection", label = "Shaping File",
         options = fileOptions,
         default = 0,
         tooltip = "Select Auto-detect or choose a specific file"}
    }

    local params = ProbeScripts.ShowDialog(inst, "Final Keytop Shaping", fields, "FinalKeytopShaping", {width = 450})
    if not params then return end

    -- Cancel any existing G68 rotation
    mc.mcCntlGcodeExecuteWait(inst, "G69")

    -- Config
    local SINGLE_TAP_FEEDRATE = 40  -- IPM for single tap probes
    local BORE_SEPARATION = 46.0  -- inches between calibration bores
    local ID_HOLE_DEPTH_THRESHOLD = -0.05  -- Threshold for fixture ID hole detection
    local safeTraverseZ = 2.0  -- Safe Z height for traversing

    -- Storage
    local centeringHeightMachine  -- bore centering height in machine coords
    local calibrationOffsets = {}  -- single-tap calibration offsets
    local fixtureID = nil  -- detected fixture ID
    local reportFile = nil
    local reportMessages = {}

    -- Helper function to write to report (buffers until file is opened)
    local function writeReport(message)
        local timestamp = os.date("%Y-%m-%d %H:%M:%S")
        local formattedMsg = string.format("[%s] %s\n", timestamp, message)
        table.insert(reportMessages, formattedMsg)
        if reportFile then
            reportFile:write(formattedMsg)
            reportFile:flush()
        end
    end

    writeReport("===== Final Keytop Shaping Started =====")

    -- Helper function for bore center probing
    local function probeBoreCenter(boreName)
        local xEdge1 = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
        local xEdge2 = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
        local centerX = (xEdge1 + xEdge2) / 2

        local yEdge1 = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
        local yEdge2 = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)
        local centerY = (yEdge1 + yEdge2) / 2

        return centerX, centerY
    end

    -- ========== LEFT BORE POSITIONING ==========

    -- Get bore location from settings (pv 540 and 541)
    local boreMachineX = mc.mcCntlGetPoundVar(inst, 540)
    local boreMachineY = mc.mcCntlGetPoundVar(inst, 541)

    if boreMachineX == 0 and boreMachineY == 0 then
        wx.wxMessageBox("Bore location not configured.\n\nPlease set the bore machine coordinates in System Settings > Keytop Replacement.",
            "Configuration Required", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    -- Get T90 tool table offsets
    local toolXOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_X, 90) or 0
    local toolYOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_Y, 90) or 0

    -- Calculate spindle position needed to put probe tip at bore center
    local spindleTargetX = boreMachineX + toolXOffset
    local spindleTargetY = boreMachineY + toolYOffset

    -- Move to safe Z height first
    mc.mcCntlSetLastError(inst, "Moving to bore location...")
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z-0.05")

    -- Move spindle to calculated position
    if not ProbeScripts.ProtectedMove(inst, "mach", spindleTargetX, spindleTargetY, nil, 300) then
        return false
    end

    -- ========== LEFT BORE CALIBRATION ==========

    -- Probe down to find bore bottom
    local doubleResults = {}
    doubleResults["-Z"] = ProbeScripts.Probe(inst, 5, false, false, nil, nil, false, nil)
    local boreBottomZ = doubleResults["-Z"]

    -- Move up 0.25" and note position
    mc.mcCntlGcodeExecuteWait(inst, "G91 G0 Z0.25")
    centeringHeightMachine = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)

    -- Double tap all four sides for centering
    doubleResults["+X"] = ProbeScripts.Probe(inst, 1, false, true, nil, nil, false, nil)
    doubleResults["-X"] = ProbeScripts.Probe(inst, 2, false, true, nil, nil, false, nil)
    doubleResults["+Y"] = ProbeScripts.Probe(inst, 3, false, true, nil, nil, false, nil)
    doubleResults["-Y"] = ProbeScripts.Probe(inst, 4, false, true, nil, nil, false, nil)

    -- Calculate and move to center
    local leftBoreCenterX = (doubleResults["+X"] + doubleResults["-X"]) / 2
    local leftBoreCenterY = (doubleResults["+Y"] + doubleResults["-Y"]) / 2
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G1 X%.4f Y%.4f F200", leftBoreCenterX, leftBoreCenterY))

    -- Single tap calibration for -Z only
    local singleZResult = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
    calibrationOffsets["-Z"] = singleZResult - doubleResults["-Z"]

    writeReport("Single-tap calibration offset:")
    writeReport(string.format("  -Z: %.6f", calibrationOffsets["-Z"]))

    -- Log left bore center and set datum
    writeReport(string.format("Left bore center: X%.4f Y%.4f", leftBoreCenterX, leftBoreCenterY))
    mc.mcAxisSetPos(inst, mc.X_AXIS, 0)
    mc.mcAxisSetPos(inst, mc.Y_AXIS, 0)

    -- Move out of bore and probe surface
    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", boreBottomZ + 1))
    if not ProbeScripts.ProtectedMove(inst, "inc", 0.6, nil, nil, 200) then
        return false
    end
    local surfaceZ = ProbeScripts.Probe(inst, 5, true, true, nil, nil, false, nil)
    writeReport(string.format("Surface Z datum set at: %.4f", surfaceZ))

    -- Move back to bore center (0,0)
    if not ProbeScripts.ProtectedMove(inst, "work", 0, 0, nil, 200) then
        return false
    end

    -- ========== FIXTURE ID PROBING ==========

    local fixtureIDBits = {}

    -- Probe each of the 10 ID holes
    for i = 1, 10 do
        local yPos = 1.0 + (i - 1) * 0.5
        if not ProbeScripts.ProtectedMove(inst, "work", 0, yPos, nil, 200) then
            return false
        end
        local holeZ = ProbeScripts.Probe(inst, 5, false, true, nil, SINGLE_TAP_FEEDRATE, true, nil)
        holeZ = holeZ - calibrationOffsets["-Z"]

        local bitValue = (holeZ < ID_HOLE_DEPTH_THRESHOLD) and 1 or 0
        fixtureIDBits[i] = bitValue

        writeReport(string.format("ID hole %d: Z=%.4f (calibrated), bit=%d", i, holeZ, bitValue))
    end

    -- Verify check bits (9th should be 0, 10th should be 1)
    if fixtureIDBits[9] ~= 0 or fixtureIDBits[10] ~= 1 then
        writeReport(string.format("WARNING: Check bits invalid! Bit 9=%d (expected 0), Bit 10=%d (expected 1)",
            fixtureIDBits[9], fixtureIDBits[10]))
    end

    -- Calculate fixture ID from first 8 bits
    fixtureID = 0
    for i = 1, 8 do
        fixtureID = fixtureID + fixtureIDBits[i] * (2 ^ (i - 1))
    end

    writeReport(string.format("Fixture ID detected: %d (binary: %s%s%s%s%s%s%s%s)",
        fixtureID,
        tostring(fixtureIDBits[8]), tostring(fixtureIDBits[7]),
        tostring(fixtureIDBits[6]), tostring(fixtureIDBits[5]),
        tostring(fixtureIDBits[4]), tostring(fixtureIDBits[3]),
        tostring(fixtureIDBits[2]), tostring(fixtureIDBits[1])))

    -- ========== RIGHT BORE PROBING ==========

    mc.mcCntlGcodeExecuteWait(inst, string.format("G90 G0 Z%.4f", safeTraverseZ))
    if not ProbeScripts.ProtectedMove(inst, "work", BORE_SEPARATION, 0, nil, 300) then
        return false
    end

    if not ProbeScripts.ProtectedMove(inst, "mach", nil, nil, centeringHeightMachine) then
        return false
    end
    local rightBoreCenterX, rightBoreCenterY = probeBoreCenter("right")
    writeReport(string.format("Right bore center (in datum coords): X%.4f Y%.4f", rightBoreCenterX, rightBoreCenterY))

    -- Calculate and apply G68 rotation
    local yDifference = rightBoreCenterY
    local xDifference = rightBoreCenterX
    local angleDegrees = 0
    if math.abs(xDifference) > 0.001 then
        local angleRadians = math.atan(yDifference / xDifference)
        angleDegrees = angleRadians * 180 / math.pi
    end

    writeReport(string.format("Right bore position relative to left: X%.4f Y%.4f", xDifference, yDifference))
    writeReport(string.format("Bore alignment angle: %.4f degrees", angleDegrees))

    mc.mcCntlGcodeExecuteWait(inst, string.format("G68 X0 Y0 R%.4f", angleDegrees))
    writeReport(string.format("G68 rotation applied: %.4f degrees centered at 0,0", angleDegrees))

    -- ========== FIND SHAPING FILE ==========

    local shapingFilePath = nil
    local pianoMake = nil
    local pianoSerial = nil
    local pianoFolder = nil
    local keySection = nil  -- "Upper" or "Lower"

    if params.fileSelection == 0 then
        -- Auto-detect: search log files for matching fixture ID
        mc.mcCntlSetLastError(inst, "Searching for fixture ID in logs...")

        local function findFixtureInLogs(searchFixtureID)
            local foundMake = nil
            local foundSerial = nil
            local foundFolder = nil
            local foundSection = nil

            for folderName in folders:gmatch("[^\r\n]+") do
                local reportPath = logsDir .. "\\" .. folderName .. "\\" .. folderName .. "_Report.txt"
                local file = io.open(reportPath, "r")
                if file then
                    local content = file:read("*a")
                    file:close()

                    local foundID = content:match("Fixture ID: (%d+)")
                    if foundID and tonumber(foundID) == searchFixtureID then
                        -- Folder name is now {Make}_{Serial}_{Section}
                        -- Extract section from folder name (last part)
                        if folderName:match("_Upper$") then
                            foundSection = "Upper"
                            foundMake, foundSerial = folderName:match("(.+)_(.+)_Upper$")
                        elseif folderName:match("_Lower$") then
                            foundSection = "Lower"
                            foundMake, foundSerial = folderName:match("(.+)_(.+)_Lower$")
                        end
                        foundFolder = folderName

                        writeReport(string.format("Found matching fixture ID %d in folder: %s", searchFixtureID, folderName))
                        writeReport(string.format("Piano: %s S/N %s, Section: %s", foundMake or "Unknown", foundSerial or "Unknown", foundSection or "Unknown"))
                        break
                    end
                end
            end

            return foundMake, foundSerial, foundFolder, foundSection
        end

        pianoMake, pianoSerial, pianoFolder, keySection = findFixtureInLogs(fixtureID)

        if not pianoFolder then
            wx.wxMessageBox(string.format("Could not find previous probing data for fixture ID %d.\n\nPlease run ProbeKeys first.", fixtureID),
                "Log Data Not Found", wx.wxOK + wx.wxICON_ERROR)
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end

        if not keySection then
            wx.wxMessageBox(string.format("Could not determine Upper/Lower section from logs for fixture ID %d.", fixtureID),
                "Section Unknown", wx.wxOK + wx.wxICON_ERROR)
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end

        -- Look for shaping file matching the section
        local pianoFolderPath = logsDir .. "\\" .. pianoFolder
        local shapingPattern = keySection .. " Shaping"

        local fileHandle = io.popen('dir "' .. pianoFolderPath .. '\\*' .. keySection .. '*Shaping*.tap" /b /o-d 2>nul')
        local files = fileHandle:read("*a")
        fileHandle:close()

        local firstFile = files:match("[^\r\n]+")
        if firstFile then
            shapingFilePath = pianoFolderPath .. "\\" .. firstFile
            writeReport(string.format("Found shaping file: %s", shapingFilePath))
        else
            wx.wxMessageBox(string.format("No %s Shaping file found for %s.\n\nPlease ensure Fusion360 has exported the shaping G-code.", keySection, pianoFolder),
                "Shaping File Not Found", wx.wxOK + wx.wxICON_ERROR)
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end

    else
        -- User selected a specific file
        local selectedIdx = params.fileSelection  -- 0 = auto-detect, 1+ = file index
        local fileInfo = availableFiles[selectedIdx]
        if fileInfo then
            shapingFilePath = fileInfo.path
            pianoFolder = fileInfo.folder

            -- Determine section from filename
            if fileInfo.file:lower():match("upper") then
                keySection = "Upper"
            elseif fileInfo.file:lower():match("lower") then
                keySection = "Lower"
            end

            writeReport(string.format("User selected file: %s", shapingFilePath))
        else
            wx.wxMessageBox("Invalid file selection.", "Error", wx.wxOK + wx.wxICON_ERROR)
            mc.mcCntlGcodeExecuteWait(inst, "G69")
            return false
        end
    end

    -- Verify file exists
    local testFile = io.open(shapingFilePath, "r")
    if not testFile then
        wx.wxMessageBox(string.format("Shaping file not found:\n%s", shapingFilePath),
            "File Not Found", wx.wxOK + wx.wxICON_ERROR)
        mc.mcCntlGcodeExecuteWait(inst, "G69")
        return false
    end
    testFile:close()

    -- ========== OPEN REPORT FILE ==========

    local pianoFolderPath = logsDir .. "\\" .. pianoFolder
    local pianoName = pianoFolder
    local reportPath = pianoFolderPath .. "\\" .. pianoName .. "_Report.txt"
    reportFile = io.open(reportPath, "a")
    if reportFile then
        for _, msg in ipairs(reportMessages) do
            reportFile:write(msg)
        end
        reportFile:flush()
    end

    -- ========== CLEANUP AND QUEUE FILE ==========

    -- Retract to machine Z0 (G68 rotation remains active for G-code execution)
    mc.mcCntlGcodeExecuteWait(inst, "G90 G53 G0 Z0")

    -- Close any currently loaded G-code file
    mc.mcCntlCloseGCodeFile(inst)

    -- Update the piano's log file
    local timestamp = os.date("%Y-%m-%d %H:%M:%S")
    writeReport(string.format("===== Final Shaping Started ====="))
    writeReport(string.format("Fixture ID: %d", fixtureID))
    writeReport(string.format("Section: %s", keySection or "Unknown"))
    writeReport(string.format("G-code file: %s", shapingFilePath))

    if reportFile then
        reportFile:close()
    end

    -- ========== DEFERRED FILE LOAD ==========

    local markerPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Temp\\DeferredGCode.txt"
    local markerFile = io.open(markerPath, "w")
    if markerFile then
        markerFile:write(shapingFilePath)
        markerFile:close()
        writeReport("Deferred load marker created: " .. markerPath)
    else
        wx.wxMessageBox("Failed to queue G-code file for execution.", "Error", wx.wxOK + wx.wxICON_ERROR)
        return false
    end

    mc.mcCntlSetLastError(inst, string.format("Shaping file ready - %s %s", pianoFolder, keySection or ""))
    return true
end







function ProbeScripts.Debug(inst)
    -- Test Probe() auto-abort on cycle stop
    -- Probe() now throws error("MACHINE_STOPPED") if state is IDLE/HOLD

    local logPath = "C:\\Mach4Hobby\\Profiles\\BLP\\Logs\\DebugProbeTest.txt"
    local logFile = io.open(logPath, "w")

    if not logFile then
        wx.wxMessageBox("Failed to open log file: " .. logPath, "Error", wx.wxOK)
        return
    end

    local function log(msg)
        local timestamp = os.date("%H:%M:%S")
        local line = string.format("[%s] %s\n", timestamp, msg)
        logFile:write(line)
        logFile:flush()
        mc.mcCntlSetLastError(inst, msg)
    end

    -- Cleanup function
    local function cleanup()
        log("=== CLEANUP CALLED ===")
        log("Would clear G68, close files, etc.")
    end

    log("===== PROBE() AUTO-ABORT TEST =====")
    log("Probe() now throws MACHINE_STOPPED if state is IDLE/HOLD")
    log("Press Cycle Stop during probing - should abort on NEXT probe call")
    log("")

    local startTime = os.time()
    local probeCount = 0

    local ok, err = pcall(function()
        log("Starting probe sequence...")

        for i = 1, 10 do
            log(string.format("--- Probe %d of 10 ---", i))

            -- Use Probe() directly - it now throws on IDLE/HOLD state
            local edgeValue, success = ProbeScripts.Probe(inst, 5, false, true, 0.5, 40, true, nil)

            if success then
                probeCount = i
                log(string.format("  Success! Edge value: %.6f", edgeValue))
            else
                log(string.format("  Probe failed (no hit), edge value: %.6f", edgeValue))
                -- Note: This is a normal failure, not cycle stop
                -- Cycle stop would have thrown before we got here
            end

            wx.wxMilliSleep(500)
        end

        log("")
        log("=== ALL PROBES COMPLETED ===")
    end)

    local elapsed = os.time() - startTime

    log("")
    log(string.format("pcall returned: ok=%s, err=%s", tostring(ok), tostring(err)))
    log(string.format("Probes completed: %d", probeCount))
    log(string.format("Elapsed time: %d seconds", elapsed))

    if not ok then
        log("")
        log("=== ABORT DETECTED - RUNNING CLEANUP ===")
        cleanup()
        log("=== CLEANUP COMPLETE ===")

        logFile:close()

        wx.wxMessageBox(string.format(
            "Probing interrupted!\n\nError: %s\nCompleted %d probes before abort.\n\nCleanup executed.\n\nSee log: %s",
            tostring(err), probeCount, logPath),
            "Aborted", wx.wxOK + wx.wxICON_WARNING)
    else
        log("")
        log("=== SUCCESS - WOULD CREATE TRIGGER ===")

        logFile:close()

        wx.wxMessageBox(string.format(
            "All probes completed!\n\nWould create Fusion trigger here.\n\nSee log: %s",
            logPath),
            "Success", wx.wxOK + wx.wxICON_INFORMATION)
    end
end


function probescripts()
end